<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>《达洛维夫人》伍尔夫</title>
      <link href="/post/3715903088.html"/>
      <url>/post/3715903088.html</url>
      
        <content type="html"><![CDATA[<h1 id="《达洛维夫人》伍尔夫"><a href="#《达洛维夫人》伍尔夫" class="headerlink" title="《达洛维夫人》伍尔夫"></a>《达洛维夫人》伍尔夫</h1><p>没有序言、没有介绍，封面之后的第一页就是小说的正文，出场的第一个人物就是达洛维夫人。当你认为自己是以上帝视角，从外界的角度看达洛维夫人的故事时，你会突然发现自己跳进了达洛维的第一视角、在达洛维对面的彼得的第一视角、与达洛维在公园擦肩而过的路人的第一视角；于是，伴随着第一视角而来的，是大篇幅的、随着意识流动的、直白的心理活动；而当你逐渐适应了第一视角，试图思考达洛维和彼得的爱情故事时，你能发现自己又再次跳出了内在世界，再次关注外界的树、喷泉和花——这就是意识流小说《达洛维夫人》给我的第一印象。</p><h3 id="混乱"><a href="#混乱" class="headerlink" title="混乱"></a>混乱</h3><p>先谈谈“混乱”吧。</p><p>我个人认为，意识流难读的原因，其实在于其不同视角的多次、快速切换，以及随着意识（而非事件发生逻辑）产生的“流动”。比如在《达洛维夫人》中，从达洛维夫人的视角，到昔日恋人彼得的视角的切换，没有任何的过渡，甚至可以说是很突兀地，中止了原来发散的意识，跳入一个完全不同的意识；而随着意识的流动则更容易让人心生疑惑，似乎上一句话还在谈花，下一句就是与之完全不相干的事物、思绪。</p><p>而在所有的“混乱”或者说“意识流”里，给我留下最深的印象的，其实是塞普蒂默斯的意识片段。塞普蒂默斯能把从外界接受到的信号无限放大，甚至无可抑制地联想、歪曲，直至让自己陷入痛苦怀疑的境地。不过，虽然同样是意识的混乱与遐想，塞普蒂默斯的混乱与《罪与罚》中的拉斯柯尔尼科夫的“疯癫”又有着明显的不同——拉斯柯尔尼科夫的想法热烈、迅猛、有清晰的思考，也由此常常出现前后矛盾、自我修正；相比之下，塞普蒂默斯的思考较为单线程，更像是一股脑地往极端上走，把外界的所有信号，套进固有的、错误的、自我的认知体系中，不加思考也无所谓修正。</p><p>当然，这是较为极端的“混乱意识”。普通的“混乱”如何呢？我反倒觉得，比起《使女的故事》中，使女的“混乱”更多是体现其内心的痛苦和绝望，达洛维夫人中的“意识流动”，更像是想法丰富、情绪充沛的高敏感人群的“碎碎念”——是看到日常的事物，根据自己的经历、特定的心境，萌发出的想法——哪怕只是一闪而过。其中，我认为描写“意识”（而不是第三视角“偷听”的心理活动）的明显表征，在于意识的随时中断的特性。比如此刻我正在写下我脑海中的想法时，我会突然感受到一阵风从窗户中吹进来，此刻倘若真切地记录下我脑海中的活动，就是：意识具有一种——哦，好像有一阵冷风吹过——随时可中断，或者说随时受影响，而非独立、完整地生发大篇幅的“独白”。而对这种普通“混乱”的理解程度，我认为更多关系读者自身的性格特质，越是相近，越不存在理解上的障碍。</p><p>然而，无论是上述的哪种“混乱”，无疑都增加了阅读难度，但这意味着“混乱”就不可取吗？我想，不是这样的。</p><p>视角的多次且迅速的切换，虽然让人不容易适应，但你可以从这种切换中获得完全不同的阅读体验。比如说，作为昔日恋人的克拉丽莎和彼得双方，在意识中思考（或者说回忆）两人的结识、恋爱过程时，产生了明显的冲突——明明是同时发生于两方的经历，由于不同的偏好选择、逻辑体系，二者回忆的重点、顺序均有明显区别。同时，在爱恋记忆的唤醒过程中，二者对对方的性格描述都分别与自己的认知有明显冲突，甚至两人都认为自己非常了解对方。再比如说，新婚夫妇卢克雷齐娅和塞普蒂默斯两人，当他们发生真实的交互时，双方对交互信号的处理有着相当显著的差别，甚至可以随着意识的延申，可能向着完全不同的两个方向发展。还有，主人克拉丽莎和女仆基尔曼小姐会同时认为对方是虚伪、傲慢的。</p><p>我认为，这正是意识流小说中，自由、不受逻辑限制的切换才能够展示出来的，与传统小说固定于一方的视角相比，你能够很奇妙地发现差异。当然，我并不否认传统小说中也存在相当多的视角切换，但无可置疑的是，其一定是受到叙事逻辑所限的。即使是我很喜欢的双线描写的写法，也需要先在一方视角进行清晰、充足地展开，才能考虑填埋抑或是开挖另一条线。</p><p>所以，可以在一定程度上来说，混乱带来了更自由的叙事，和更加即时性的冲突，容易产生更微妙、更有趣的化学反应。</p><p>当然，仅仅是混乱，完全发散、没有主题、没有任何外延限制的混乱，只能成为“癫狂病人”的日志，而不能成为小说。所以比起体味“混乱”给我带来的惊喜，“混乱”中的“秩序”让我进一步爱上了这本书。</p><h3 id="秩序"><a href="#秩序" class="headerlink" title="秩序"></a>秩序</h3><p>我开始发现，那些在小说最开头，达洛维的视角里一闪而过的、支离破碎的、令人费解的、没有意义的片段，逐渐得到了详实、丰富、又合乎逻辑的展开。</p><p>在克拉丽莎所见，路中间有一对奇怪的青年夫妇，一位会定定地站在路中间，说些什么“树是活的，没有罪”这样让人摸不着头脑的话，另一位则迅速地把他拉走。在彼得所见，公园长椅坐着一对奇怪的男女，一位不时看着天空，嘴里念叨着什么，一位则苦恼地看着他，或是说着自己的话。在这对奇怪的男女里，塞普蒂默斯患上了精神疾病，而当时的社会的不了解、霍斯大夫信誓旦旦的“没有病”的诊断、另一位“精神”医生的“完全孤立”疗法的提出，只让塞普蒂默斯倍感压力、痛苦，甚至没有希望；而卢克雷齐娅，从最开始和旁人一样困惑、不理解，到逐渐选择接纳、相信和支持自己的丈夫。这一动态的变化，不止在以他们作为主体的描写中，还在看似无逻辑的“意识流动”中悄然发生。这种细节的前后自洽，正是使我体会到“秩序感”的一大来源。</p><p>此外，还有在混乱的、对立的性格描述中，奇妙地发生“综合”，然后无意识地表现在人物上的自洽；以及，虽然多次向外延申，却始终没有脱离小说主体内容的框架、逻辑上的自洽。</p><h3 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h3><p>然而，除了奇妙的“混乱”和“秩序”，我同样折服于《达洛维夫人》出现的大量的、非同寻常的比喻。我曾经形容《长恨歌》中的比喻是绵软的、富有小家碧玉的情态的，《人生清单》中的比喻是清新而别致的，《情人》中的比喻是飘渺而繁复的，那么《达洛维夫人》中的比喻给我的感觉是近乎极致的生动和出乎意料——在拟人中，哈里街上的钟声作为不同人物的连结点，是伸出长长的手来抓人的；抽象的名词，化身为有生动情态、有自己的小私心，有时还颐指气使地做着指挥的人；经过无数年代的小路化身为老妇人，站在风中寻求“救济”；而在拟物中，沉默、冷静但美丽的伊丽莎白，是和风中的白杨……</p><p>但不得不提的是，作为一本译文小说，还是不可避免地受到翻译的限制，比如存在一些语句不太符合汉语的语言习惯，以及在视角变换时，汉语人称代词繁多且混乱导致的指代不明，还有部分直接引语与间接引语之间的转换存在明显问题。而作为外国小说，也难免遇到长长的、拗口的、难记的、常常分离开的姓和名，这使得我不得不翻回前文，判断名和姓指代的是否是同一个人。</p><p>但我认为，这些瑕疵都不能掩盖《达洛维夫人》本身的魅力，我依旧深深喜欢上了这本书，并且认为其中的意识流部分非常出彩，值得一试。</p><p>第一次写于2022年11月04日。</p>]]></content>
      
      
      <categories>
          
          <category> 偷得浮生半日闲 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 伍尔夫 </tag>
            
            <tag> 小说 </tag>
            
            <tag> 意识流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《到灯塔去》伍尔夫</title>
      <link href="/post/1167721442.html"/>
      <url>/post/1167721442.html</url>
      
        <content type="html"><![CDATA[<h1 id="《到灯塔去》伍尔夫"><a href="#《到灯塔去》伍尔夫" class="headerlink" title="《到灯塔去》伍尔夫"></a>《到灯塔去》伍尔夫</h1><p>同样是伍尔夫的意识流小说，《到灯塔去》和《达洛维夫人》<a href="/post/3715903088.html" title="《达洛维夫人》伍尔夫">《达洛维夫人》伍尔夫</a>有相似又有不同。相似之处在于，伍尔夫一贯地使用了其灵活而细腻的笔触来展现“意识的流动”，毫无提示的视角切换，毫无预警的所指转换，这些都是让人不知觉陷入她的表述中；然而，比起《达洛维夫人》只讲述半天内发生的事情（这点与《到灯塔去》的第一部分类似），《到灯塔去》还增加了第二部分和第三部分。其中，第二部分的写法很特别，以景色描写为无形之线，纺织十年的光阴，连接前的第一部分和后的第三部分；第三部分则有些精神上“朝圣”的意味。</p><h3 id="一、小说人物"><a href="#一、小说人物" class="headerlink" title="一、小说人物"></a>一、小说人物</h3><p>小说有三个关键人物——拉姆齐夫人、拉姆齐和莉丽。</p><h4 id="1-拉姆齐夫人"><a href="#1-拉姆齐夫人" class="headerlink" title="1.拉姆齐夫人"></a>1.拉姆齐夫人</h4><p>在对拉姆齐夫人的态度上，译者认为伍尔夫主要在表达“拉姆齐夫人伟大、无私的爱跨越了时间和空间”。实际上，我认为拉姆齐夫人的形象与达洛维夫人有些相似，不过伍尔夫的确赋予了拉姆齐夫人更多“爱”的付出，并且毋庸置疑的是，拉姆齐夫人展现出的爱足够无私，足够伟大。</p><p>但我并不认为伍尔夫只是一味地赞叹拉姆齐夫人的爱，将其捧上神坛高歌。伍尔夫会借助莉丽之口，对拉姆齐夫人进行质疑——“想到拉姆齐夫人带着毫不动摇的冷静态度，硬要自作主张地把她完全无法理解的命运强加给她，她几乎歇斯底里地大笑起来”；同时，也会借助拉姆齐夫人的心理活动，表现一小部分的自省——“她被某种力量驱使着前进……几乎对她自己来说，似乎这也是一种逃避”。此外，在最后的晚餐一幕，拉姆齐夫人也有出神不愿意扮演“女主人”角色的片刻，且在拉姆齐夫人施展她的关怀时，伍尔夫也借旁观的莉丽之口，表明她的关怀并非真正为他人，相反，更像是为了满足自己，带着“施恩于人”的傲慢。因此，我认为拉姆齐夫人的形象构建也有着自私、扮演“夫人”角色的可能性。</p><h4 id="2-拉姆齐"><a href="#2-拉姆齐" class="headerlink" title="2.拉姆齐"></a>2.拉姆齐</h4><p>对于拉姆齐，伍尔夫的描述似乎是拉姆齐夫人的反面，他足够理性却完全不近人情——对孩子的欺骗他只会残忍地告诉他事实，并且得意地认为孩子就应该学会接受生活的真相；作为有所成就的哲学家，他勇敢地向未踏足之地前进——“如果说伟大工作是从A到Z，那么现在我已经到了Q，下一个呢，下一个是R，我要冲击R”；但他又时常展现出软弱的一面，希翼通过获得他人（尤其是拉姆齐夫人）的同情来获得心理安慰。我起初认为拉姆齐的刻画比较单一稳定，但在第三部中，伍尔夫借詹姆斯和凯姆的想法：“如果他说我们也终将死去，就太扫兴了”来展现拉姆齐的转变——他并没有和往常一样这么说。</p><p>说完拉姆齐夫人和拉姆齐，还可以谈谈他们共同建构起的婚姻形象。在搜索资料时，我看到有学者的观点认为借助拉姆齐夫妻，伍尔夫探讨了理性和感性的一对完美融合，我有比较不同的意见。就我所读，伍尔夫展现了这样的夫妻状态：“那个黄铜的鸟嘴，那把渴望的弯刀…那个自私的男人，扑过去拼命地吮吸、砍伐”（拉姆齐从夫人处获取同情和能量）、“他那样如此公开地在众目睽睽之下求助于她，这使她感到不安（拉姆齐夫人认为自己不应当高过丈夫）、”她不敢告诉他：温室屋顶的修理费用也许会达到五十英镑“（拉姆齐是家里的甩手掌柜）。但比起赞扬它的融洽和完美，我个人认为，伍尔夫也许更多只是展示，或者再带有一点点自省的怀疑——“说不清是什么道理…突然降临到他们身上…使他们成为婚姻的象征：丈夫和妻子”。</p><h4 id="3-莉丽"><a href="#3-莉丽" class="headerlink" title="3.莉丽"></a>3.莉丽</h4><p>最后是莉丽，莉丽的角色很独特，有时作为一个旁观者，观察、评价小说中出现的其他人，也有时陷入自己意识的泥沼。而对于拉姆齐夫人和拉姆齐以及其他任务的态度，她也有时批评，有时突然理解而称赞。而到小说的最后，莉丽对两方都和解了——她理解了拉姆齐夫人的爱，也理解了拉姆齐先生所渴望的同情（虽然她还是无法说出口），也因此最终得以在她画卷完成十年未完成之笔，这也是为什么我认为本书第三部类似精神“朝圣”的一部分原因。</p><p>当然，每个人都因为自己独特的生命体验，会对作品有不同的解读，译者也许与原著有比我更近的距离，学者也比我具有更专业的文学解读视角。但至少在此时此刻，我的感受和我的解读是这样的。</p><h3 id="二、人性之剖析与杂谈"><a href="#二、人性之剖析与杂谈" class="headerlink" title="二、人性之剖析与杂谈"></a>二、人性之剖析与杂谈</h3><p>除此之外，如果说读《达洛维夫人》给我最大的感触是混乱与秩序的合理配置，《到灯塔去》则让我更加深刻地体会到伍尔夫对人性观察之细微、表达之独特。</p><p>古今中外的文学作品从来不乏描写人性，即使不以人性的描写为表达目的，人物作为其基本要素之一，也几乎无可避免地由作家来构建、服务于表达。但人性往往集中于一个面来展现，例如并不泾渭分明的善良与邪恶、克制与欲望。</p><p>而于伍尔夫而言，意识作为她表达的承载体，人性被切割成数不清的碎片，不仅有些“断裂”，并且可能在不同部分折射出不同的特点。例如，拉姆齐夫人回忆起与塔斯莱一起进城，对他的态度就变化得很快，在上一刻还是赞扬——“她几乎都要爱上他了”，下一刻就转变为讨厌——“真是扫兴的家伙”。这是一个我很喜欢的小细节，一方面，评价者是复杂、变化莫测的，会随着外部的信息重新构建印象，而另一方面，被评价的人本身也是复杂与变化的。</p><p>人格心理学认为，人格是在遗传与环境的交互作用下，个体所具有的典型而独特、稳定而有差异的心理品质组合系统。这种“稳定性”是否与我提到的“碎片”相冲突呢，我认为不然。因为二者讨论的时间范围并不相同，前者在客观上占据相当的时间，而“碎片”则更多是占据一定“心理时间”进行讨论。</p><p>关于“物理时间”和“心理时间”，这点译者也有在序中提到，达洛维夫人和到灯塔去的第一部，客观时间上都只有半天；而到灯塔去的第二部篇幅不长，客观时间却又十年。（其实在这里我想起，马原老师在课上提到，康德认为时间与空间不过是受限于人类观测方式的产物，而非真实存在的物质形态。）</p><p>第一次写于2024年03月30日。</p>]]></content>
      
      
      <categories>
          
          <category> 偷得浮生半日闲 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 伍尔夫 </tag>
            
            <tag> 小说 </tag>
            
            <tag> 意识流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mac用ssh连linux服务器</title>
      <link href="/post/1909324461.html"/>
      <url>/post/1909324461.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>网上的一些ssh免密连接linux服务器的资料都写的过于复杂，因此笔者写了一份简明的教程。</p><p>配置如下：</p><ul><li>客户端（发起SSH连接的一方）：<strong>Mac Sonoma14.4.1</strong> </li><li>服务器（接受SSH请求的一方）：22.04.1-Ubuntu </li></ul><h1 id="简单SSH连接"><a href="#简单SSH连接" class="headerlink" title="简单SSH连接"></a>简单SSH连接</h1><p>基本的<code>ssh</code>命令格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh [用户名]@[主机地址]</span><br></pre></td></tr></table></figure><p>例如，如果用户名是<code>john</code>，想要连接到主机地址为<code>example.com</code>的远程服务器，使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh john@example.com</span><br></pre></td></tr></table></figure><p>这个命令会尝试以用户<code>john</code>的身份建立到<code>example.com</code>的SSH连接。如果连接成功，将需要提供密码（如果有的话），之后就可以开始远程操作该服务器了。</p><p>可以使用远程主机的IP地址来代替域名。例如，如果远程服务器的IP地址是<code>192.168.1.100</code>，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh 用户名@192.168.1.100</span><br></pre></td></tr></table></figure><h1 id="SSH免密连接"><a href="#SSH免密连接" class="headerlink" title="SSH免密连接"></a>SSH免密连接</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>SSH免密连接需要在客户端生成公钥和私钥：</p><ul><li>公钥：公钥将复制到服务器一端。</li><li>私钥：私钥要保存在客户端本地，也就是Mac上。</li></ul><p>在SSH连接的时候，会根据公钥和私钥进行验证，具体的过程如下：</p><blockquote><ul><li>服务器使用存储的公钥对客户端发送的认证请求进行加密，生成一个挑战（challenge）。</li><li>客户端使用自己的私钥对挑战进行解密，然后将解密结果发送回服务器。</li><li>服务器验证收到的解密结果是否与原始挑战匹配。如果匹配，服务器就知道客户端持有对应的私钥，因此认证成功</li></ul></blockquote><h2 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h2><h3 id="省流"><a href="#省流" class="headerlink" title="省流"></a>省流</h3><p>如果不想知道详细的过程，可以直接执行以下的命令：</p><p>首先在Mac终端上执行下面指令生成公钥秘钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;your_email@qq.com&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>这里用任意邮箱替代<code>&quot;your_email@qq.com&quot;</code>即可。</p></blockquote><p>然后在终端中，SSH连接到服务器上并进行一系列权限设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh [用户名]@[主机地址]</span><br><span class="line"><span class="built_in">chmod</span> 700 ~/.ssh</span><br><span class="line"><span class="built_in">chmod</span> 600 ~/.ssh/authorized_keys</span><br><span class="line">sudo <span class="built_in">chown</span> [用户名]:[用户名] ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>在终端中，用<code>exit</code>退出SSH：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>在终端中，拷贝公钥到服务器<code>~/.ssh/authorized_keys</code>中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id [用户名]@[主机地址]</span><br></pre></td></tr></table></figure><p>之后就可以用ssh免密登陆了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh [用户名]@[主机地址]</span><br></pre></td></tr></table></figure><h3 id="生成私钥与公钥"><a href="#生成私钥与公钥" class="headerlink" title="生成私钥与公钥"></a>生成私钥与公钥</h3><p>首先，打开Mac上的终端（Command+空格搜索终端即可）。然后输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;your_email@qq.com&quot;</span></span><br></pre></td></tr></table></figure><ul><li><code>-t rsa</code>：指定要创建的密钥类型。这里使用的是RSA算法，RSA是一种非对称加密算法，广泛用于SSH密钥生成。</li><li><code>-b 4096</code>：指定密钥的长度。这里设置为4096位。密钥长度越长，安全性越高，但同时也会增加计算负担。4096位是一个当前普遍认为安全的长度。</li><li><code>-C &quot;your_email@qq.com&quot;</code>：添加注释。这里的注释是邮箱<code>your_email@qq.com</code>，这个注释会添加到公钥文件中，帮助识别密钥的拥有者。这通常用于当多个密钥存在时，区分不同的密钥。</li></ul><p>这个秘钥会生成在你的Mac的<code>用户名/.ssh</code>文件夹下。</p><h3 id="更改服务器中文件夹权限"><a href="#更改服务器中文件夹权限" class="headerlink" title="更改服务器中文件夹权限"></a>更改服务器中文件夹权限</h3><h4 id="更改-ssh文件夹权限"><a href="#更改-ssh文件夹权限" class="headerlink" title="更改.ssh文件夹权限"></a>更改.ssh文件夹权限</h4><p>先使用密码<a href="#简单SSH连接">手动登录到服务器</a>上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh [用户名]@[主机地址]</span><br></pre></td></tr></table></figure><p>然后检查 <code>.ssh</code> 目录权限（之后要把公钥复制到.ssh/authorized_keys下）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -ld ~/.ssh</span><br></pre></td></tr></table></figure><p>会看到这样的输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drwxrwxr-x 2 node1 node1 4096  4月 20 20:47 /home/node1/.ssh</span><br></pre></td></tr></table></figure><p><code>drwxrwxr-x</code>：这部分表示文件（或目录）的权限。这里<code>d</code>表示这是一个目录。</p><ul><li>接下来的三个字符<code>rwx</code>表示目录所有者（user，这里是node1）的权限，</li><li>再接下来的三个字符<code>rwx</code>表示所属组（group，这里也是node1）的权限。</li><li>最后的三个字符<code>r-x</code>表示其他用户（others）的权限。</li></ul><p>所以这里的意思是所有者和所属组有读写和执行权限，而其他用户有读和执行权限，但没有写权限。</p><p><code>.ssh</code> 目录的权限过于宽松，任何用户都可以进入这个目录。所以更改一下其的权限，将 <code>.ssh</code> 目录的权限修改为只有所有者可以读写执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 700 ~/.ssh</span><br></pre></td></tr></table></figure><blockquote><p><code>chmod</code>（change mode）： <code>chmod</code> 命令用于改变文件或目录的访问权限，权限设置使用符号表示法或八进制表示法。</p></blockquote><h4 id="更改-ssh-authorized-keys的权限"><a href="#更改-ssh-authorized-keys的权限" class="headerlink" title="更改.ssh/authorized_keys的权限"></a>更改.ssh/authorized_keys的权限</h4><p>查看<code>.ssh/authorized_keys</code>的权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>输出应该如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r-- 1 root root 96  3月 11 21:26 /home/node1/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p><code>-rw-r--r--</code>：这部分表示文件（或目录）的权限。</p><ul><li>这里<code>-</code>表示这是一个普通文件。接下来的三个字符<code>rw-</code>表示文件所有者（user，这里是root）有读写权限，没有执行权限；</li><li>再接下来的三个字符<code>r--</code>表示所属组（group，这里也是root）有读权限，没有写和执行权限；</li><li>最后的三个字符<code>r--</code>表示其他用户（others）有读权限，没有写和执行权限。</li></ul><p><code>authorized_keys</code>文件可以被所有用户读取，这通常不是推荐的做法。并且<code>authorized_keys</code> 文件目前属于 <code>root</code> 用户，应该改为目前的登录用户（也就是ssh时输入的用户名部分）。</p><p>首先，修改 <code>authorized_keys</code> 文件权限：，将 <code>authorized_keys</code> 文件的权限修改为只有所有者可以读写。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 600 ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>然后修改 <code>authorized_keys</code> 文件所有者为目前登录的用户（将你的用户名替换掉<code>[用户名]</code>这一部分）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">chown</span> [用户名]:[用户名] ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><blockquote><p><code>chown</code>（change owner）： <code>chown</code> 命令用于改变文件或目录的所有者和/或所属组。</p></blockquote><h3 id="拷贝公钥"><a href="#拷贝公钥" class="headerlink" title="拷贝公钥"></a>拷贝公钥</h3><p>刚才的一系列操作都是为了能将生成的公钥拷贝到<code>~/.ssh.authorized_keys</code>下。然后在客户端（你的Mac）上，使用这个命令进行拷贝：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id [用户名]@[主机地址]</span><br></pre></td></tr></table></figure><h3 id="测试SSH免密登录是否成功"><a href="#测试SSH免密登录是否成功" class="headerlink" title="测试SSH免密登录是否成功"></a>测试SSH免密登录是否成功</h3><p>上面的都设置完之后，用<code>exit</code>指令可以退出目前的ssh登录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>然后再次使用ssh登录，就不需要密码了！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh [用户名]@[主机地址]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 重生之我是程序员 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学海泛舟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu配置C++20环境</title>
      <link href="/post/1240948986.html"/>
      <url>/post/1240948986.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文写于2024.5.19，我的系统为22.04.1-Ubuntu，默认带的是gcc11，它还不支持C++20。为了用上一些C++20的特性，便打算配置一下C++20的环境，期间走了不少弯路，故写一份笔记造福后人。</p><p>这里列出我的一些配置：</p><ul><li>22.04.1-Ubuntu</li><li>CLion 2024.1</li></ul><h1 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h1><h2 id="下载clang18"><a href="#下载clang18" class="headerlink" title="下载clang18"></a>下载clang18</h2><p>首先，需要下载支持C++20的编译器。从<a href="https://zh.cppreference.com/w/cpp/compiler_support/20">cppreference</a>上可以找到支持C++20的编译器有哪些。这里选择下载clang18，因为当下的gcc13尚不支持C++20的模块功能。</p><blockquote><p>如果用cmake，cmake需要3.28以上才支持C++20模块功能</p></blockquote><p>参考一篇<a href="https://zhuanlan.zhihu.com/p/670338052">知乎文章</a>，在命令行下输入以下内容安装LLVM18（其带有clang18）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://apt.llvm.org/llvm.sh</span><br><span class="line">chmod +x llvm.sh</span><br><span class="line">sudo ./llvm.sh 18</span><br></pre></td></tr></table></figure><p>下载完之后用下面的命令查看一下clang18是否成功安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang-18 --v</span><br></pre></td></tr></table></figure><p>输出应该如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Ubuntu clang version 18.1.6 (++20240517093811+3d0752b9492e-1~exp1~20240517213934.128)</span><br><span class="line">Target: x86_64-pc-linux-gnu</span><br><span class="line">Thread model: posix</span><br><span class="line">InstalledDir: /usr/bin</span><br><span class="line">Found candidate GCC installation: /usr/bin/../lib/gcc/x86_64-linux-gnu/11</span><br><span class="line">Found candidate GCC installation: /usr/bin/../lib/gcc/x86_64-linux-gnu/12</span><br><span class="line">Selected GCC installation: /usr/bin/../lib/gcc/x86_64-linux-gnu/12</span><br><span class="line">Candidate multilib: .;@m64</span><br><span class="line">Selected multilib: .;@m64</span><br></pre></td></tr></table></figure><h2 id="下载gcc12"><a href="#下载gcc12" class="headerlink" title="下载gcc12"></a>下载gcc12</h2><p>从刚才<code>clang-18 --v</code>可以看到，clang18需要gcc12，如果没有的话，需要安装一下。</p><blockquote><p>具体而言，是需要gcc12带的C++标准库libstdc++。如果没有的话会报错。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selected GCC installation: /usr/bin/../lib/gcc/x86_64-linux-gnu/12</span><br></pre></td></tr></table></figure><p>用下面的命令安装gcc12和g++12：</p><blockquote><ul><li><code>gcc</code> 是GCC套件中的C语言编译器，用于编译C语言源代码。</li><li><code>g++</code> 是GCC套件中的C++语言编译器，用于编译C++语言源代码。</li></ul></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gcc-12 g++12</span><br></pre></td></tr></table></figure><h2 id="安装libc"><a href="#安装libc" class="headerlink" title="安装libc++"></a>安装libc++</h2><p>gcc12带的C++标准库libstdc++是不含C++20的库的（gcc13带的C++标准库才含有C++20的库），所以还需要下载llvm带的另一个C++标准库libc++（是的，刚才安装llvm-18的时候并没有安装这个C++标准库）。</p><p>用以下命令来安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libc++-18-dev libc++abi-18-dev</span><br></pre></td></tr></table></figure><h2 id="配置工具链"><a href="#配置工具链" class="headerlink" title="配置工具链"></a>配置工具链</h2><p>打开CLion的设置，打开构建、执行、部署中的工具链一项。</p><p><img src="/images/Ubuntu配置C20环境.assets/image-20240519114554944.png" alt="image-20240519114554944"></p><p>应该可以在/usr/bin中找到clang-18（点C Compiler旁边像文件夹的那个按钮）。</p><p><img src="/images/Ubuntu配置C20环境.assets/image-20240519114703299.png" alt="image-20240519114703299"></p><p>同样，设置C++ compiler为clang++-18，到这里编译器就设置好了。</p><h2 id="更改cmakelist"><a href="#更改cmakelist" class="headerlink" title="更改cmakelist"></a>更改cmakelist</h2><p>现在直接编译还成功不了，因为clang-18会去找gcc12的标准库libstdc++，而其还不支持C++20。所以需要设置标准库为我们安装的libc++-18。在cmakelist.txt中添加如下语句：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -stdlib=libc++&quot;</span>)</span><br></pre></td></tr></table></figure><p>在CMake中，<code>CMAKE_CXX_FLAGS</code>是一个变量，它用于存储编译C++源文件时的编译器标志。这行CMake代码是修改这个变量的值的命令，通过将<code>-stdlib=libc++</code>添加到现有的编译器标志中。</p><p>这行代码的作用是告诉C++编译器（比如Clang）使用<code>libc++</code>作为标准的C++库而不是默认的<code>libstdc++</code>。<code>libc++</code>是LLVM项目的一部分，它是C++标准库的一个实现，旨在提供对最新C++标准的良好支持。</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>最后用一个小文件测试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;format&gt;</span> <span class="comment">//format是C++20引入的</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;std::format(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cmakelist.txt如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.28</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">test</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">20</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_SCAN_FOR_MODULES <span class="keyword">OFF</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_compile_options</span>(-std=c++<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -stdlib=libc++&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="keyword">test</span></span><br><span class="line">        main.cpp)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果成功输出了<code>hello world!</code>，那么就配置成功了。</p>]]></content>
      
      
      <categories>
          
          <category> 重生之我是程序员 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学海泛舟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础</title>
      <link href="/post/2575511367.html"/>
      <url>/post/2575511367.html</url>
      
        <content type="html"><![CDATA[<p>参考文章：<a href="https://blog.algorithmpark.xyz/2023/07/23/language/python/index/">算法乐园的Python笔记</a></p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="print函数"><a href="#print函数" class="headerlink" title="print函数"></a>print函数</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>最简单的用法就是直接打印一个字符串：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br></pre></td></tr></table></figure><p>这将在控制台上输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, World!</span><br></pre></td></tr></table></figure><h3 id="打印多个值"><a href="#打印多个值" class="headerlink" title="打印多个值"></a>打印多个值</h3><p>你也可以在一次<code>print</code>调用中打印多个值，只需用逗号隔开它们：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello,&quot;</span>, <span class="string">&quot;World!&quot;</span>)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, World!</span><br></pre></td></tr></table></figure><h3 id="打印变量"><a href="#打印变量" class="headerlink" title="打印变量"></a>打印变量</h3><p>当然，<code>print</code>函数也可以用于打印变量的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line">y = <span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x =&quot;</span>, x, <span class="string">&quot;, y =&quot;</span>, y)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span> , y = <span class="number">20</span></span><br></pre></td></tr></table></figure><h3 id="换行与分隔符"><a href="#换行与分隔符" class="headerlink" title="换行与分隔符"></a>换行与分隔符</h3><p>默认情况下，<code>print</code>函数会在每个值之间添加一个空格，并在最后添加一个换行符。你可以通过<code>sep</code>和<code>end</code>参数来自定义这些行为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>, sep=<span class="string">&quot;-&quot;</span>, end=<span class="string">&quot;!!!\n&quot;</span>)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello-World!!!</span><br></pre></td></tr></table></figure><h3 id="格式化字符串的语法"><a href="#格式化字符串的语法" class="headerlink" title="格式化字符串的语法"></a>格式化字符串的语法</h3><p>格式化字符串使用<code>f</code>或<code>F</code>前缀来标识，后面跟着一个字符串字面量，其中可以包含花括号<code>&#123;&#125;</code>内的表达式。这些花括号内的表达式将在运行时被计算，并用其结果替换花括号。</p><h4 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;Alice&quot;</span>  </span><br><span class="line">age = <span class="number">30</span>  </span><br><span class="line">greeting = <span class="string">f&quot;Hello, my name is <span class="subst">&#123;name&#125;</span> and I am <span class="subst">&#123;age&#125;</span> years old.&quot;</span>  </span><br><span class="line"><span class="built_in">print</span>(greeting)  <span class="comment"># 输出: Hello, my name is Alice and I am 30 years old.</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，变量<code>name</code>和<code>age</code>被插入到了字符串中的相应位置。</p><h2 id="input语句"><a href="#input语句" class="headerlink" title="input语句"></a>input语句</h2><h3 id="基本用法-2"><a href="#基本用法-2" class="headerlink" title="基本用法"></a>基本用法</h3><p><code>input()</code>函数的基本用法非常简单。当调用它时，程序会暂停并等待用户输入。用户可以在命令行或交互式环境中输入文本，然后按Enter键提交输入。</p><p>下面是一个简单的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user_input = <span class="built_in">input</span>(<span class="string">&quot;请输入一些文本：&quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;你输入的是：&quot;</span>, user_input)</span><br></pre></td></tr></table></figure><p>在这个例子中，程序首先打印出提示信息”请输入一些文本：”，然后等待用户输入。用户输入的内容将被赋值给变量<code>user_input</code>，然后程序打印出”你输入的是：”后面跟着用户输入的内容。</p><h3 id="输入类型"><a href="#输入类型" class="headerlink" title="输入类型"></a>输入类型</h3><p>需要注意的是，<code>input()</code>函数返回的总是一个字符串类型。即使你输入的是一个数字，它也会被当作字符串处理。如果你需要将输入转换为其他类型（如整数或浮点数），你需要使用相应的类型转换函数。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h3 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h3><p>Python 中的单行注释以 <code>#</code> 开头。<code>#</code> 符号后面的所有内容都会被视为注释，直到该行的结束。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是一个单行注释  </span></span><br><span class="line">x = <span class="number">5</span>  <span class="comment"># 可以在代码行的末尾添加注释</span></span><br></pre></td></tr></table></figure><h3 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h3><p>Python 本身并没有直接支持多行注释的语法，但我们可以使用三重引号（<code>&quot;&quot;&quot;</code> 或 <code>&#39;&#39;&#39;</code>）来实现类似的效果。三重引号通常用于多行字符串，但如果没有将它们赋值给变量或用作其他目的，它们也可以用作多行注释。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;  </span></span><br><span class="line"><span class="string">这是一个多行注释的  </span></span><br><span class="line"><span class="string">示例。你可以在这里写下  </span></span><br><span class="line"><span class="string">多行文字来描述你的代码。  </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 或者使用三个单引号  </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;  </span></span><br><span class="line"><span class="string">这也是一个多行注释的示例，  </span></span><br><span class="line"><span class="string">和上面的三重双引号具有相同的效果。  </span></span><br><span class="line"><span class="string">选择哪种风格通常取决于个人或团队的偏好。  </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>Python 中一般以新行作为语句的结束标识，可以使用 \ 将一行语句分为多行显示。如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">128</span></span><br><span class="line">b = <span class="number">1024</span></span><br><span class="line">c = <span class="number">512</span></span><br><span class="line">d = a + \</span><br><span class="line">    b - \</span><br><span class="line">    c</span><br></pre></td></tr></table></figure><p>如果包含在 []、{}、() 括号中，则不需要使用 \。如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr = &#123;</span><br><span class="line">    a,</span><br><span class="line">    b,</span><br><span class="line">    c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Python变量及基本数据"><a href="#Python变量及基本数据" class="headerlink" title="Python变量及基本数据"></a>Python变量及基本数据</h1><h2 id="类型介绍"><a href="#类型介绍" class="headerlink" title="类型介绍"></a>类型介绍</h2><p>在Python编程语言中，数据类型是一个重要的概念，它决定了变量可以保存何种类型的数据以及可以对这些变量执行哪些操作。Python有几种基本（或内置）的数据类型，包括整数（int）、浮点数（float）、字符串（str）等，但请注意字符（char）这一概念在Python中并不作为一个独立的基本数据类型存在，字符通常被视为长度为1的字符串。</p><h3 id="1-整数（Integers）"><a href="#1-整数（Integers）" class="headerlink" title="1. 整数（Integers）"></a>1. 整数（Integers）</h3><p>整数是没有小数部分的数字，可以是正数或负数。在Python中，整数的大小只受限于可用内存。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span>   <span class="comment"># 定义一个整数</span></span><br><span class="line">y = -<span class="number">20</span>  <span class="comment"># 定义一个负整数</span></span><br></pre></td></tr></table></figure><p>Python 3中的整数是动态大小的，意味着Python整数可以处理任意大小的整数，只要内存允许。</p><h3 id="2-浮点数（Floating-Point-Numbers）"><a href="#2-浮点数（Floating-Point-Numbers）" class="headerlink" title="2. 浮点数（Floating Point Numbers）"></a>2. 浮点数（Floating Point Numbers）</h3><p>浮点数是有小数点的数字，它们用于表示实数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1.23</span>   <span class="comment"># 定义一个浮点数</span></span><br><span class="line">y = -<span class="number">4.56</span>  <span class="comment"># 定义一个负的浮点数</span></span><br></pre></td></tr></table></figure><p>浮点数在计算机中的表示是近似的，因此在进行浮点数运算时要特别注意精度问题。</p><h3 id="3-字符串（Strings）"><a href="#3-字符串（Strings）" class="headerlink" title="3. 字符串（Strings）"></a>3. 字符串（Strings）</h3><p>字符串是由零个或多个字符组成的有序字符序列。在Python中，字符串是不可变的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">&quot;Hello&quot;</span>  <span class="comment"># 定义一个字符串</span></span><br><span class="line">s2 = <span class="string">&#x27;World&#x27;</span>  <span class="comment"># 字符串也可以用单引号定义</span></span><br></pre></td></tr></table></figure><p>字符串可以通过连接（concatenation）形成新的字符串，也可以用切片（slicing）来访问子字符串。</p><h3 id="4-字符（Characters）"><a href="#4-字符（Characters）" class="headerlink" title="4. 字符（Characters）"></a>4. 字符（Characters）</h3><p>在Python中，并没有专门的“字符”数据类型。相反，字符被视为长度为1的字符串。你可以通过索引字符串来获取单个字符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;Hello&quot;</span></span><br><span class="line">char = s[<span class="number">0</span>]  <span class="comment"># 获取字符串中的第一个字符，结果为 &#x27;H&#x27;</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>char</code> 实际上是一个长度为1的字符串，它包含了字符 ‘H’。在Python中处理单个字符时，你通常会使用长度为1的字符串。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个变量money，并赋值为10</span></span><br><span class="line">money = <span class="number">10</span></span><br><span class="line"><span class="comment"># 对money变量进行减法操作，减去5</span></span><br><span class="line">money = money - <span class="number">5</span></span><br><span class="line"><span class="comment"># 打印money变量的值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;余额为&quot;</span>, money, <span class="string">&quot;元&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="查看数据类型"><a href="#查看数据类型" class="headerlink" title="查看数据类型"></a>查看数据类型</h2><p>可以使用<code>type()</code>函数来查看一个变量的数据类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义几个变量，并分别赋予不同的数据类型</span></span><br><span class="line">string_type = <span class="string">&quot;hello world&quot;</span></span><br><span class="line">int_type = <span class="number">666</span></span><br><span class="line">float_type = <span class="number">114.514</span></span><br><span class="line"><span class="comment"># 使用type()函数查看变量的数据类型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(string_type), <span class="built_in">type</span>(int_type), <span class="built_in">type</span>(float_type))</span><br></pre></td></tr></table></figure><p>运行这段代码，你会得到输出<code>&lt;class &#39;str&#39;&gt; &lt;class &#39;int&#39;&gt; &lt;class &#39;float&#39;&gt;</code>，说明这三个变量的数据类型分别是字符串、整数和浮点数。</p><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><p>在Python中，你可以使用内置的函数来进行数据类型之间的转换。常见的转换函数有<code>int()</code>、<code>float()</code>和<code>str()</code>。</p><ul><li><code>int(x)</code>：将x转换为一个整数。如果x是一个浮点数，会舍去小数部分。如果x是一个字符串，且字符串内容可以转换为整数，则会转换为相应的整数；<strong>否则会报错</strong>。</li><li><code>float(x)</code>：将x转换为一个浮点数。如果x是一个整数，会在其后面添加<code>.0</code>。如果x是一个字符串，且字符串内容可以转换为浮点数，则会转换为相应的浮点数；<strong>否则会报错</strong>。</li><li><code>str(x)</code>：将x转换为一个字符串。无论x是什么数据类型，都会转换为其对应的字符串形式。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将浮点数转换为字符串</span></span><br><span class="line">float_str = <span class="built_in">str</span>(<span class="number">114.514</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(float_str), float_str)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字符串转换为整数</span></span><br><span class="line">num = <span class="built_in">int</span>(<span class="string">&quot;11&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(num), num)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字符串转换为浮点数</span></span><br><span class="line">num2 = <span class="built_in">float</span>(<span class="string">&quot;1919.810&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(num2), num2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将整数转换为浮点数</span></span><br><span class="line">fnum = <span class="built_in">float</span>(<span class="number">11</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(fnum), fnum)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将浮点数转换为整数，注意这里不会四舍五入，而是直接舍去小数部分</span></span><br><span class="line">inum = <span class="built_in">int</span>(<span class="number">114.514</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(inum), inum)</span><br></pre></td></tr></table></figure><p>运行这段代码，你会得到以下输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &#x27;str&#x27;&gt; 114.514</span><br><span class="line">&lt;class &#x27;int&#x27;&gt; 11</span><br><span class="line">&lt;class &#x27;float&#x27;&gt; 1919.81</span><br><span class="line">&lt;class &#x27;float&#x27;&gt; 11.0</span><br><span class="line">&lt;class &#x27;int&#x27;&gt; 114</span><br></pre></td></tr></table></figure><p>注意在进行数据类型转换时，要确保转换是合法的，否则程序会报错。例如，尝试将一个包含非数字字符的字符串转换为整数或浮点数会导致<code>ValueError</code>。</p><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>标识符命名只允许出现:（和C++一样）</p><ul><li>英文字母</li><li>中文(不推荐)</li><li>数字(<strong>不可以开头</strong>)</li><li>下划线_</li></ul><h1 id="处理数据类型"><a href="#处理数据类型" class="headerlink" title="处理数据类型"></a>处理数据类型</h1><h2 id="Python的运算符介绍"><a href="#Python的运算符介绍" class="headerlink" title="Python的运算符介绍"></a>Python的运算符介绍</h2><h3 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="1. 算术运算符"></a>1. 算术运算符</h3><p>算术运算符用于执行基本的数学运算。</p><ul><li><code>+</code>：加法运算符，用于计算两个数的和。</li><li><code>-</code>：减法运算符，用于计算两个数的差。</li><li><code>*</code>：乘法运算符，用于计算两个数的积。</li><li><code>/</code>：除法运算符，用于计算两个数的商。<strong>(python两个整数相除会得到浮点数)</strong></li><li><code>//</code>：整除运算符，用于计算两个数整除后的结果（只保留整数部分）。整除取整方向默认为$−∞$。</li><li><code>%</code>：取模运算符，用于计算两个数相除后的余数。</li><li><code>**</code>：幂运算符，用于计算一个数的幂。</li></ul><h3 id="2-比较运算符"><a href="#2-比较运算符" class="headerlink" title="2. 比较运算符"></a>2. 比较运算符</h3><p>比较运算符用于比较两个值的大小关系，返回一个布尔值（True或False）。</p><ul><li><code>==</code>：等于运算符，用于判断两个值是否相等。</li><li><code>!=</code>：不等于运算符，用于判断两个值是否不相等。</li><li><code>&gt;</code>：大于运算符，用于判断左侧的值是否大于右侧的值。</li><li><code>&lt;</code>：小于运算符，用于判断左侧的值是否小于右侧的值。</li><li><code>&gt;=</code>：大于等于运算符，用于判断左侧的值是否大于或等于右侧的值。</li><li><code>&lt;=</code>：小于等于运算符，用于判断左侧的值是否小于或等于右侧的值。</li></ul><h3 id="3-逻辑运算符"><a href="#3-逻辑运算符" class="headerlink" title="3. 逻辑运算符"></a>3. 逻辑运算符</h3><p>逻辑运算符用于组合多个条件表达式，返回一个布尔值。</p><ul><li><p><code>and</code>：逻辑与运算符，当所有条件都为True时，返回True。</p></li><li><p><code>or</code>：逻辑或运算符，当至少有一个条件为True时，返回True。</p></li><li><p><code>not</code>：逻辑非运算符，用于取反一个布尔值。</p><blockquote><h4 id="Python中的逻辑判断：与、或、非"><a href="#Python中的逻辑判断：与、或、非" class="headerlink" title="Python中的逻辑判断：与、或、非"></a><strong>Python中的逻辑判断：与、或、非</strong></h4><p>在Python中，逻辑运算符用于连接布尔表达式，并根据这些表达式的真假值返回结果。与Java等其他语言相比，Python的逻辑运算符有一些独特之处，特别是在处理非布尔类型的值时。</p><h5 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h5><p>Python中的逻辑运算符包括：</p><ul><li><code>and</code>：逻辑与</li><li><code>or</code>：逻辑或</li><li><code>not</code>：逻辑非</li></ul><h6 id="逻辑运算符的行为"><a href="#逻辑运算符的行为" class="headerlink" title="逻辑运算符的行为"></a>逻辑运算符的行为</h6><h5 id="逻辑与-and"><a href="#逻辑与-and" class="headerlink" title="逻辑与 (and)"></a>逻辑与 (<code>and</code>)</h5><p>当使用<code>and</code>运算符时：</p><ul><li>如果所有表达式的值都为真（非零、非空等），则返回最后一个表达式的值。</li><li>如果有一个或多个表达式的值为假（零、空等），则返回第一个假值。</li></ul><h6 id="逻辑或-or"><a href="#逻辑或-or" class="headerlink" title="逻辑或 (or)"></a>逻辑或 (<code>or</code>)</h6><p>当使用<code>or</code>运算符时：</p><ul><li>如果有一个或多个表达式的值为真，则返回第一个真值。</li><li>如果所有表达式的值都为假，则返回最后一个假值。</li></ul><h5 id="逻辑非-not"><a href="#逻辑非-not" class="headerlink" title="逻辑非 (not)"></a>逻辑非 (<code>not</code>)</h5><p><code>not</code>运算符返回表达式的布尔否定值。如果表达式为真，则返回<code>False</code>；如果表达式为假，则返回<code>True</code>。</p><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p>下面是一些Python逻辑运算符的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 逻辑与 (and)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span> &gt; <span class="number">2</span> <span class="keyword">and</span> <span class="number">3</span> &gt; <span class="number">1</span>)  <span class="comment"># True，因为两个条件都为真</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span> <span class="keyword">and</span> <span class="number">2</span>)          <span class="comment"># 2，因为3为真，返回第二个值2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">0</span> <span class="keyword">and</span> <span class="literal">None</span>)       <span class="comment"># 0，因为0为假，返回第一个假值0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 逻辑或 (or)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span> &gt; <span class="number">2</span> <span class="keyword">or</span> <span class="number">3</span> &gt; <span class="number">1</span>)   <span class="comment"># True，因为至少有一个条件为真</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span> <span class="keyword">or</span> <span class="number">3</span> &gt; <span class="number">2</span>)       <span class="comment"># 2，因为2为真，返回第一个真值2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">0</span> <span class="keyword">or</span> <span class="literal">None</span>)        <span class="comment"># None，因为两者都为假，返回最后一个假值None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 逻辑非 (not)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">not</span> <span class="number">3</span>)            <span class="comment"># False，因为3为真值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">not</span> <span class="number">0</span>)            <span class="comment"># True，因为0为假值</span></span><br></pre></td></tr></table></figure><h4 id="为假的值"><a href="#为假的值" class="headerlink" title="为假的值"></a>为假的值</h4><p>在Python中，以下值在布尔上下文中被视为<code>False</code>：</p><ul><li>数值类型中的<code>0</code>和<code>0.0</code></li><li>空序列类型，如空字符串<code>&#39;&#39;</code>、空列表<code>[]</code>、空元组<code>()</code>、空字典<code>&#123;&#125;</code></li><li><code>None</code>对象</li><li>布尔类型本身的<code>False</code>值</li></ul><p>需要注意的是，当这些“假值”作为逻辑表达式的一部分时，它们本身会被返回作为结果，而不是布尔值<code>False</code>。这是Python逻辑运算符与其他语言（如Java）的一个主要区别。在Java中，逻辑运算符只能用于布尔表达式，并且结果总是布尔值。而在Python中，逻辑运算符可以更加灵活地用于不同类型的值，并返回这些值本身作为结果。这种特性使得Python代码在某些情况下可以更加简洁和高效。但同时也需要注意逻辑运算符的这种行为可能会带来的潜在混淆和错误。因此在使用时需要特别小心并确保理解其行为规则。</p></blockquote></li></ul><h3 id="4-位运算符"><a href="#4-位运算符" class="headerlink" title="4. 位运算符"></a>4. 位运算符</h3><p>位运算符用于对二进制位进行操作。</p><ul><li><code>&amp;</code>：按位与运算符，对两个数的二进制位进行与操作。</li><li><code>|</code>：按位或运算符，对两个数的二进制位进行或操作。</li><li><code>^</code>：按位异或运算符，对两个数的二进制位进行异或操作。</li><li><code>~</code>：按位取反运算符，对一个数的二进制位进行取反操作。</li><li><code>&lt;&lt;</code>：左移运算符，将一个数的二进制位向左移动指定的位数。</li><li><code>&gt;&gt;</code>：右移运算符，将一个数的二进制位向右移动指定的位数。</li></ul><h3 id="5-赋值运算符"><a href="#5-赋值运算符" class="headerlink" title="5. 赋值运算符"></a>5. 赋值运算符</h3><p>赋值运算符用于将表达式的值赋给变量。</p><ul><li><code>=</code>：赋值运算符，将右侧表达式的值赋给左侧的变量。</li><li><code>+=</code>：加法赋值运算符，将右侧的值加到左侧的变量上，并将结果赋给左侧的变量。</li><li><code>-=</code>：减法赋值运算符，将右侧的值从左侧的变量中减去，并将结果赋给左侧的变量。</li><li><code>*=</code>：乘法赋值运算符，将右侧的值与左侧的变量相乘，并将结果赋给左侧的变量。</li><li><code>/=</code>：除法赋值运算符，将左侧的变量除以右侧的值，并将结果赋给左侧的变量。</li><li><code>%=</code>：取模赋值运算符，将左侧变量与右侧值进行取模运算，并将结果赋给左侧的变量。</li><li><code>**=</code>：幂赋值运算符，将左侧变量进行幂运算后的结果赋给左侧的变量。</li><li><code>//=</code>：整除赋值运算符，将左侧变量与右侧值进行整除运算后的结果赋给左侧的变量。</li></ul><h3 id="6-身份运算符"><a href="#6-身份运算符" class="headerlink" title="6. 身份运算符"></a>6. 身份运算符</h3><p>身份运算符用于比较两个对象的身份是否相同。</p><ul><li><code>is</code>：判断两个标识符是否引用同一个对象。</li><li><code>is not</code>：判断两个标识符是否引用不同的对象。</li></ul><h3 id="7-成员运算符"><a href="#7-成员运算符" class="headerlink" title="7. 成员运算符"></a>7. 成员运算符</h3><p>成员运算符用于判断一个值是否存在于序列中（如列表、元组、字符串等）。</p><ul><li><code>in</code>：如果指定的值在序列中找到，则返回True，否则返回False。</li><li><code>not in</code>：如果指定的值没有在序列中找到，则返回True，否则返回False。</li></ul><p>这些运算符在Python编程中非常常用，掌握它们对于编写高效的Python代码至关重要。</p><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p>在Python中，你可以使用加号（<code>+</code>）操作符来拼接（连接）两个或多个字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">&quot;abcd&quot;</span></span><br><span class="line">s2 = <span class="string">&quot;defg&quot;</span></span><br><span class="line">s3 = s1 + s2</span><br><span class="line"><span class="built_in">print</span>(s3)  <span class="comment"># 输出：abcddefg</span></span><br></pre></td></tr></table></figure><h3 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h3><p>Python 提供了多种方式来格式化字符串，其中 <code>%</code> 操作符是一种较旧的方法，但在某些情况下仍然很有用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用%s作为字符串占位符，%d作为整数占位符，%f作为浮点数占位符</span></span><br><span class="line">num = <span class="number">114514</span></span><br><span class="line">s = <span class="string">&quot;abcde&quot;</span></span><br><span class="line">message1 = <span class="string">&quot;%s你好世界&quot;</span> % s</span><br><span class="line"><span class="built_in">print</span>(message1)  <span class="comment"># 输出：abcde你好世界</span></span><br><span class="line"></span><br><span class="line">message2 = <span class="string">&quot;%s你好世界%d&quot;</span> % (s, num)</span><br><span class="line"><span class="built_in">print</span>(message2)  <span class="comment"># 输出：abcde你好世界114514</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 另一个例子，包含浮点数</span></span><br><span class="line">s = <span class="string">&quot;绩点&quot;</span></span><br><span class="line">gpa = <span class="number">0.1</span></span><br><span class="line">num = <span class="number">666</span></span><br><span class="line">message = <span class="string">&quot;%s高达%.1f,老铁%d&quot;</span> % (s, gpa, num)</span><br><span class="line"><span class="built_in">print</span>(message)  <span class="comment"># 输出：绩点高达0.1,老铁666</span></span><br></pre></td></tr></table></figure><p>注意：<code>%.1f</code> 表示浮点数将被格式化为小数点后保留一位。</p><h4 id="字符串格式化的一种快速写法"><a href="#字符串格式化的一种快速写法" class="headerlink" title="字符串格式化的一种快速写法"></a>字符串格式化的一种快速写法</h4><p>格式:<code>f”内容&#123;变量&#125;”</code>(不关心精度控制)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;绩点&quot;</span></span><br><span class="line">gpa = <span class="number">0.1</span></span><br><span class="line">num = <span class="number">666</span></span><br><span class="line">message = <span class="string">f&quot;<span class="subst">&#123;s&#125;</span>高达<span class="subst">&#123;gpa&#125;</span>,大佬<span class="subst">&#123;num&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">print</span>(message)</span><br></pre></td></tr></table></figure><h3 id="字符转ASCII和ASCII转字符串"><a href="#字符转ASCII和ASCII转字符串" class="headerlink" title="字符转ASCII和ASCII转字符串"></a>字符转ASCII和ASCII转字符串</h3><p>在Python中，你可以使用 <code>ord()</code> 函数将一个字符转换成其对应的ASCII数值，使用 <code>chr()</code> 函数将一个ASCII数值转换成对应的字符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>))  <span class="comment"># 输出：97</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="number">97</span>))   <span class="comment"># 输出：a</span></span><br></pre></td></tr></table></figure><h3 id="字符串的大小写转化"><a href="#字符串的大小写转化" class="headerlink" title="字符串的大小写转化"></a>字符串的大小写转化</h3><p>Python 提供了几种方法来改变字符串的大小写。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 title() 方法将字符串中每个单词的首字母变成大写，其余小写</span></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;wHat a beaUTIFul GIrl!!&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.title())  <span class="comment"># 输出：What A Beautiful Girl!!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 upper() 方法将字符串中所有字母变成大写</span></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;Cpp Is The Best Programing Language&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.upper())  <span class="comment"># 输出：CPP IS THE BEST PROGRAMING LANGUAGE</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 lower() 方法将字符串中所有字母变成小写</span></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;I HATE PYTHOn&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.lower())  <span class="comment"># 输出：i hate python</span></span><br></pre></td></tr></table></figure><p>注意：这些方法都不会改变原始字符串，而是返回一个新的字符串。因为Python中的字符串是不可变的。</p><h3 id="浮点数精度控制"><a href="#浮点数精度控制" class="headerlink" title="浮点数精度控制"></a>浮点数精度控制</h3><h4 id="使用-格式化浮点数"><a href="#使用-格式化浮点数" class="headerlink" title="使用%格式化浮点数"></a>使用%格式化浮点数</h4><p>下面是一些使用<code>%</code>运算符和<code>.yf</code>格式来格式化浮点数的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个浮点数  </span></span><br><span class="line">number = <span class="number">3.141592653589793</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 使用%格式化方法，保留两位小数  </span></span><br><span class="line">formatted_number = <span class="string">&quot;%.2f&quot;</span> % number  </span><br><span class="line"><span class="built_in">print</span>(formatted_number)  <span class="comment"># 输出: 3.14  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 如果需要指定总宽度（包括小数点和小数），则使用x.yf格式  </span></span><br><span class="line"><span class="comment"># 但这里的总宽度仅包括小数点前的数字、小数点和小数点后的数字，不包括可能的负号或指数部分  </span></span><br><span class="line">formatted_number_with_width = <span class="string">&quot;%8.2f&quot;</span> % number  </span><br><span class="line"><span class="built_in">print</span>(formatted_number_with_width)  <span class="comment"># 输出: &quot;    3.14&quot;（前面有空格填充以达到总宽度8）  </span></span><br></pre></td></tr></table></figure><h1 id="条件与循环"><a href="#条件与循环" class="headerlink" title="条件与循环"></a>条件与循环</h1><h2 id="1-条件语句"><a href="#1-条件语句" class="headerlink" title="1. 条件语句"></a>1. 条件语句</h2><h3 id="1-1-布尔类型"><a href="#1-1-布尔类型" class="headerlink" title="1.1 布尔类型"></a>1.1 布尔类型</h3><p>布尔类型（bool）用于表示逻辑值，其中 <code>True</code> 表示真（逻辑上的1），<code>False</code> 表示假（逻辑上的0）。</p><h3 id="1-2-条件表达式"><a href="#1-2-条件表达式" class="headerlink" title="1.2 条件表达式"></a>1.2 条件表达式</h3><p>条件表达式的结果是布尔类型。例如，比较运算符（如 <code>&gt;</code>、<code>&lt;</code>、<code>==</code> 等）的结果就是布尔类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num1 = <span class="number">11</span></span><br><span class="line">num2 = <span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;11 &gt; 20 的结果是 <span class="subst">&#123;<span class="number">11</span> &gt; <span class="number">20</span>&#125;</span>, 类型为 <span class="subst">&#123;<span class="built_in">type</span>(<span class="number">11</span> &gt; <span class="number">20</span>)&#125;</span>&quot;</span>)  <span class="comment"># 输出 False 和 &lt;class &#x27;bool&#x27;&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-3-if-elif-else-语句"><a href="#1-3-if-elif-else-语句" class="headerlink" title="1.3 if-elif-else 语句"></a>1.3 if-elif-else 语句</h3><p><code>if-elif-else</code> 语句用于根据条件执行不同的代码块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入一个数字：&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> num &lt; <span class="number">10</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;num&#125;</span> &lt; 10&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> num &lt;= <span class="number">100</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;num&#125;</span> &lt;= 100&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure><p>在这个例子中，根据输入的数字大小，程序会输出不同的结果。<strong>注意要写$:$</strong></p><h3 id="1-4-pass-语句"><a href="#1-4-pass-语句" class="headerlink" title="1.4 pass 语句"></a>1.4 pass 语句</h3><p><code>pass</code> 是一个空语句，它不做任何事情。它通常用作占位符，以保持程序结构的完整性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入一个数字：&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> num &lt;= <span class="number">100</span>:</span><br><span class="line">    <span class="keyword">pass</span>  <span class="comment"># 这里什么也不做</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(num)  <span class="comment"># 只有当 num &gt; 100 时才会执行这条语句</span></span><br></pre></td></tr></table></figure><h2 id="2-循环语句"><a href="#2-循环语句" class="headerlink" title="2. 循环语句"></a>2. 循环语句</h2><h3 id="2-1-while-循环"><a href="#2-1-while-循环" class="headerlink" title="2.1 while 循环"></a>2.1 while 循环</h3><p><code>while</code> 循环会重复执行一段代码，直到条件不再满足为止。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span></span><br><span class="line">add = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> x &lt;= <span class="number">100</span>:</span><br><span class="line">    add += x  <span class="comment"># 累加 x 的值到 add 变量中</span></span><br><span class="line">    x += <span class="number">1</span>    <span class="comment"># x 自增 1</span></span><br><span class="line"><span class="built_in">print</span>(add)  <span class="comment"># 输出累加结果，从 1 加到 100 的和为 5050</span></span><br></pre></td></tr></table></figure><h3 id="2-2-for-循环"><a href="#2-2-for-循环" class="headerlink" title="2.2 for 循环"></a>2.2 for 循环</h3><p><code>for</code> 循环用于遍历序列类型（如字符串、列表、元组等）中的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;abcdef&quot;</span></span><br><span class="line"><span class="keyword">for</span> ch <span class="keyword">in</span> s:  <span class="comment"># 遍历字符串 s 中的每个字符</span></span><br><span class="line">    <span class="keyword">if</span> ch == <span class="string">&quot;a&quot;</span>:</span><br><span class="line">        <span class="keyword">continue</span>  <span class="comment"># 跳过当前循环的剩余部分，进入下一次循环</span></span><br><span class="line">    <span class="keyword">if</span> ch == <span class="string">&quot;e&quot;</span>:</span><br><span class="line">        <span class="keyword">break</span>  <span class="comment"># 跳出整个循环</span></span><br><span class="line">    <span class="built_in">print</span>(ch)  <span class="comment"># 输出字符，但不会输出 &quot;a&quot; 和 &quot;e&quot; 之后的字符</span></span><br></pre></td></tr></table></figure><h3 id="2-3-range-函数"><a href="#2-3-range-函数" class="headerlink" title="2.3 range() 函数"></a>2.3 range() 函数</h3><p><code>range()</code> 函数用于生成一个数字序列。它有三种用法：</p><ul><li><code>range(num)</code>：生成从 0 开始到 num-1 的数字序列。</li><li><code>range(num1, num2)</code>：生成从 num1 开始到 num2-1 的数字序列。</li><li><code>range(num1, num2, step)</code>：生成从 num1 开始到 num2-1 的数字序列，步长为 step。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 range() 函数的例子</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>, <span class="number">11</span>, <span class="number">2</span>):  <span class="comment"># 生成 [5, 7, 9] 这样的序列并遍历它</span></span><br><span class="line">    <span class="built_in">print</span>(x, end=<span class="string">&#x27; &#x27;</span>)  <span class="comment"># 输出每个数字并用空格分隔它们，结果是 5 7 9</span></span><br><span class="line"><span class="built_in">print</span>()  <span class="comment"># 输出一个换行符以美观结束输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 另一个例子：倒序输出 10 到 1 的数字序列</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>, <span class="number">0</span>, -<span class="number">1</span>):  <span class="comment"># 生成 [10, 9, 8, ..., 1] 这样的序列并遍历它（注意不包含0）</span></span><br><span class="line">    <span class="built_in">print</span>(i, end=<span class="string">&#x27; &#x27;</span>)  <span class="comment"># 输出每个数字并用空格分隔它们，结果是 10 9 8 7 6 5 4 3 2 1</span></span><br><span class="line"><span class="built_in">print</span>()  <span class="comment"># 同样输出一个换行符以结束输出</span></span><br></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数定义与调用"><a href="#函数定义与调用" class="headerlink" title="函数定义与调用"></a>函数定义与调用</h2><p>在Python中，函数是通过<code>def</code>关键字定义的，后面跟函数名和括号内的参数列表。函数体由一系列语句组成，并且使用缩进来表示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">function_name</span>(<span class="params">parameters</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Docstring: 函数说明文档&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 函数体：由语句组成，执行特定的任务</span></span><br><span class="line">    <span class="keyword">return</span> result  <span class="comment"># 可选：返回函数执行的结果</span></span><br></pre></td></tr></table></figure><p>调用函数时，需要在函数名后加上括号和必要的参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = function_name(arguments)  <span class="comment"># 调用函数，并将返回值存储在变量中（如果有返回值的话）</span></span><br></pre></td></tr></table></figure><blockquote><p> 注：Python不支持函数重载</p></blockquote><h2 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h2><p>如果函数中有<code>return</code>语句，那么函数会返回<code>return</code>后面的值。如果函数中没有<code>return</code>语句或者<code>return</code>语句后面没有跟任何值，那么函数会默认返回<code>None</code>。</p><h3 id="多返回值"><a href="#多返回值" class="headerlink" title="多返回值"></a>多返回值</h3><p>在Python中，函数不仅可以返回单个值，还可以返回多个值。</p><h4 id="函数多返回值"><a href="#函数多返回值" class="headerlink" title="函数多返回值"></a>函数多返回值</h4><p>当函数需要返回多个值时，可以将这些值<strong>以逗号分隔</strong>放在<code>return</code>语句后。这些值会被打包成一个元组返回。调用函数时，可以使用多个变量来接收这些返回值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test01</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">11</span>, <span class="number">22</span></span><br><span class="line"></span><br><span class="line">x, y = test01()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;x=<span class="subst">&#123;x&#125;</span>, y=<span class="subst">&#123;y&#125;</span>&quot;</span>)  <span class="comment"># 输出：x=11, y=22</span></span><br></pre></td></tr></table></figure><p>函数也可以返回不同类型的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test02</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">11</span>, <span class="number">4.5</span>, <span class="string">&quot;14&quot;</span></span><br><span class="line"></span><br><span class="line">x, y, z = test02()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;x=<span class="subst">&#123;x&#125;</span>, y=<span class="subst">&#123;y&#125;</span>, z=<span class="subst">&#123;z&#125;</span>&quot;</span>)  <span class="comment"># 输出：x=11, y=4.5, z=14</span></span><br></pre></td></tr></table></figure><h2 id="函数的参数传递"><a href="#函数的参数传递" class="headerlink" title="函数的参数传递"></a>函数的参数传递</h2><h3 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h3><p>位置参数是按照函数声明中参数的顺序来传递的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test03</span>(<span class="params">name, age, gender</span>):</span><br><span class="line">    <span class="built_in">print</span>(name, age, gender)</span><br><span class="line"></span><br><span class="line">test03(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">10</span>, <span class="string">&#x27;Male&#x27;</span>)  <span class="comment"># 输出：Tom 10 Male</span></span><br></pre></td></tr></table></figure><h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>关键字参数是通过参数名来指定要传递的参数值。关键字参数可以不按照函数声明中的顺序来传递，但是要注意在函数调用时关键字参数的名称必须与函数声明中的参数名一致。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test04</span>(<span class="params">name, age, gender</span>):</span><br><span class="line">    <span class="built_in">print</span>(name, age, gender)</span><br><span class="line"></span><br><span class="line">test04(name=<span class="string">&#x27;Tom&#x27;</span>, age=<span class="number">10</span>, gender=<span class="string">&#x27;Male&#x27;</span>)  <span class="comment"># 输出：Tom 10 Male</span></span><br></pre></td></tr></table></figure><p>关键字参数和位置参数可以混用，但位置参数必须放在关键字参数前面。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test05</span>(<span class="params">name, age, gender</span>):</span><br><span class="line">    <span class="built_in">print</span>(name, age, gender)</span><br><span class="line"></span><br><span class="line">test05(<span class="string">&#x27;Tom&#x27;</span>, age=<span class="number">10</span>, gender=<span class="string">&#x27;Male&#x27;</span>)  <span class="comment"># 输出：Tom 10 Male</span></span><br></pre></td></tr></table></figure><h3 id="缺省参数"><a href="#缺省参数" class="headerlink" title="缺省参数"></a>缺省参数</h3><p>缺省参数是指在函数声明时为参数指定一个默认值。如果在函数调用时没有为该参数传递值，则使用默认值。<strong>缺省参数必须放在函数声明的最后</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test06</span>(<span class="params">name, age, gender=<span class="string">&quot;Male&quot;</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(name, age, gender)</span><br><span class="line"></span><br><span class="line">test06(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">10</span>)  <span class="comment"># 输出：Tom 10 Male</span></span><br></pre></td></tr></table></figure><h3 id="不定长参数"><a href="#不定长参数" class="headerlink" title="不定长参数"></a>不定长参数</h3><p>不定长参数是指函数可以接受任意数量的参数。在函数声明中，使用<code>*args</code>来表示接受任意数量的位置参数，使用<code>**kwargs</code>来表示接受任意数量的关键字参数。这些参数在函数内部被收集为一个元组或一个字典。</p><h4 id="位置传递（-args）"><a href="#位置传递（-args）" class="headerlink" title="位置传递（*args）"></a>位置传递（*args）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test07</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line"></span><br><span class="line">test07(<span class="string">&#x27;Jerry&#x27;</span>)  <span class="comment"># 输出：(&#x27;Jerry&#x27;,)</span></span><br><span class="line">test07(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">10</span>)  <span class="comment"># 输出：(&#x27;Tom&#x27;, 10)</span></span><br><span class="line">test07(<span class="string">&#x27;Trump&#x27;</span>, <span class="number">77</span>, <span class="string">&#x27;Male&#x27;</span>)  <span class="comment"># 输出：(&#x27;Trump&#x27;, 77, &#x27;Male&#x27;)</span></span><br></pre></td></tr></table></figure><h4 id="关键字传递（-kwargs）"><a href="#关键字传递（-kwargs）" class="headerlink" title="关键字传递（**kwargs）"></a>关键字传递（**kwargs）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test08</span>(<span class="params">**kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(kwargs)</span><br><span class="line"></span><br><span class="line">test08(name=<span class="string">&#x27;TOM&#x27;</span>, age=<span class="number">18</span>, <span class="built_in">id</span>=<span class="number">110</span>)  <span class="comment"># 输出：&#123;&#x27;name&#x27;: &#x27;TOM&#x27;, &#x27;age&#x27;: 18, &#x27;id&#x27;: 110&#125;</span></span><br></pre></td></tr></table></figure><h2 id="局部变量与全局变量"><a href="#局部变量与全局变量" class="headerlink" title="局部变量与全局变量"></a>局部变量与全局变量</h2><p>在函数内部定义的变量是局部变量，只能在该函数内部访问。在函数外部定义的变量是全局变量，可以在任何地方访问，包括函数内部（除非被局部变量覆盖）。</p><p>如果需要在函数内部修改全局变量，需要使用<code>global</code>关键字声明。</p><h2 id="函数说明文档（Docstring）"><a href="#函数说明文档（Docstring）" class="headerlink" title="函数说明文档（Docstring）"></a>函数说明文档（Docstring）</h2><p>函数说明文档是一种特殊的注释，用于解释函数的作用、参数和返回值。它位于函数定义的开始，由三个双引号（可以是三个单引号）包围。</p><p>Docstring可以通过<code>help()</code>函数或者函数的<code>__doc__</code>属性查看。</p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>下面是一个包含函数定义、调用、局部变量、全局变量和Docstring的示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局变量</span></span><br><span class="line">num = <span class="number">200</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">strlen</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计算字符串的长度</span></span><br><span class="line"><span class="string">    :param s: 输入的字符串</span></span><br><span class="line"><span class="string">    :return: 字符串的长度</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    length = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">        length += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> length</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_global</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    演示全局变量的访问和修改</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">global</span> num  <span class="comment"># 声明是全局变量</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Global num before modification: <span class="subst">&#123;num&#125;</span>&quot;</span>)</span><br><span class="line">    num = <span class="number">500</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Global num after modification: <span class="subst">&#123;num&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_local</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    演示局部变量的作用范围</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    local_num = <span class="number">100</span>  <span class="comment"># 局部变量</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Local num: <span class="subst">&#123;local_num&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数并打印结果</span></span><br><span class="line">s1 = <span class="string">&quot;Hello, world!&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Length of &#x27;<span class="subst">&#123;s1&#125;</span>&#x27;: <span class="subst">&#123;strlen(s1)&#125;</span>&quot;</span>)  <span class="comment"># 调用strlen函数计算字符串长度并打印结果</span></span><br><span class="line">test_global()  <span class="comment"># 调用test_global函数修改全局变量并打印结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Global num after test_global function: <span class="subst">&#123;num&#125;</span>&quot;</span>)  <span class="comment"># 打印修改后的全局变量值以确认修改生效</span></span><br><span class="line">test_local()  <span class="comment"># 调用test_local函数演示局部变量的作用范围（不会修改全局变量）</span></span><br></pre></td></tr></table></figure><h1 id="Python中的数据结构"><a href="#Python中的数据结构" class="headerlink" title="Python中的数据结构"></a>Python中的数据结构</h1><h2 id="List——列表"><a href="#List——列表" class="headerlink" title="List——列表"></a>List——列表</h2><h3 id="定义列表"><a href="#定义列表" class="headerlink" title="定义列表"></a>定义列表</h3><p>在Python中，列表（List）是一种可变的数据容器，可以包含任意类型的对象：数字、字符串、其他列表等。列表中的元素通过逗号分隔，并包含在方括号 <code>[]</code> 中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个字符串列表</span></span><br><span class="line">name_list = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(name_list)  <span class="comment"># 输出: [&#x27;abc&#x27;, &#x27;def&#x27;, &#x27;ghi&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(name_list))  <span class="comment"># 输出: &lt;class &#x27;list&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表可以存储多种不同类型的元素</span></span><br><span class="line">my_list = [<span class="string">&quot;abc&quot;</span>, <span class="number">666</span>, <span class="literal">True</span>]</span><br><span class="line"><span class="built_in">print</span>(my_list)  <span class="comment"># 输出: [&#x27;abc&#x27;, 666, True]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(my_list))  <span class="comment"># 输出: &lt;class &#x27;list&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表支持嵌套</span></span><br><span class="line">two_dimension = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]]</span><br><span class="line"><span class="built_in">print</span>(two_dimension)  <span class="comment"># 输出: [[1, 2, 3], [4, 5, 6]]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(two_dimension))  <span class="comment"># 输出: &lt;class &#x27;list&#x27;&gt;</span></span><br></pre></td></tr></table></figure><h3 id="下标索引"><a href="#下标索引" class="headerlink" title="下标索引"></a>下标索引</h3><p>列表中的元素可以通过下标索引来访问。在Python中，下标从0开始。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(my_list[<span class="number">0</span>])  <span class="comment"># 输出: abc</span></span><br><span class="line"><span class="built_in">print</span>(my_list[<span class="number">1</span>])  <span class="comment"># 输出: def</span></span><br><span class="line"><span class="built_in">print</span>(my_list[<span class="number">2</span>])  <span class="comment"># 输出: ghi</span></span><br></pre></td></tr></table></figure><p>尝试访问超出范围的索引会导致<code>IndexError</code>。</p><h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><p>在Python中，你可以使用<code>list.index()</code>函数来查找列表中某个元素的索引。这个函数会返回元素在列表中首次出现的索引，如果元素不在列表中，则会抛出一个<code>ValueError</code>异常。</p><p>下面是一个基本的使用示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个列表  </span></span><br><span class="line">my_list = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;cherry&#x27;</span>, <span class="string">&#x27;date&#x27;</span>]  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 查找&#x27;banana&#x27;的索引  </span></span><br><span class="line">index = my_list.index(<span class="string">&#x27;banana&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 输出索引  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;The index of &#x27;banana&#x27; is <span class="subst">&#123;index&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>这段代码会输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash复制代码</span><br><span class="line">The index of <span class="string">&#x27;banana&#x27;</span> is 1</span><br></pre></td></tr></table></figure><p>因为在这个列表中，’banana’的索引是1（索引是从0开始的）。</p><h3 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h3><p>列表中的元素可以通过下标索引来修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>]</span><br><span class="line">my_list[<span class="number">1</span>] = <span class="string">&quot;bcd&quot;</span></span><br><span class="line"><span class="built_in">print</span>(my_list)  <span class="comment"># 输出: [&#x27;abc&#x27;, &#x27;bcd&#x27;, &#x27;ghi&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><h4 id="insert-方法"><a href="#insert-方法" class="headerlink" title=".insert()方法"></a>.insert()方法</h4><p>使用<code>.insert()</code>方法可以在列表的指定位置插入一个元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>]</span><br><span class="line">my_list.insert(<span class="number">1</span>, <span class="string">&quot;666&quot;</span>)  <span class="comment"># 在下标1处插入&quot;666&quot;</span></span><br><span class="line"><span class="built_in">print</span>(my_list)  <span class="comment"># 输出: [&#x27;abc&#x27;, &#x27;666&#x27;, &#x27;def&#x27;, &#x27;ghi&#x27;]</span></span><br></pre></td></tr></table></figure><h4 id="append-方法"><a href="#append-方法" class="headerlink" title=".append()方法"></a>.append()方法</h4><p>使用<code>.append()</code>方法可以在列表的末尾追加一个元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>]</span><br><span class="line">my_list.append(<span class="string">&quot;jkl&quot;</span>)  <span class="comment"># 在末尾追加&quot;jkl&quot;</span></span><br><span class="line"><span class="built_in">print</span>(my_list)  <span class="comment"># 输出: [&#x27;abc&#x27;, &#x27;def&#x27;, &#x27;ghi&#x27;, &#x27;jkl&#x27;]</span></span><br></pre></td></tr></table></figure><h4 id="extend-方法"><a href="#extend-方法" class="headerlink" title=".extend()方法"></a>.extend()方法</h4><p>使用<code>.extend()</code>方法可以在列表的末尾追加另一个容器（例如列表）的所有元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>]</span><br><span class="line">my_list.extend([<span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqr&quot;</span>])  <span class="comment"># 追加另一个列表的所有元素</span></span><br><span class="line"><span class="built_in">print</span>(my_list)  <span class="comment"># 输出: [&#x27;abc&#x27;, &#x27;def&#x27;, &#x27;ghi&#x27;, &#x27;jkl&#x27;, &#x27;mno&#x27;, &#x27;pqr&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><h4 id="del语句"><a href="#del语句" class="headerlink" title="del语句"></a>del语句</h4><p>使用<code>del</code>语句可以删除列表中指定位置的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>]</span><br><span class="line"><span class="keyword">del</span> my_list[<span class="number">1</span>]  <span class="comment"># 删除下标为1的元素</span></span><br><span class="line"><span class="built_in">print</span>(my_list)  <span class="comment"># 输出: [&#x27;abc&#x27;, &#x27;ghi&#x27;, &#x27;jkl&#x27;]</span></span><br></pre></td></tr></table></figure><h4 id="pop-方法"><a href="#pop-方法" class="headerlink" title=".pop()方法"></a>.pop()方法</h4><p>使用<code>.pop()</code>方法可以删除并返回列表中指定位置的元素。如果不提供索引，则默认删除并返回最后一个元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>]</span><br><span class="line">element = my_list.pop(<span class="number">1</span>)  <span class="comment"># 删除下标为1的元素，并将其值赋给element</span></span><br><span class="line"><span class="built_in">print</span>(element)  <span class="comment"># 输出: def</span></span><br><span class="line"><span class="built_in">print</span>(my_list)  <span class="comment"># 输出: [&#x27;abc&#x27;, &#x27;ghi&#x27;, &#x27;jkl&#x27;]</span></span><br></pre></td></tr></table></figure><h4 id="remove-方法"><a href="#remove-方法" class="headerlink" title=".remove()方法"></a>.remove()方法</h4><p>使用<code>.remove()</code>方法可以删除列表中第一个出现的指定元素。如果元素不存在于列表中，则会导致<code>ValueError</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>]</span><br><span class="line">my_list.remove(<span class="string">&quot;def&quot;</span>)  <span class="comment"># 删除第一个出现的&quot;def&quot;</span></span><br><span class="line"><span class="built_in">print</span>(my_list)  <span class="comment"># 输出: [&#x27;abc&#x27;, &#x27;ghi&#x27;, &#x27;jkl&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="清空列表"><a href="#清空列表" class="headerlink" title="清空列表"></a>清空列表</h3><p>使用<code>.clear()</code>方法可以清空列表中的所有元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>]</span><br><span class="line">my_list.clear()  <span class="comment"># 清空列表</span></span><br><span class="line"><span class="built_in">print</span>(my_list)  <span class="comment"># 输出: []</span></span><br></pre></td></tr></table></figure><h3 id="统计元素数量"><a href="#统计元素数量" class="headerlink" title="统计元素数量"></a>统计元素数量</h3><p>使用<code>.count()</code>方法可以统计列表中某个元素出现的次数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(my_list.count(<span class="number">1</span>))  <span class="comment"># 输出: 2，因为1在列表中出现了2次</span></span><br></pre></td></tr></table></figure><h3 id="列表长度"><a href="#列表长度" class="headerlink" title="列表长度"></a>列表长度</h3><p>使用内置函数<code>len()</code>可以获取列表的长度（即元素的数量）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(my_list))  <span class="comment"># 输出: 5，因为列表中有5个元素</span></span><br></pre></td></tr></table></figure><h3 id="遍历容器"><a href="#遍历容器" class="headerlink" title="遍历容器"></a>遍历容器</h3><p>可以使用<code>for</code>循环来遍历列表中的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> ele <span class="keyword">in</span> my_list:</span><br><span class="line">    <span class="built_in">print</span>(ele, end=<span class="string">&quot; &quot;</span>)  <span class="comment"># 输出: 1 2 3 4 5 </span></span><br></pre></td></tr></table></figure><p>如果需要在遍历过程中同时获取元素的下标和值，可以使用<code>enumerate()</code>函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> index, item <span class="keyword">in</span> <span class="built_in">enumerate</span>(my_list, start=<span class="number">1</span>):  <span class="comment"># 设置下标从1开始</span></span><br><span class="line">    <span class="built_in">print</span>(index, item)  <span class="comment"># 输出元素的下标和值</span></span><br></pre></td></tr></table></figure><p>这将输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 apple</span><br><span class="line">2 banana</span><br><span class="line">3 cherry</span><br></pre></td></tr></table></figure><blockquote><p>如果start=0，将输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;0 apple</span><br><span class="line">1 banana</span><br><span class="line">2 cherry</span><br></pre></td></tr></table></figure></blockquote><h3 id="Python中列表的拷贝方法"><a href="#Python中列表的拷贝方法" class="headerlink" title="Python中列表的拷贝方法"></a>Python中列表的拷贝方法</h3><p>在Python中，拷贝一个列表可以有多种方法，但每种方法都有其特定的用途和后果。本笔记将详细介绍使用赋值运算符（<code>=</code>）、<code>.copy()</code>方法，以及<code>copy</code>模块中的<code>deepcopy()</code>函数进行列表拷贝的区别。</p><h4 id="1-赋值运算符（-）"><a href="#1-赋值运算符（-）" class="headerlink" title="1. 赋值运算符（=）"></a>1. 赋值运算符（<code>=</code>）</h4><p>使用赋值运算符并不是真正的拷贝，而是创建了一个新的引用指向同一个列表对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]</span><br><span class="line">list2 = list1  <span class="comment"># 这不是拷贝，list2只是指向list1的引用</span></span><br></pre></td></tr></table></figure><p>在这种情况下，<code>list1</code>和<code>list2</code>实际上是指向内存中同一个对象的两个不同名字。任何对<code>list2</code>的修改都会反映到<code>list1</code>上，反之亦然。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list2.append(<span class="number">6</span>)  <span class="comment"># 修改list2</span></span><br><span class="line"><span class="built_in">print</span>(list1)  <span class="comment"># 输出: [1, 2, 3, [4, 5], 6] —— list1也被修改了</span></span><br></pre></td></tr></table></figure><h4 id="2-copy-方法（浅拷贝）"><a href="#2-copy-方法（浅拷贝）" class="headerlink" title="2. .copy()方法（浅拷贝）"></a>2. <code>.copy()</code>方法（浅拷贝）</h4><p>Python的列表对象有一个<code>.copy()</code>方法，用于创建列表的浅拷贝。这意味着它创建了列表的一个新副本，但副本中的元素仍然是原始列表中元素的引用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]</span><br><span class="line">list2 = list1.copy()  <span class="comment"># 执行浅拷贝</span></span><br></pre></td></tr></table></figure><p>现在，<code>list1</code>和<code>list2</code>是两个不同的列表对象，<strong>但它们的元素（特别是可变对象，如内部列表）仍然是共享的。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list2[<span class="number">3</span>][<span class="number">0</span>] = <span class="string">&#x27;four&#x27;</span>  <span class="comment"># 修改list2中的内部列表</span></span><br><span class="line"><span class="built_in">print</span>(list1)  <span class="comment"># 输出: [1, 2, 3, [&#x27;four&#x27;, 5]] —— list1也被影响了</span></span><br></pre></td></tr></table></figure><p>尽管<code>list1</code>和<code>list2</code>是不同的列表对象，但由于浅拷贝的性质，它们共享对内部列表的引用。</p><h4 id="3-deepcopy-函数（深拷贝）"><a href="#3-deepcopy-函数（深拷贝）" class="headerlink" title="3. deepcopy()函数（深拷贝）"></a>3. <code>deepcopy()</code>函数（深拷贝）</h4><p><strong>要创建一个完全独立的列表拷贝，包括其所有嵌套对象，应使用<code>copy</code>模块中的<code>deepcopy()</code>函数</strong>。深拷贝会递归地复制对象及其所有子对象，生成一个全新的对象树。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]</span><br><span class="line">list2 = copy.deepcopy(list1)  <span class="comment"># 执行深拷贝</span></span><br></pre></td></tr></table></figure><p>现在，<code>list2</code>是<code>list1</code>的一个完全独立的拷贝，包括所有嵌套对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list2[<span class="number">3</span>][<span class="number">0</span>] = <span class="string">&#x27;four&#x27;</span>  <span class="comment"># 修改list2中的内部列表</span></span><br><span class="line"><span class="built_in">print</span>(list1)  <span class="comment"># 输出: [1, 2, 3, [4, 5]] —— list1未受影响</span></span><br></pre></td></tr></table></figure><p>修改<code>list2</code>不会影响<code>list1</code>，因为<code>deepcopy()</code>创建了所有对象的独立拷贝。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>赋值运算符（<code>=</code>）不创建拷贝，只创建引用。</li><li><code>.copy()</code>方法执行浅拷贝，创建新列表但<strong>共享嵌套对象</strong>。</li><li><code>deepcopy()</code>函数执行深拷贝，递归地复制所有对象，生成完全独立的对象树。</li></ul><h2 id="tuple——元组"><a href="#tuple——元组" class="headerlink" title="tuple——元组"></a>tuple——元组</h2><p><strong>和list的区别是不可修改</strong></p><p>元组（Tuple）是Python中的一种不可变序列类型，用于存储一系列有序的元素。与列表（List）不同，元组一旦定义，就不能再修改其内容。元组通常用于存储不应该被改变的数据集合。</p><h3 id="定义元组"><a href="#定义元组" class="headerlink" title="定义元组"></a>定义元组</h3><p>元组使用圆括号<code>()</code>来定义，元素之间使用逗号<code>,</code>分隔。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个包含多个元素的元组</span></span><br><span class="line">my_tuple = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;hello&#x27;</span>, <span class="number">5.5</span>)</span><br><span class="line"><span class="built_in">print</span>(my_tuple)  <span class="comment"># 输出：(1, 2, 3, &#x27;hello&#x27;, 5.5)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个空元组</span></span><br><span class="line">empty_tuple = ()</span><br><span class="line"><span class="built_in">print</span>(empty_tuple)  <span class="comment"># 输出：()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以使用tuple()函数来创建一个空元组</span></span><br><span class="line">another_empty_tuple = <span class="built_in">tuple</span>()</span><br><span class="line"><span class="built_in">print</span>(another_empty_tuple)  <span class="comment"># 输出：()</span></span><br></pre></td></tr></table></figure><p>注意，如果元组只包含一个元素，那么该元素后面必须跟一个逗号，否则它不会被识别为元组。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个包含单个元素的元组（注意逗号）</span></span><br><span class="line">single_element_tuple = (<span class="number">42</span>,)</span><br><span class="line"><span class="built_in">print</span>(single_element_tuple)  <span class="comment"># 输出：(42,)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(single_element_tuple))  <span class="comment"># 输出：&lt;class &#x27;tuple&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果没有逗号，它会被当作一个普通的表达式，而不是元组</span></span><br><span class="line">not_a_tuple = (<span class="number">42</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(not_a_tuple))  <span class="comment"># 输出：&lt;class &#x27;int&#x27;&gt;，因为它被当作了一个整数</span></span><br></pre></td></tr></table></figure><h3 id="元组的不可变性"><a href="#元组的不可变性" class="headerlink" title="元组的不可变性"></a>元组的不可变性</h3><p>元组是不可变的，这意味着一旦创建了一个元组，你就不能添加、删除或更改其元素。尝试这样做会导致TypeError。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_tuple = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># 尝试修改元组（会导致错误）</span></span><br><span class="line"><span class="comment"># my_tuple[0] = 0  # TypeError: &#x27;tuple&#x27; object does not support item assignment</span></span><br></pre></td></tr></table></figure><p>然而，如果元组中包含可变对象（如列表），那么这些对象的内容是可以被修改的。但请注意，你不能更改这些可变对象在元组中的身份（即不能用一个新的列表替换原有的列表）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 元组中包含一个列表</span></span><br><span class="line">my_tuple_with_list = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="comment"># 修改列表的内容是可以的</span></span><br><span class="line">my_tuple_with_list[<span class="number">2</span>][<span class="number">0</span>] = -<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(my_tuple_with_list)  <span class="comment"># 输出：(1, 2, [-1, 4, 5])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 尝试用一个新的列表替换原有的列表（会导致错误）</span></span><br><span class="line"><span class="comment"># my_tuple_with_list[2] = [6, 7, 8]  # TypeError: &#x27;tuple&#x27; object does not support item assignment</span></span><br></pre></td></tr></table></figure><p>在实际应用中，如果你需要一个不可变的序列来存储数据，并且这些数据在程序的整个生命周期中都不会改变，那么使用元组是一个很好的选择。元组的不可变性也使其在某些情况下比列表更加高效，因为Python可以在内部对其进行优化。</p><h2 id="string——字符串"><a href="#string——字符串" class="headerlink" title="string——字符串"></a>string——字符串</h2><p>字符串（String）是 Python 中常见的数据容器之一，用于存储字符序列。字符串具有一些独特的特点和操作方法。</p><h3 id="字符串的访问"><a href="#字符串的访问" class="headerlink" title="字符串的访问"></a>字符串的访问</h3><p>字符串中的字符可以通过下标进行访问。下标从0开始递增，表示从前往后访问字符；而从-1开始递减，则表示从后往前访问字符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">0</span>])  <span class="comment"># 输出: H</span></span><br><span class="line"><span class="built_in">print</span>(s[-<span class="number">1</span>]) <span class="comment"># 输出: !</span></span><br></pre></td></tr></table></figure><h3 id="字符串的不可变性"><a href="#字符串的不可变性" class="headerlink" title="字符串的不可变性"></a>字符串的不可变性</h3><p>同元组（Tuple）一样，字符串是一个无法修改的数据容器。一旦一个字符串被创建，就不能修改它的内容。任何对字符串的修改操作都会生成一个新的字符串对象。</p><h3 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h3><h4 id="index-方法"><a href="#index-方法" class="headerlink" title="index 方法"></a>index 方法</h4><p><code>index</code> 方法用于查找子字符串在字符串中首次出现的位置，并返回该位置的索引。如果子字符串不存在，<strong>则会抛出异常</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;you are a handsome boy&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.index(<span class="string">&quot;hand&quot;</span>))  <span class="comment"># 输出: 10</span></span><br></pre></td></tr></table></figure><h4 id="replace-方法"><a href="#replace-方法" class="headerlink" title="replace 方法"></a>replace 方法</h4><p><code>replace</code> 方法用于将字符串中的某个子字符串替换为另一个字符串，并返回替换后的新字符串。原始字符串本身不会被修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;cats and dogs are good cats and dogs and cats and dogs do things cats and dogs like do&quot;</span></span><br><span class="line">s1 = s.replace(<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;tiger&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># 输出原始字符串</span></span><br><span class="line"><span class="built_in">print</span>(s1) <span class="comment"># 输出替换后的新字符串</span></span><br></pre></td></tr></table></figure><h4 id="split-方法"><a href="#split-方法" class="headerlink" title="split 方法"></a>split 方法</h4><p><code>split</code> 方法用于根据指定的分隔符将字符串分割成多个子字符串，并将这些子字符串存储在列表中返回。原始字符串本身不会被修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;cats and dogs are good cats and dogs and cats and dogs do things cats and dogs like do&quot;</span></span><br><span class="line">l = s.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># 输出原始字符串</span></span><br><span class="line"><span class="built_in">print</span>(l)  <span class="comment"># 输出分割后的列表</span></span><br></pre></td></tr></table></figure><h4 id="strip-方法"><a href="#strip-方法" class="headerlink" title="strip 方法"></a>strip 方法</h4><p><code>strip</code> 方法用于去除字符串开头和结尾的空白字符（包括空格、制表符、换行符等），并返回处理后的新字符串。原始字符串本身不会被修改。如果指定了参数，则会去除前后指定的字符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;  12abcde1  &quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.strip())      <span class="comment"># 输出: &quot;12abcde1&quot;</span></span><br><span class="line">s = <span class="string">&quot;12abcde1&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.strip(<span class="string">&quot;12&quot;</span>))  <span class="comment">#输出:&quot;abcde&quot;</span></span><br></pre></td></tr></table></figure><h4 id="count-方法"><a href="#count-方法" class="headerlink" title="count 方法"></a>count 方法</h4><p><code>count</code> 方法用于统计某个子字符串在字符串中出现的次数，并返回该次数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;114514514114514514114114&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.count(<span class="string">&quot;114&quot;</span>))  <span class="comment"># 输出: 4</span></span><br></pre></td></tr></table></figure><h4 id="len-函数"><a href="#len-函数" class="headerlink" title="len 函数"></a>len 函数</h4><p><code>len</code> 函数用于获取字符串的长度，即字符的个数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;114514514114514514114114&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(s))  <span class="comment"># 输出: 24</span></span><br></pre></td></tr></table></figure><p>请注意，虽然 <code>len</code> 是一个内置函数而不是字符串的方法，但它经常用于获取字符串的长度，因此在这里也一并提及。</p><h3 id="Python-中常用处理字符串的相关函数"><a href="#Python-中常用处理字符串的相关函数" class="headerlink" title="Python 中常用处理字符串的相关函数"></a>Python 中常用处理字符串的相关函数</h3><p>在Python中，字符串是不可变的，但Python提供了很多方法来操作字符串。这些方法可以帮助我们完成各种任务，如查找子字符串，替换子字符串，分割字符串等。下面列出了一些Python中常用的字符串方法：</p><h4 id="字符串首字母大写"><a href="#字符串首字母大写" class="headerlink" title="字符串首字母大写"></a>字符串首字母大写</h4><p><code>string.capitalize()</code></p><p>该方法返回字符串的一个副本，其中第一个字符为大写，其余为小写。</p><h4 id="计数子字符串"><a href="#计数子字符串" class="headerlink" title="计数子字符串"></a>计数子字符串</h4><p><code>string.count(str, beg=0, end=len(string))</code></p><p>该方法返回子字符串在字符串中出现的次数。可选参数<code>beg</code>和<code>end</code>是字符串中要开始和结束搜索的索引范围。</p><h4 id="检查字符串结束"><a href="#检查字符串结束" class="headerlink" title="检查字符串结束"></a>检查字符串结束</h4><p><code>string.endswith(obj, beg=0, end=len(string))</code></p><p>该方法检查字符串是否以指定的后缀结束，如果是则返回<code>True</code>，否则返回<code>False</code>。可选参数<code>beg</code>和<code>end</code>指定需要检查的字符串的子集。</p><h4 id="查找子字符串"><a href="#查找子字符串" class="headerlink" title="查找子字符串"></a>查找子字符串</h4><p><code>string.find(str, beg=0, end=len(string))</code></p><p>该方法检测字符串中是否包含子字符串<code>str</code>，如果包含则返回开始的索引值，否则返回-1。搜索可以指定开始和结束的索引范围。</p><h4 id="类似find但异常"><a href="#类似find但异常" class="headerlink" title="类似find但异常"></a>类似find但异常</h4><p><code>string.index(str, beg=0, end=len(string))</code></p><p>与<code>find()</code>方法类似，但如果子字符串不在字符串中，则会引发一个异常。</p><h4 id="检查字母和数字"><a href="#检查字母和数字" class="headerlink" title="检查字母和数字"></a>检查字母和数字</h4><ul><li><code>string.isalnum()</code>：如果字符串至少有一个字符并且所有字符都是字母或数字，则返回<code>True</code>。</li><li><code>string.isalpha()</code>：如果字符串至少有一个字符并且所有字符都是字母，则返回<code>True</code>。</li><li><code>string.isdecimal()</code>：如果字符串只包含十进制数字，则返回<code>True</code>。</li><li><code>string.isdigit()</code>：如果字符串只包含数字，则返回<code>True</code>。</li></ul><h4 id="检查大小写"><a href="#检查大小写" class="headerlink" title="检查大小写"></a>检查大小写</h4><ul><li><code>string.islower()</code>：如果字符串中包含至少一个区分大小写的字符，并且所有这些字符都是小写，则返回<code>True</code>。</li><li><code>string.isupper()</code>：如果字符串中包含至少一个区分大小写的字符，并且所有这些字符都是大写，则返回<code>True</code>。</li></ul><h4 id="其他检查"><a href="#其他检查" class="headerlink" title="其他检查"></a>其他检查</h4><ul><li><code>string.isnumeric()</code>：如果字符串中只包含数字字符，则返回<code>True</code>。</li><li><code>string.isspace()</code>：如果字符串中只包含空格，则返回<code>True</code>。</li><li><code>string.istitle()</code>：如果字符串是标题化的（即每个单词的首字母大写），则返回<code>True</code>。</li></ul><h4 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h4><p><strong><code>string.join(seq)</code></strong></p><p>该方法以指定的字符串作为分隔符，将序列中的元素连接成一个新的字符串。</p><p><strong>使用加号 <code>+</code> 运算符</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">&quot;Hello&quot;</span>  </span><br><span class="line">str2 = <span class="string">&quot;World&quot;</span>  </span><br><span class="line">str3 = str1 + <span class="string">&quot; &quot;</span> + str2  </span><br><span class="line"><span class="built_in">print</span>(str3)  <span class="comment"># 输出: Hello World</span></span><br></pre></td></tr></table></figure><p>在这个例子中，我们使用了 <code>+</code> 运算符和空格字符串来连接 <code>str1</code> 和 <code>str2</code>。</p><h4 id="转换大小写"><a href="#转换大小写" class="headerlink" title="转换大小写"></a>转换大小写</h4><ul><li><code>string.lower()</code>：将字符串中的所有大写字符转换为小写。</li><li><code>string.upper()</code>：将字符串中的所有小写字符转换为大写。</li></ul><h4 id="去除空格"><a href="#去除空格" class="headerlink" title="去除空格"></a>去除空格</h4><ul><li><code>string.lstrip()</code>：删除字符串左边的空格。</li><li><code>string.rstrip()</code>：删除字符串右边的空格（注：该方法未在上文列出，但经常与<code>lstrip()</code>一起使用）。</li><li><code>string.strip([obj])</code>：在字符串上同时执行<code>lstrip()</code>和<code>rstrip()</code>，删除两端的空格或指定字符。</li></ul><h4 id="替换子字符串"><a href="#替换子字符串" class="headerlink" title="替换子字符串"></a>替换子字符串</h4><p><code>string.replace(str1, str2, num=string.count(str1))</code></p><p>该方法把字符串中的<code>str1</code>替换成<code>str2</code>，如果指定了<code>num</code>，则替换不超过<code>num</code>次。</p><h4 id="分割字符串"><a href="#分割字符串" class="headerlink" title="分割字符串"></a>分割字符串</h4><p><code>string.split(str=&quot;&quot;, num=string.count(str))</code></p><p>该方法以指定的分隔符切片字符串，如果指定了<code>num</code>，则仅分隔出<code>num+1</code>个子字符串。</p><h4 id="检查字符串开始"><a href="#检查字符串开始" class="headerlink" title="检查字符串开始"></a>检查字符串开始</h4><p><code>string.startswith(obj, beg=0, end=len(string))</code></p><p>该方法检查字符串是否以指定的前缀开始，如果是则返回<code>True</code>，否则返回<code>False</code>。</p><h4 id="交换大小写"><a href="#交换大小写" class="headerlink" title="交换大小写"></a>交换大小写</h4><p><code>string.swapcase()</code></p><p>该方法翻转字符串中的大小写，即大写变小写，小写变大写。</p><h4 id="标题化字符串"><a href="#标题化字符串" class="headerlink" title="标题化字符串"></a>标题化字符串</h4><p><code>string.title()</code></p><p>该方法返回“标题化”的字符串，即所有单词的首字母大写，其余小写。</p><p>需要注意的是，字符串的方法很多，而且功能强大，但这里只列出了一些常用的方法。在实际编程中，可以根据需要选择合适的方法来操作字符串。</p><h2 id="序列的切片"><a href="#序列的切片" class="headerlink" title="序列的切片"></a>序列的切片</h2><p>序列是内容连续、有序，且可以使用下标索引的一类数据容器。在Python中，列表、元组、字符串均可以视为序列。</p><p>对序列进行切片操作可以得到序列的一个子序列。切片操作使用冒号(<code>:</code>)分隔的下标索引来实现，基本语法为<code>sequence[start:end:step]</code>，其中：</p><ul><li><code>sequence</code>表示要进行切片操作的序列。</li><li><code>start</code>表示切片操作的起始位置（包含该位置），如果省略则表示从头开始。</li><li><code>end</code>表示切片操作的结束位置（不包含该位置），如果省略则表示直到序列末尾。</li><li><code>step</code>表示切片操作的步长，即每隔多少个元素取一个，如果省略则表示步长为1。</li></ul><p>注意，<strong>切片操作不会影响序列本身</strong>，而是会得到一个新的序列。</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><h4 id="列表切片"><a href="#列表切片" class="headerlink" title="列表切片"></a>列表切片</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mylist = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从索引1开始到索引4之前（不包含索引4）的子序列</span></span><br><span class="line">result1 = mylist[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(result1)  <span class="comment"># 输出: [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从索引2开始到索引9之前，每隔2个元素取一个的子序列</span></span><br><span class="line">result2 = mylist[<span class="number">2</span>:<span class="number">9</span>:<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(result2)  <span class="comment"># 输出: [2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure><h4 id="元组切片"><a href="#元组切片" class="headerlink" title="元组切片"></a>元组切片</h4><p>元组的切片操作与列表类似。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mytuple = (<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从头到尾的子序列（复制整个元组）</span></span><br><span class="line">r1 = mytuple[:]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;r1=<span class="subst">&#123;r1&#125;</span>&quot;</span>)  <span class="comment"># 输出: r1=(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从尾到头的子序列（反转整个元组）</span></span><br><span class="line">r2 = mytuple[::-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;r2=<span class="subst">&#123;r2&#125;</span>&quot;</span>)  <span class="comment"># 输出: r2=(10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)</span></span><br></pre></td></tr></table></figure><h4 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h4><p>字符串也可以进行切片操作，得到一个新的字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mystring = <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从索引7开始到末尾的子字符串</span></span><br><span class="line">result3 = mystring[<span class="number">7</span>:]</span><br><span class="line"><span class="built_in">print</span>(result3)  <span class="comment"># 输出: World!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从头开始到索引5之前（不包含索引5）的子字符串，每隔2个字符取一个</span></span><br><span class="line">result4 = mystring[:<span class="number">5</span>:<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(result4)  <span class="comment"># 输出: Hlo</span></span><br></pre></td></tr></table></figure><h2 id="Set——集合"><a href="#Set——集合" class="headerlink" title="Set——集合"></a>Set——集合</h2><p>集合是一个无序的、不重复的数据集合。在Python中，集合用花括号<code>&#123;&#125;</code>或者<code>set()</code>函数创建，但由于花括号<code>&#123;&#125;</code>同时用于表示字典，所以空集合必须用<code>set()</code>表示，而不是<code>&#123;&#125;</code>。</p><h3 id="集合的创建与特性"><a href="#集合的创建与特性" class="headerlink" title="集合的创建与特性"></a>集合的创建与特性</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用花括号创建集合（非空集合）</span></span><br><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">11</span>&#125;</span><br><span class="line"><span class="comment"># 使用set()创建空集合</span></span><br><span class="line">c = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印集合a和c</span></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 输出: &#123;1, 2, 3, 4, 5, 6, 11&#125;，注意重复元素被自动去除了</span></span><br><span class="line"><span class="built_in">print</span>(c)  <span class="comment"># 输出: set()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：空的大括号表示字典，不是集合</span></span><br><span class="line">b = &#123;&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(b))  <span class="comment"># 输出: &lt;class &#x27;dict&#x27;&gt;</span></span><br></pre></td></tr></table></figure><h3 id="集合的修改"><a href="#集合的修改" class="headerlink" title="集合的修改"></a>集合的修改</h3><p>集合是可变的，可以添加或删除元素。</p><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><p>使用<code>.add()</code>方法向集合添加元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">11</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line">a.add(<span class="number">1</span>)  <span class="comment"># 添加元素1到集合a中</span></span><br><span class="line">a.add(<span class="number">5</span>)  <span class="comment"># 添加元素5（已存在，不会重复添加）</span></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 输出: &#123;1, 2, 3, 4, 5, 6, 7, 11&#125;</span></span><br></pre></td></tr></table></figure><h4 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h4><p>使用<code>.remove()</code>方法从集合中移除指定元素；使用<code>.pop()</code>方法随机移除并返回集合中的一个元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">11</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line">a.remove(<span class="number">3</span>)  <span class="comment"># 移除元素3</span></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 输出: &#123;2, 4, 5, 6, 7, 11&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用pop()方法从集合中随机移除元素并打印</span></span><br><span class="line">a = &#123;<span class="number">11</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(a) &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(a.pop())</span><br><span class="line"><span class="comment"># 输出可能是集合a中的任意元素，因为移除是随机的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：pop()取出的过程对于字符串是随机的,即每次运行结果都不同</span></span><br></pre></td></tr></table></figure><h3 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h3><h4 id="差集"><a href="#差集" class="headerlink" title="差集"></a>差集</h4><p>使用<code>.difference()</code>方法可以得到两个集合的差集，即存在于第一个集合但不存在于第二个集合的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;</span><br><span class="line">diff = set1.difference(set2)</span><br><span class="line"><span class="built_in">print</span>(diff)  <span class="comment"># 输出: &#123;1, 2, 3&#125;，这些元素只存在于set1中</span></span><br></pre></td></tr></table></figure><h4 id="差集并更新左集合"><a href="#差集并更新左集合" class="headerlink" title="差集并更新左集合"></a>差集并更新左集合</h4><p>使用<code>.difference_update()</code>方法可以直接更新左集合为差集结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;</span><br><span class="line">set1.difference_update(set2)  <span class="comment"># set1现在更新为差集结果</span></span><br><span class="line"><span class="built_in">print</span>(set1)  <span class="comment"># 输出: &#123;1, 2, 3&#125;</span></span><br></pre></td></tr></table></figure><h4 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h4><p>使用<code>.union()</code>方法可以得到两个集合的并集，即两个集合中所有不重复的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">union_set = set1.union(set2)</span><br><span class="line"><span class="built_in">print</span>(union_set)  <span class="comment"># 输出: &#123;1, 2, 3, 4, 5&#125;</span></span><br></pre></td></tr></table></figure><h3 id="集合的长度"><a href="#集合的长度" class="headerlink" title="集合的长度"></a>集合的长度</h3><p>使用<code>len()</code>函数可以得到集合中元素的数量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(a))  <span class="comment"># 输出: 9，因为集合自动去除了重复元素</span></span><br></pre></td></tr></table></figure><h3 id="集合的遍历"><a href="#集合的遍历" class="headerlink" title="集合的遍历"></a>集合的遍历</h3><p>由于集合不支持下标索引，所以不能使用<code>while</code>循环通过下标来遍历集合。但可以使用<code>for</code>循环直接遍历集合中的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">for</span> ele <span class="keyword">in</span> set1:</span><br><span class="line">    <span class="built_in">print</span>(ele, end=<span class="string">&quot; &quot;</span>)  <span class="comment"># 输出: 1 2 3 4 5（顺序可能不同，因为集合是无序的）</span></span><br></pre></td></tr></table></figure><h2 id="字典——dict"><a href="#字典——dict" class="headerlink" title="字典——dict"></a>字典——dict</h2><p>字典（dict）是Python中的一种基本数据结构，用于存储键值对（key-value pairs）。字典是无序的，即元素的插入顺序和迭代顺序可能不一致。<strong>字典的键（key）必须是不可变的类型</strong>，如整数、浮点数、字符串、元组等，而值（value）可以是任意Python对象。</p><h3 id="创建字典"><a href="#创建字典" class="headerlink" title="创建字典"></a>创建字典</h3><p>字典可以通过大括号 <code>&#123;&#125;</code> 或 <code>dict()</code> 函数来创建。大括号中，键值对之间用冒号分隔，每对键值对之间用逗号分隔。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d1 = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">97</span>, <span class="string">&quot;b&quot;</span>: <span class="number">98</span>, <span class="string">&quot;c&quot;</span>: <span class="number">99</span>, <span class="string">&quot;d&quot;</span>: <span class="number">100</span>&#125;</span><br><span class="line">d2 = &#123;&#125;  <span class="comment"># 空字典</span></span><br><span class="line">d3 = <span class="built_in">dict</span>()  <span class="comment"># 通过dict()函数创建空字典</span></span><br></pre></td></tr></table></figure><h3 id="访问字典元素"><a href="#访问字典元素" class="headerlink" title="访问字典元素"></a>访问字典元素</h3><p>字典中的元素可以通过键来访问。使用方括号 <code>[]</code> 和键名来获取对应的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d1 = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">97</span>, <span class="string">&quot;b&quot;</span>: <span class="number">98</span>, <span class="string">&quot;c&quot;</span>: <span class="number">99</span>, <span class="string">&quot;d&quot;</span>: <span class="number">100</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(d1[<span class="string">&quot;b&quot;</span>])  <span class="comment"># 输出 98</span></span><br></pre></td></tr></table></figure><h3 id="新增和更新字典元素"><a href="#新增和更新字典元素" class="headerlink" title="新增和更新字典元素"></a>新增和更新字典元素</h3><p>可以通过方括号 <code>[]</code> 来新增或更新字典中的元素。如果键已经存在，则对应的值会被更新；如果键不存在，则会在字典中新增一个键值对。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d1 = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">97</span>, <span class="string">&quot;b&quot;</span>: <span class="number">98</span>&#125;</span><br><span class="line">d1[<span class="string">&quot;c&quot;</span>] = <span class="number">99</span>  <span class="comment"># 新增键值对</span></span><br><span class="line">d1[<span class="string">&quot;a&quot;</span>] = <span class="number">100</span>  <span class="comment"># 更新键&quot;a&quot;对应的值</span></span><br></pre></td></tr></table></figure><p>需要注意的是，<strong>字典不支持访问不存在的键，否则会抛出<code>KeyError</code>异常</strong>。如果尝试访问不存在的键，可以使用<code>get()</code>方法，该方法允许指定一个默认值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d1 = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">97</span>, <span class="string">&quot;b&quot;</span>: <span class="number">98</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(d1.get(<span class="string">&quot;c&quot;</span>, <span class="string">&quot;Not Found&quot;</span>))  <span class="comment"># 输出 &quot;Not Found&quot;</span></span><br></pre></td></tr></table></figure><h3 id="删除字典元素"><a href="#删除字典元素" class="headerlink" title="删除字典元素"></a>删除字典元素</h3><p>可以使用<code>pop()</code>方法来删除字典中的元素，并返回被删除元素的值。<strong>如果尝试删除不存在的键，<code>pop()</code>方法会抛出<code>KeyError</code>异常，但可以通过提供第二个参数来指定一个默认值</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d1 = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">97</span>, <span class="string">&quot;b&quot;</span>: <span class="number">98</span>, <span class="string">&quot;c&quot;</span>: <span class="number">99</span>&#125;</span><br><span class="line">value = d1.pop(<span class="string">&quot;b&quot;</span>)  <span class="comment"># 删除键&quot;b&quot;并返回其值</span></span><br><span class="line"><span class="built_in">print</span>(value)  <span class="comment"># 输出 98</span></span><br></pre></td></tr></table></figure><p>另外，<code>clear()</code>方法可以清空字典中的所有元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d1.clear()  <span class="comment"># 清空字典</span></span><br><span class="line"><span class="built_in">print</span>(d1)  <span class="comment"># 输出 &#123;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="获取字典的键和值"><a href="#获取字典的键和值" class="headerlink" title="获取字典的键和值"></a>获取字典的键和值</h3><p>可以使用<code>keys()</code>方法获取字典中所有的键，<code>values()</code>方法获取所有的值。<strong>这两个方法返回的都是视图对象，它们会反映字典的任何更改。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d1 = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">97</span>, <span class="string">&quot;b&quot;</span>: <span class="number">98</span>, <span class="string">&quot;c&quot;</span>: <span class="number">99</span>&#125;</span><br><span class="line">keys = d1.keys()</span><br><span class="line">values = d1.values()</span><br><span class="line"><span class="built_in">print</span>(keys)  <span class="comment"># 输出 dict_keys([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;])</span></span><br><span class="line"><span class="built_in">print</span>(values)  <span class="comment"># 输出 dict_values([97, 98, 99])</span></span><br></pre></td></tr></table></figure><h3 id="遍历字典"><a href="#遍历字典" class="headerlink" title="遍历字典"></a>遍历字典</h3><p>字典可以通过多种方式进行遍历。最常见的是遍历所有的键，然后使用键来访问对应的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d1 = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">97</span>, <span class="string">&quot;b&quot;</span>: <span class="number">98</span>, <span class="string">&quot;c&quot;</span>: <span class="number">99</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> d1:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;key=<span class="subst">&#123;key&#125;</span>, value=<span class="subst">&#123;d1[key]&#125;</span>&quot;</span>, end=<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure><p>还可以直接遍历字典的项（键值对），这可以通过<code>items()</code>方法来实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> d1.items():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;key=<span class="subst">&#123;key&#125;</span>, value=<span class="subst">&#123;value&#125;</span>&quot;</span>, end=<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="统计字典元素数量"><a href="#统计字典元素数量" class="headerlink" title="统计字典元素数量"></a>统计字典元素数量</h3><p>使用<code>len()</code>函数可以获取字典中元素的数量（键值对的数量）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d1 = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">97</span>, <span class="string">&quot;b&quot;</span>: <span class="number">98</span>, <span class="string">&quot;c&quot;</span>: <span class="number">99</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(d1))  <span class="comment"># 输出 3</span></span><br></pre></td></tr></table></figure><h3 id="判断元素是否在字典内"><a href="#判断元素是否在字典内" class="headerlink" title="判断元素是否在字典内"></a>判断元素是否在字典内</h3><p>可以使用<code>in</code>关键字来判断一个键是否存在于字典中。同样地，<code>not in</code>可以用来判断一个键是否不存在于字典中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d1 = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">97</span>, <span class="string">&quot;b&quot;</span>: <span class="number">98</span>, <span class="string">&quot;c&quot;</span>: <span class="number">99</span>&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;c&quot;</span> <span class="keyword">in</span> d1:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;in&quot;</span>)  <span class="comment"># 输出 in</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;p&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> d1:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;not in&quot;</span>)  <span class="comment"># 输出 not in</span></span><br></pre></td></tr></table></figure><h2 id="容器常用功能"><a href="#容器常用功能" class="headerlink" title="容器常用功能"></a>容器常用功能</h2><h3 id="容器之间的转换"><a href="#容器之间的转换" class="headerlink" title="容器之间的转换"></a>容器之间的转换</h3><h4 id="转换为列表-list"><a href="#转换为列表-list" class="headerlink" title="转换为列表(list)"></a>转换为列表(list)</h4><p>在Python中，列表（list）是一种非常常用的数据结构，它可以容纳不同类型的元素，包括数字、字符串、元组、集合甚至字典等。Python提供了便捷的方式将这些容器类型转换为列表。</p><h5 id="从元组-tuple-转换"><a href="#从元组-tuple-转换" class="headerlink" title="从元组(tuple)转换"></a>从元组(tuple)转换</h5><p>元组与列表非常相似，但元组是不可变的。我们可以使用<code>list()</code>函数将元组转换为列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a1 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(a1))  <span class="comment"># 输出: [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><h5 id="从字符串-string-转换"><a href="#从字符串-string-转换" class="headerlink" title="从字符串(string)转换"></a>从字符串(string)转换</h5><p>字符串可以被看作字符的序列，因此也可以被转换为列表，每个字符成为列表的一个元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b1 = <span class="string">&quot;abcdefg&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(b1))  <span class="comment"># 输出: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;]</span></span><br></pre></td></tr></table></figure><h5 id="从集合-set-转换"><a href="#从集合-set-转换" class="headerlink" title="从集合(set)转换"></a>从集合(set)转换</h5><p>集合是一个无序的不重复元素集，转换为列表后会得到一个包含集合中所有元素的列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(c1))  <span class="comment"># 输出可能是: [1, 2, 3, 4, 5] （因为集合是无序的，所以实际输出可能不同）</span></span><br></pre></td></tr></table></figure><h5 id="从字典-dictionary-转换"><a href="#从字典-dictionary-转换" class="headerlink" title="从字典(dictionary)转换"></a>从字典(dictionary)转换</h5><p>字典转换为列表时，默认只包含字典的键(key)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d1 = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">97</span>, <span class="string">&quot;b&quot;</span>: <span class="number">98</span>, <span class="string">&quot;c&quot;</span>: <span class="number">99</span>, <span class="string">&quot;d&quot;</span>: <span class="number">100</span>, <span class="string">&quot;e&quot;</span>: <span class="number">101</span>, <span class="string">&quot;f&quot;</span>: <span class="number">102</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(d1))  <span class="comment"># 输出: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;]（字典的键转换为列表）</span></span><br></pre></td></tr></table></figure><p><strong>如果想要同时获取键和值，可以使用<code>items()</code>方法</strong>，它会返回一个包含键值对的元组列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(d1.items()))  <span class="comment"># 输出: [(&#x27;a&#x27;, 97), (&#x27;b&#x27;, 98), (&#x27;c&#x27;, 99), (&#x27;d&#x27;, 100), (&#x27;e&#x27;, 101), (&#x27;f&#x27;, 102)]</span></span><br></pre></td></tr></table></figure><h3 id="转换为其他类型"><a href="#转换为其他类型" class="headerlink" title="转换为其他类型"></a>转换为其他类型</h3><p>当然，Python也允许我们将列表转换为其他类型，如元组、字符串、集合等。</p><h4 id="转换为元组-tuple"><a href="#转换为元组-tuple" class="headerlink" title="转换为元组(tuple)"></a>转换为元组(tuple)</h4><p>使用<code>tuple()</code>函数可以将列表转换为元组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>(lst))  <span class="comment"># 输出: (1, 2, 3, 4, 5)</span></span><br></pre></td></tr></table></figure><h4 id="转换为字符串-string"><a href="#转换为字符串-string" class="headerlink" title="转换为字符串(string)"></a>转换为字符串(string)</h4><p>在Python中，将列表转化为字符串可以通过多种方式实现。最常见的方法是使用 <code>join()</code> 方法，它可以将列表中的元素连接起来形成一个字符串。以下是一个简单的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>, <span class="string">&#x27;this&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;list&#x27;</span>]  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 使用空格作为分隔符将列表元素连接成字符串  </span></span><br><span class="line">my_string = <span class="string">&#x27; &#x27;</span>.join(my_list)  </span><br><span class="line"><span class="built_in">print</span>(my_string)  <span class="comment"># 输出：Hello world this is a list  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 如果列表中包含数字或其他非字符串类型，需要先将它们转换为字符串  </span></span><br><span class="line">my_mixed_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>]  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 使用map函数和str将列表中的每个元素转换为字符串，然后再连接  </span></span><br><span class="line">my_string_from_mixed_list = <span class="string">&#x27; &#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, my_mixed_list))  </span><br><span class="line"><span class="built_in">print</span>(my_string_from_mixed_list)  <span class="comment"># 输出：1 2 3 apple banana</span></span><br></pre></td></tr></table></figure><h4 id="转换为集合-set"><a href="#转换为集合-set" class="headerlink" title="转换为集合(set)"></a>转换为集合(set)</h4><p>使用<code>set()</code>函数可以将列表转换为集合，从而去除重复元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">set</span>(lst))  <span class="comment"># 输出: &#123;1, 2, 3, 4, 5&#125;</span></span><br></pre></td></tr></table></figure><h3 id="排序功能-sorted"><a href="#排序功能-sorted" class="headerlink" title="排序功能(sorted)"></a>排序功能(sorted)</h3><p>Python的<code>sorted()</code>函数可以对任何可迭代对象进行排序，并返回一个列表。默认情况下，排序是升序的，但<strong>可以通过<code>reverse=True</code>参数进行降序排序</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a1 = (<span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(a1))  <span class="comment"># 输出: [0, 2, 4, 5, 6] （升序）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(a1, reverse=<span class="literal">True</span>))  <span class="comment"># 输出: [6, 5, 4, 2, 0] （降序）</span></span><br></pre></td></tr></table></figure><p>对于字符串和字典的排序，<code>sorted()</code>函数会根据元素的字符顺序或键的顺序进行排序。如果想要根据其他标准进行排序，可以使用<code>key</code>参数指定一个函数来提取用于排序的值。</p><h1 id="头等函数"><a href="#头等函数" class="headerlink" title="头等函数"></a>头等函数</h1><h2 id="函数作为参数传递"><a href="#函数作为参数传递" class="headerlink" title="函数作为参数传递"></a>函数作为参数传递</h2><p>在Python中，函数是对象，可以像其他对象一样被传递作为参数。这种能力使得函数变得更加灵活和强大。你可以将函数作为参数传递给其他函数，或者从其他函数中返回函数。</p><h3 id="函数作为参数的示例"><a href="#函数作为参数的示例" class="headerlink" title="函数作为参数的示例"></a>函数作为参数的示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_func</span>(<span class="params">compute</span>):</span><br><span class="line">    result = compute(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">type</span>(compute))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将add函数作为参数传递给test_func</span></span><br><span class="line">test_func(add)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">&lt;class &#x27;function&#x27;&gt;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>test_func</code>接收一个名为<code>compute</code>的函数作为参数，并使用它来计算1和2的和。然后打印结果和<code>compute</code>的类型，显示为<code>&lt;class &#39;function&#39;&gt;</code>，表明<code>compute</code>确实是一个函数对象。</p><h2 id="使用lambda匿名函数作为参数"><a href="#使用lambda匿名函数作为参数" class="headerlink" title="使用lambda匿名函数作为参数"></a>使用lambda匿名函数作为参数</h2><p>lambda函数是一种简洁的写函数的方式，它可以在一行内定义简单的函数。lambda函数是匿名的，因为它们没有正式的函数名，但可以将它们赋值给变量，或者以其他方式使用，例如作为函数的参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_func</span>(<span class="params">compute</span>):</span><br><span class="line">    result = compute(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">type</span>(compute))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将lambda函数作为参数传递给test_func</span></span><br><span class="line">test_func(<span class="keyword">lambda</span> x, y: x + y)<span class="comment">#可以不写出return</span></span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">&lt;class &#x27;function&#x27;&gt;</span><br></pre></td></tr></table></figure><p>这里，我们创建了一个lambda函数<code>lambda x, y: x + y</code>，它接收两个参数<code>x</code>和<code>y</code>，并返回它们的和。然后我们将这个lambda函数作为参数传递给<code>test_func</code>。输出与前面的例子相同，因为lambda函数的行为与<code>add</code>函数相同。</p><p>请注意，在lambda函数中，虽然我们没有明确写出<code>return</code>关键字，但表达式<code>x + y</code>的结果会被自动返回。这是lambda函数的一个特点：它们总是返回表达式的结果。</p><p>在Python中，<strong><code>lambda</code>函数是设计为单行表达式函数的，它们只能包含一个表达式，该表达式的值会被返回。</strong>因此，<code>lambda</code>函数不支持多行语句或多条指令。如果你想定义一个多行的函数，你应该使用<code>def</code>关键字来定义一个常规函数。</p><h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><h2 id="模块的概念"><a href="#模块的概念" class="headerlink" title="模块的概念"></a>模块的概念</h2><p>在Python中，模块（Module）是一个包含Python定义和语句的文件。文件名就是模块名加上<code>.py</code>后缀。模块可以被其他程序引入，以使用该模块中的函数、类等功能。模块可以包含可执行的语句和定义函数、类和变量。模块让你能够有逻辑地组织你的Python代码段，实现代码重用。</p><h3 id="模块的导入"><a href="#模块的导入" class="headerlink" title="模块的导入"></a>模块的导入</h3><h4 id="1-使用import语句导入整个模块"><a href="#1-使用import语句导入整个模块" class="headerlink" title="1. 使用import语句导入整个模块"></a>1. 使用<code>import</code>语句导入整个模块</h4><p>你可以使用<code>import</code>语句导入整个模块，并通过模块名来访问其中的函数、类、变量等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time  <span class="comment"># 导入整个time模块</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)  <span class="comment"># 使用time模块中的sleep函数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h4 id="2-使用from-import-语句导入模块中的特定部分"><a href="#2-使用from-import-语句导入模块中的特定部分" class="headerlink" title="2. 使用from ... import ...语句导入模块中的特定部分"></a>2. 使用<code>from ... import ...</code>语句导入模块中的特定部分</h4><p>如果你只需要模块中的某个函数或类，可以使用<code>from ... import ...</code>语句将其导入到当前命名空间中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep  <span class="comment"># 只导入time模块中的sleep函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">sleep(<span class="number">1</span>)  <span class="comment"># 直接使用sleep函数，不需要加模块名前缀</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h4 id="3-使用from-import-语句导入模块中的所有内容"><a href="#3-使用from-import-语句导入模块中的所有内容" class="headerlink" title="3. 使用from ... import *语句导入模块中的所有内容"></a>3. 使用<code>from ... import *</code>语句导入模块中的所有内容</h4><p>虽然这种方式可以导入模块中的所有内容，<strong>但通常不推荐使用，因为它可能导致命名冲突和不可预见的行为。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> *  <span class="comment"># 导入time模块中的所有内容（不推荐）</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">sleep(<span class="number">1</span>)  <span class="comment"># 直接使用sleep函数，不需要加模块名前缀</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="给模块起别名"><a href="#给模块起别名" class="headerlink" title="给模块起别名"></a>给模块起别名</h3><p>如果模块名太长或与其他模块名冲突，你可以使用<code>as</code>关键字给模块起一个别名。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time <span class="keyword">as</span> t  <span class="comment"># 给time模块起别名为t</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">t.sleep(<span class="number">1</span>)  <span class="comment"># 使用别名t来访问time模块中的sleep函数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="给函数起别名"><a href="#给函数起别名" class="headerlink" title="给函数起别名"></a>给函数起别名</h3><p>同样地，你也可以使用<code>as</code>关键字给导入的函数起别名。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep <span class="keyword">as</span> sl  <span class="comment"># 给sleep函数起别名为sl</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">sl(<span class="number">1</span>)  <span class="comment"># 使用别名sl来调用sleep函数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h2 id="定义自己的模块"><a href="#定义自己的模块" class="headerlink" title="定义自己的模块"></a>定义自己的模块</h2><h3 id="自定义模块"><a href="#自定义模块" class="headerlink" title="自定义模块"></a>自定义模块</h3><p>在Python中，模块是一个包含Python定义和语句的文件。文件名是模块名加上<code>.py</code>后缀。模块可以被其他程序引入，以使用该模块中的函数、类等。在本例中，我们将创建一个简单的模块，并展示如何在其他文件中导入和使用它。</p><h3 id="创建模块"><a href="#创建模块" class="headerlink" title="创建模块"></a>创建模块</h3><p>首先，我们创建一个名为<code>greetings.py</code>的模块，它包含一个名为<code>print_hi</code>的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># greetings.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_hi</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Hi, <span class="subst">&#123;name&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    print_hi(<span class="string">&#x27;PyCharm&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在这个模块中：</p><ul><li>我们定义了一个名为<code>print_hi</code>的函数，它接受一个参数<code>name</code>，并打印出问候语。</li><li>我们使用了一个特殊的条件语句<code>if __name__ == &#39;__main__&#39;:</code>。当<strong>这个模块作为主程序运行时（即直接运行<code>greetings.py</code>文件），这个条件语句下的代码会被执行</strong>。因此，它会打印出“Hi, PyCharm”。但是，当这个模块被其他文件导入时，这个条件语句下的代码不会被执行。</li></ul><h2 id="导入和使用模块"><a href="#导入和使用模块" class="headerlink" title="导入和使用模块"></a>导入和使用模块</h2><p>现在，我们可以在另一个Python文件中导入这个模块，并使用它提供的函数。例如，创建一个名为<code>main.py</code>的文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> greetings</span><br><span class="line"></span><br><span class="line">greetings.print_hi(<span class="string">&#x27;Alice&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在这个文件中，我们使用<code>import</code>语句导入了<code>greetings</code>模块，并<strong>使用点符号（<code>.</code>）访问模块中的<code>print_hi</code>函数</strong>。当我们运行<code>main.py</code>文件时，它会输出“Hi, Alice”。</p><p>注意，由于我们在<code>greetings.py</code>文件中使用了<code>if __name__ == &#39;__main__&#39;:</code>语句，所以当我们导入这个模块时，它不会自动执行<code>print_hi(&#39;PyCharm&#39;)</code>语句。因此，输出仅为“Hi, Alice”，而不包括“Hi, PyCharm”。</p><h1 id="自定义Python包"><a href="#自定义Python包" class="headerlink" title="自定义Python包"></a>自定义Python包</h1><h2 id="什么是Python包"><a href="#什么是Python包" class="headerlink" title="什么是Python包"></a>什么是Python包</h2><p>从物理结构上看，<strong>Python包就是一个文件夹</strong>，它包含一个<code>__init__.py</code>文件，并且该文件夹内可以包含多个模块文件（即.py文件）。这个文件夹的层级结构可以表示包的层级关系。</p><p>从逻辑层面来看，包可以看作是一个更大规模的模块，它允许我们将相关的模块组织在一起，形成一个有层次的命名空间。</p><h2 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h2><p>在Python中，导入包有几种不同的方式：</p><h3 id="方式一：使用import语句"><a href="#方式一：使用import语句" class="headerlink" title="方式一：使用import语句"></a>方式一：使用import语句</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> 包名.模块名</span><br></pre></td></tr></table></figure><p>使用方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">包名.模块名.目标函数()</span><br></pre></td></tr></table></figure><h3 id="方式二：使用from…import语句"><a href="#方式二：使用from…import语句" class="headerlink" title="方式二：使用from…import语句"></a>方式二：使用from…import语句</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> 包名 <span class="keyword">import</span> 模块名</span><br></pre></td></tr></table></figure><p>使用方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模块名.目标函数()</span><br></pre></td></tr></table></figure><h3 id="方式三：直接导入目标函数"><a href="#方式三：直接导入目标函数" class="headerlink" title="方式三：直接导入目标函数"></a>方式三：直接导入目标函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> 包名.模块名 <span class="keyword">import</span> 目标函数</span><br></pre></td></tr></table></figure><p>使用方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">目标函数()</span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>在使用包中的模块或函数之前，需要确保包已经被正确安装或位于Python的搜索路径中。</li><li><code>__init__.py</code>文件是包的初始化文件，它可以是空的，也可以包含一些初始化代码或定义<code>__all__</code>变量来指定当使用<code>from 包名 import *</code>时应该导入哪些模块。</li></ul><h2 id="安装第三方包"><a href="#安装第三方包" class="headerlink" title="安装第三方包"></a>安装第三方包</h2><h3 id="什么是第三方包"><a href="#什么是第三方包" class="headerlink" title="什么是第三方包"></a>什么是第三方包</h3><p>第三方包指的是非Python官方提供的包，它们由Python社区中的开发者创建和维护。这些包通常用于解决特定的问题或提供特定的功能，例如数据处理、机器学习、网络编程等。</p><h3 id="安装第三方包-pip"><a href="#安装第三方包-pip" class="headerlink" title="安装第三方包 - pip"></a>安装第三方包 - pip</h3><p>pip是Python的包管理工具，它允许你轻松地安装、升级和卸载Python包。你可以使用pip来安装第三方包。</p><h3 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h3><p>在命令行中，使用以下命令来安装第三方包：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install 包名称</span><br></pre></td></tr></table></figure><p>这将会从Python Package Index（PyPI）下载并安装包。</p><h3 id="pip的网络优化"><a href="#pip的网络优化" class="headerlink" title="pip的网络优化"></a>pip的网络优化</h3><p>由于pip默认连接的是国外的PyPI源，有时下载速度可能会很慢。你<strong>可以通过指定国内的镜像源来加速包的下载</strong>。例如，使用清华大学提供的PyPI镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple 包名称</span><br></pre></td></tr></table></figure><p>或者，你可以永久地修改pip的配置文件，将默认的源替换为国内的镜像源。这样，每次使用pip安装包时都会自动从国内的镜像源下载。</p><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><ul><li>在安装第三方包之前，确保你的Python环境已经正确设置，并且pip工具已经安装。</li><li>有些第三方包可能依赖于其他包或特定版本的Python，因此在安装之前最好查看包的文档以了解其依赖关系和要求。</li><li><strong>如果你使用的是虚拟环境（virtualenv或conda等），则应在激活虚拟环境后安装第三方包，以确保它们仅在当前虚拟环境中可用。</strong></li></ul><h1 id="定义自己的数据类型——类和对象"><a href="#定义自己的数据类型——类和对象" class="headerlink" title="定义自己的数据类型——类和对象"></a>定义自己的数据类型——类和对象</h1><p>在Python中，类（Class）是一种抽象数据类型，它定义了包含数据（属性）和方法（函数）的对象的行为和状态。对象是类的实例，它具体地表示了类的属性和行为。</p><h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><p>类可以通过<code>class</code>关键字来定义，类的名称通常以大写字母开头。类中可以定义属性和方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cla</span>:</span><br><span class="line">    a = <span class="literal">None</span></span><br><span class="line">    b = <span class="literal">None</span></span><br><span class="line">    c = <span class="literal">None</span></span><br><span class="line">    d = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>Cla</code>是一个类，它定义了四个类属性<code>a</code>、<code>b</code>、<code>c</code>和<code>d</code>，它们都被初始化为<code>None</code>。</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>类中提供了私有成员的形式来支持。</p><ul><li>私有成员变量</li><li>私有成员方法</li></ul><p>定义私有成员的方式非常简单,只需要:</p><ul><li>私有成员变量:变量名以<code>__</code>开头(2个下划线)</li><li>私有成员方法:方法名以<code>__</code>开头（2个下划线）</li></ul><p>即可完成私有成员的设置</p><h2 id="对象的创建和属性赋值"><a href="#对象的创建和属性赋值" class="headerlink" title="对象的创建和属性赋值"></a>对象的创建和属性赋值</h2><p>要创建一个类的实例（对象），可以使用类名加上括号。然后可以通过点操作符<code>.</code>来访问对象的属性或方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c = Cla()  <span class="comment"># 创建一个Cla类的实例对象c</span></span><br><span class="line">c.a = <span class="string">&quot;abc&quot;</span>  <span class="comment"># 给对象c的a属性赋值</span></span><br><span class="line">c.b = <span class="number">1</span>      <span class="comment"># 给对象c的b属性赋值</span></span><br><span class="line">c.c = <span class="number">114.514</span>  <span class="comment"># 给对象c的c属性赋值</span></span><br><span class="line">c.d = <span class="literal">True</span>     <span class="comment"># 给对象c的d属性赋值</span></span><br></pre></td></tr></table></figure><p><strong>打印对象<code>c</code>会显示其内存地址</strong>，打印<code>type(c)</code>会显示其类型，而打印<code>c.a</code>则会显示其<code>a</code>属性的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(c)       <span class="comment"># 输出对象c的内存地址</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(c)) <span class="comment"># 输出对象c的类型</span></span><br><span class="line"><span class="built_in">print</span>(c.a)     <span class="comment"># 输出对象c的a属性的值</span></span><br></pre></td></tr></table></figure><h2 id="类的方法"><a href="#类的方法" class="headerlink" title="类的方法"></a>类的方法</h2><p>类还可以定义方法，方法是类的函数，它可以在类的对象上执行操作。<strong>方法的第一个参数总是<code>self</code>，它表示对象本身。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Man</span>:</span><br><span class="line">    name = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say_hi</span>(<span class="params">self</span>):<span class="comment">#self是必须填写的，调用类的方法的时候会自动传入该对象</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;我是<span class="subst">&#123;self.name&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say_hi_with_msg</span>(<span class="params">self, msg</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;我是<span class="subst">&#123;self.name&#125;</span>,<span class="subst">&#123;msg&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>Man</code>类定义了两个方法：<code>say_hi</code>和<code>say_hi_with_msg</code>。这两个方法都接受<code>self</code>作为第一个参数，表示对象本身。<code>say_hi</code>方法打印出对象的<code>name</code>属性，而<code>say_hi_with_msg</code>方法则打印出对象的<code>name</code>属性和一个额外的消息。</p><h3 id="对象的方法调用"><a href="#对象的方法调用" class="headerlink" title="对象的方法调用"></a>对象的方法调用</h3><p>要调用对象的方法，<strong>可以使用点操作符<code>.</code>和方法名</strong>。如果方法需要参数，可以在方法名后面的括号中提供。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">he = Man()         <span class="comment"># 创建一个Man类的实例对象he</span></span><br><span class="line">he.name = <span class="string">&quot;某人&quot;</span>   <span class="comment"># 给对象he的name属性赋值</span></span><br><span class="line">he.say_hi()        <span class="comment"># 调用对象he的say_hi方法</span></span><br><span class="line">he.say_hi_with_msg(<span class="string">&quot;hhhhhhh&quot;</span>)  <span class="comment"># 调用对象he的say_hi_with_msg方法并传递一个参数</span></span><br></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p><strong>在Python中，类的构造方法是<code>__init__()</code>。当创建类的新实例时，这个方法会自动被调用。构造方法通常用于初始化新创建对象的属性。</strong></p><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><p>下面是一个简单的<code>Student</code>类，它使用构造方法来初始化学生的姓名、年龄和电话号码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, tel</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.tel = tel</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个Student对象</span></span><br><span class="line">stu = Student(<span class="string">&quot;张三&quot;</span>, <span class="number">31</span>, <span class="string">&quot;1145141919810&quot;</span>)</span><br></pre></td></tr></table></figure><p>在这个例子中，当我们创建<code>stu</code>对象时，<code>__init__</code>方法被调用，并且我们传递的参数（”张三”, 31, “1145141919810”）被用来初始化对象的属性。</p><h3 id="魔术方法（Magic-Methods）"><a href="#魔术方法（Magic-Methods）" class="headerlink" title="魔术方法（Magic Methods）"></a>魔术方法（Magic Methods）</h3><p>Python中的魔术方法，也称为特殊方法或双下划线方法，是以双下划线开头和结尾的方法。这些方法有特殊的意义，并且通常在某种特定的操作发生时由Python自动调用。</p><h4 id="常见的魔术方法"><a href="#常见的魔术方法" class="headerlink" title="常见的魔术方法"></a>常见的魔术方法</h4><ul><li><code>__init__</code>: 构造方法，用于初始化新创建对象的状态。</li><li><code>__str__</code>: 返回对象的字符串表示形式，当我们尝试打印对象或使用<code>str()</code>转换对象时调用。</li><li><code>__lt__</code>: 定义小于（&lt;）操作符的行为。</li><li><code>__le__</code>: 定义小于等于（&lt;=）操作符的行为。</li><li><code>__eq__</code>: 定义等于（==）操作符的行为。</li></ul><h5 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h5><p>下面是一个扩展的<code>Student</code>类，包含了<code>__str__</code>，<code>__lt__</code>，<code>__le__</code>和<code>__eq__</code>魔术方法的实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, tel</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.tel = tel</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Student(name=<span class="subst">&#123;self.name&#125;</span>, age=<span class="subst">&#123;self.age&#125;</span>, tel=<span class="subst">&#123;self.tel&#125;</span>)&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__lt__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(other, Student):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&quot;Comparison is only implemented for instances of &#x27;Student&#x27;&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.age &lt; other.age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__le__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(other, Student):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&quot;Comparison is only implemented for instances of &#x27;Student&#x27;&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.age &lt;= other.age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(other, Student):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.name == other.name <span class="keyword">and</span> self.age == other.age <span class="keyword">and</span> self.tel == other.tel</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Student对象</span></span><br><span class="line">stu1 = Student(<span class="string">&quot;张三&quot;</span>, <span class="number">31</span>, <span class="string">&quot;1145141919810&quot;</span>)</span><br><span class="line">stu2 = Student(<span class="string">&quot;李四&quot;</span>, <span class="number">30</span>, <span class="string">&quot;1234567890&quot;</span>)</span><br><span class="line">stu3 = Student(<span class="string">&quot;张三&quot;</span>, <span class="number">31</span>, <span class="string">&quot;1145141919810&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用魔术方法</span></span><br><span class="line"><span class="built_in">print</span>(stu1)  <span class="comment"># 调用 __str__</span></span><br><span class="line"><span class="built_in">print</span>(stu1 &lt; stu2)  <span class="comment"># 调用 __lt__</span></span><br><span class="line"><span class="built_in">print</span>(stu1 &lt;= stu2)  <span class="comment"># 调用 __le__</span></span><br><span class="line"><span class="built_in">print</span>(stu1 == stu3)  <span class="comment"># 调用 __eq__</span></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student(name=张三, age=31, tel=1145141919810)</span><br><span class="line">False</span><br><span class="line">False</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>注意，在实现比较魔术方法时，我们通常首先检查比较的对象是否也是相同类的实例。如果不是，我们可能会抛出一个<code>TypeError</code>异常或者简单地返回<code>False</code>（对于<code>__eq__</code>方法）。在实现<code>__lt__</code>和<code>__le__</code>方法时，我们只比较了学生的年龄属性，但根据实际需要，可以比较更多的属性或应用更复杂的逻辑。</p><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>在Python中，继承是面向对象编程的一个重要概念，允许我们创建一个类（称为子类或派生类）来继承另一个类（称为父类或基类）的属性和方法。这样，子类可以重用父类的代码，同时还可以添加或覆盖父类的功能。</p><h2 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h2><p>单继承是指一个子类只继承一个父类的属性和方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, tel</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.tel = tel</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Student类对象, name = <span class="subst">&#123;self.name&#125;</span>, age = <span class="subst">&#123;self.age&#125;</span>, tel = <span class="subst">&#123;self.tel&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__le__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(other, Student):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&quot;Comparison is only implemented for instances of &#x27;Student&#x27;&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.age &lt;= other.age</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dalao</span>(<span class="title class_ inherited__">Student</span>):  <span class="comment"># Dalao类继承自Student类</span></span><br><span class="line">    GPA = <span class="number">5.0</span>  <span class="comment"># Dalao类新增了一个类属性GPA</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个Dalao类的实例</span></span><br><span class="line">d1 = Dalao(<span class="string">&quot;王五&quot;</span>, <span class="number">30</span>, <span class="string">&quot;114514&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(d1.GPA)  <span class="comment"># 输出Dalao类的GPA属性值</span></span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5.0</span><br></pre></td></tr></table></figure></p><h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><p>多继承是指一个子类可以继承多个父类的属性和方法。在Python中，可以通过在类定义时，在括号内列出多个父类来实现多继承。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">method1</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;A method1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">method2</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;B method2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(A, B):  <span class="comment"># C类继承自A类和B类</span></span><br><span class="line">    <span class="keyword">pass</span>  <span class="comment"># C类没有新增属性和方法，直接继承A和B的属性和方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个C类的实例</span></span><br><span class="line">c1 = C()</span><br><span class="line">c1.method1()  <span class="comment"># 调用继承自A类的方法</span></span><br><span class="line">c1.method2()  <span class="comment"># 调用继承自B类的方法</span></span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A method1</span><br><span class="line">B method2</span><br></pre></td></tr></table></figure></p><p>需要注意的是，多继承可能会引起方法解析顺序（MRO）的问题，Python中使用C3线性化算法来确定方法解析顺序。可以使用<code>类名.mro()</code>或<code>类名.__mro__</code>来查看类的MRO列表。</p><h2 id="复写和调用父类成员"><a href="#复写和调用父类成员" class="headerlink" title="复写和调用父类成员"></a>复写和调用父类成员</h2><p>子类可以复写父类的成员属性和成员方法，即重新定义同名的属性或方法。<strong>当子类对象调用成员时，会调用复写后的新成员。</strong>如果需要使用被复写的父类成员，可以使用特殊的调用方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">introduce</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;我是<span class="subst">&#123;self.name&#125;</span>，今年<span class="subst">&#123;self.age&#125;</span>岁。&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraduateStudent</span>(<span class="title class_ inherited__">Student</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, major</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name, age)  <span class="comment"># 调用父类的构造函数初始化name和age属性</span></span><br><span class="line">        self.major = major  <span class="comment"># 新增major属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">introduce</span>(<span class="params">self</span>):  <span class="comment"># 复写父类的introduce方法</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;我是研究生<span class="subst">&#123;self.name&#125;</span>，今年<span class="subst">&#123;self.age&#125;</span>岁，我的专业是<span class="subst">&#123;self.major&#125;</span>。&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个GraduateStudent类的实例并调用introduce方法</span></span><br><span class="line">gs = GraduateStudent(<span class="string">&quot;张三&quot;</span>, <span class="number">25</span>, <span class="string">&quot;计算机科学&quot;</span>)</span><br><span class="line">gs.introduce()  <span class="comment"># 调用复写后的新方法输出信息包含专业</span></span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我是研究生张三，今年25岁，我的专业是计算机科学。</span><br></pre></td></tr></table></figure></p><p>在上面的例子中，<code>GraduateStudent</code>类复写了<code>Student</code>类的<code>introduce</code>方法，并在其中添加了专业信息。同时，在<code>GraduateStudent</code>类的构造函数中，我们使用<code>super().__init__(name, age)</code>来调用父类的构造函数初始化继承的属性。这样，我们就可以在子类中添加新的属性或方法，同时保留父类的功能。</p><h3 id="访问父类成员"><a href="#访问父类成员" class="headerlink" title="访问父类成员"></a>访问父类成员</h3><h4 id="直接通过父类名调用"><a href="#直接通过父类名调用" class="headerlink" title="直接通过父类名调用"></a>直接通过父类名调用</h4><p>如果要直接通过父类名来调用其成员方法或访问成员变量，可以使用以下语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父类名.成员方法(self, 其他参数)</span><br><span class="line">父类名.成员变量</span><br></pre></td></tr></table></figure><p>这里需要注意的是，当直接调用父类的成员方法时，需要显式地将当前对象作为第一个参数传递（通常是<code>self</code>）。</p><blockquote><p>可以对实例化后的对象是用</p></blockquote><h4 id="使用super-调用"><a href="#使用super-调用" class="headerlink" title="使用super()调用"></a>使用<code>super()</code>调用</h4><p><code>super()</code>函数提供了一种动态的方式来访问父类的方法或属性，而不需要显式地引用父类的名字。这在多重继承的场景中特别有用，因为它可以确保正确地调用方法解析顺序（MRO）中的下一个类。</p><p>使用<code>super()</code>调用父类成员的语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">super</span>().成员方法(其他参数)</span><br><span class="line"><span class="built_in">super</span>().成员变量</span><br></pre></td></tr></table></figure><p>注意，在使用<code>super()</code>时，不需要显式地传递<code>self</code>参数，因为<code>super()</code>会自动处理。</p><blockquote><p>在类定义的时候才可以使用</p></blockquote><h1 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h1><p>多态是面向对象编程的三大特性之一，它允许我们使用父类引用来指向子类对象，并且可以调用在子类中重写的方法。<strong>在Python中，多态的实现主要依赖于鸭子类型（duck typing）的概念，即不关注对象的实际类型</strong>，而是关注对象是否具有所需的方法。</p><p>下面我们通过一段代码来演示多态的概念：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:  <span class="comment"># 定义一个Animal类作为父类</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span>  <span class="comment"># 父类中的speak方法为空实现</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):  <span class="comment"># Dog类继承自Animal类</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;汪汪汪&quot;</span>)  <span class="comment"># Dog类中重写speak方法，输出“汪汪汪”</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):  <span class="comment"># Cat类继承自Animal类</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;喵喵喵&quot;</span>)  <span class="comment"># Cat类中重写speak方法，输出“喵喵喵”</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Robot</span>:  <span class="comment"># 定义一个Robot类，它没有继承自Animal类</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;滋滋滋&quot;</span>)  <span class="comment"># Robot类中有一个speak方法，输出“滋滋滋”</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_noise</span>(<span class="params">obj</span>):  <span class="comment"># 定义一个函数，接受一个对象作为参数</span></span><br><span class="line">    obj.speak()  <span class="comment"># 调用对象的speak方法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建对象并调用make_noise函数</span></span><br><span class="line">a = Animal()  <span class="comment"># 创建Animal对象，但注意Animal类的speak方法为空实现，调用时不会有输出</span></span><br><span class="line">b = Dog()  <span class="comment"># 创建Dog对象</span></span><br><span class="line">c = Cat()  <span class="comment"># 创建Cat对象</span></span><br><span class="line">d = Robot()  <span class="comment"># 创建Robot对象，虽然它没有继承自Animal类，但它有一个speak方法，所以可以在make_noise函数中使用</span></span><br><span class="line"></span><br><span class="line">make_noise(b)  <span class="comment"># 输出“汪汪汪”</span></span><br><span class="line">make_noise(c)  <span class="comment"># 输出“喵喵喵”</span></span><br><span class="line"><span class="comment"># make_noise(a)  # 这行代码如果取消注释会运行但没有输出，因为Animal类的speak方法为空实现</span></span><br><span class="line">make_noise(d)  <span class="comment"># 输出“滋滋滋”，虽然Robot类没有继承自Animal类，但由于它有一个speak方法，所以可以在make_noise函数中使用，这体现了鸭子类型的思想</span></span><br></pre></td></tr></table></figure><p>注意：在上述代码中，我们实际上并没有使用到<code>a = Animal()</code>这个对象，因为<code>Animal</code>类的<code>speak</code>方法是一个空实现。如果我们尝试调用<code>make_noise(a)</code>，它不会产生任何输出。在实际的多态示例中，我们通常会避免创建这样的空实现的父类对象。此外，虽然<code>Robot</code>类没有继承自<code>Animal</code>类，但由于它有一个与<code>Animal</code>类中同名的<code>speak</code>方法，我们仍然可以将其对象传递给<code>make_noise</code>函数并调用其<code>speak</code>方法。<strong>这就是鸭子类型的核心思想：不关注对象的实际类型，只关注对象是否具有所需的方法。</strong>然而，在严格的面向对象设计中，为了让代码更加清晰和可维护，我们通常会建议将具有相同行为（即具有相同方法）的类组织到一个继承体系中，并通过父类引用来操作子类对象。这样可以确保我们的代码更加符合面向对象的设计原则。在上述示例中，我们可以将<code>Robot</code>类也设计为继承自<code>Animal</code>类（如果逻辑上合理的话），这样就可以更加清晰地展示多态的特性。但是需要注意的是，并不是所有的具有相同方法的类都应该被组织到一个继承体系中。在实际开发中，我们需要根据具体的业务逻辑和设计需求来决定如何组织我们的类和对象。另外需要注意的是，Python中的多态与一些其他语言（如Java）中的多态略有不同。在Python中，由于动态类型和鸭子类型的特性，我们可以在不显式地声明接口或继承体系的情况下实现多态。这使得Python的代码更加灵活和简洁。但是在享受这种灵活性的同时，我们也需要注意保持代码的清晰性和可维护性。</p><h1 id="变量的类型注解"><a href="#变量的类型注解" class="headerlink" title="变量的类型注解"></a>变量的类型注解</h1><p>在Python 3.5及以后的版本中，引入了类型注解（Type Annotations）的功能。类型注解允许开发者在代码中显式地标注变量、函数参数以及返回值的数据类型。这些注解主要用于帮助开发者编写更加清晰、易于理解的代码，并且为静态类型检查工具、集成开发环境（IDE）等第三方工具提供更好的支持。</p><h2 id="类型注解的作用"><a href="#类型注解的作用" class="headerlink" title="类型注解的作用"></a>类型注解的作用</h2><ol><li><strong>代码提示</strong>：类型注解可以帮助IDE等开发工具提供更为准确的代码提示和自动补全功能。</li><li><strong>静态类型检查</strong>：配合静态类型检查工具，可以在代码运行前发现潜在的类型错误。</li><li><strong>文档化</strong>：类型注解也可以作为一种文档形式，帮助其他开发者理解代码中的数据类型。</li></ol><h2 id="变量的类型注解-1"><a href="#变量的类型注解-1" class="headerlink" title="变量的类型注解"></a>变量的类型注解</h2><p>变量的类型注解是在变量名后面加上冒号（<code>:</code>）和类型名。需<strong>要注意的是，类型注解仅仅是注释，它不会改变Python的动态类型特性。</strong>也就是说，即使你标注了一个变量为整数类型，Python仍然允许你为这个变量赋值为其他类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 变量类型注解示例</span></span><br><span class="line">my_var: <span class="built_in">int</span> = <span class="number">42</span>  <span class="comment"># 标注my_var为整数类型</span></span><br></pre></td></tr></table></figure><p>然而，以下代码虽然类型注解为<code>int</code>，但实际上赋值为字符串类型，Python不会报错，但在静态类型检查时会警告类型不匹配：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var: <span class="built_in">int</span> = <span class="string">&quot;itheima&quot;</span>  <span class="comment"># 类型注解为int，但实际赋值为str，这不会引发运行时错误</span></span><br><span class="line"><span class="built_in">print</span>(var)  <span class="comment"># 输出：itheima</span></span><br></pre></td></tr></table></figure><h2 id="函数的类型注解"><a href="#函数的类型注解" class="headerlink" title="函数的类型注解"></a>函数的类型注解</h2><p>函数的类型注解包括函数参数的类型注解和返回值类型的注解。参数的类型注解写在参数名后面，返回值类型的注解写在函数声明后面的箭头（<code>-&gt;</code>）后面。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 函数类型注解示例</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">name: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;Hello, <span class="subst">&#123;name&#125;</span>!&quot;</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>greet</code>函数的参数<code>name</code>被注解为字符串类型，返回值也被注解为字符串类型。</p><h2 id="Union用法"><a href="#Union用法" class="headerlink" title="Union用法"></a>Union用法</h2><p>当变量或函数参数可以是多种类型之一时，可以使用<code>Union</code>来指定这些类型。<code>Union</code>是从<code>typing</code>模块中导入的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Union</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Union用法示例：变量可以是str或int类型  </span></span><br><span class="line">my_var: <span class="type">Union</span>[<span class="built_in">str</span>, <span class="built_in">int</span>] = <span class="string">&quot;Hello&quot;</span>  <span class="comment"># my_var可以是str类型  </span></span><br><span class="line">my_var = <span class="number">42</span>  <span class="comment"># my_var也可以是int类型，这不会引发运行时错误  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># Union用法示例：列表中的元素可以是str或int类型  </span></span><br><span class="line">my_list: <span class="built_in">list</span>[<span class="type">Union</span>[<span class="built_in">str</span>, <span class="built_in">int</span>]] = [<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;itheima&quot;</span>, <span class="string">&quot;itcast&quot;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>my_var</code>被注解为可以是字符串或整数类型，而<code>my_list</code>被注解为一个列表，其中的元素可以是字符串或整数类型。这样，在静态类型检查时，如果这些变量被赋予了不符合注解类型的值，工具就会发出警告。然而，在运行时，Python本身不会因为这些类型注解而引发错误。</p>]]></content>
      
      
      <categories>
          
          <category> 重生之我是程序员 </category>
          
          <category> Python笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Pytorch笔记</title>
      <link href="/post/969045566.html"/>
      <url>/post/969045566.html</url>
      
        <content type="html"><![CDATA[<h1 id="调用帮助文档"><a href="#调用帮助文档" class="headerlink" title="调用帮助文档"></a>调用帮助文档</h1><p>在Python中，<code>help()</code>和<code>dir()</code>是两个内置函数，它们提供了对Python对象（如模块、类、方法、函数、变量等）的有用信息。</p><ul><li><p><code>help()</code>函数用于获取有关Python对象的信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span>(<span class="built_in">print</span>) <span class="comment">#这将显示有关print()函数的详细信息，包括它的用途、参数、返回值等。</span></span><br></pre></td></tr></table></figure></li><li><p><code>dir()</code>函数用于列出Python对象的所有属性和方法。</p><p>获取内置<code>math</code>模块的所有属性和方法：</p></li></ul>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(math))</span><br></pre></td></tr></table></figure><p>  这将显示<code>math</code>模块中定义的所有函数、变量和常量的名称。</p><p>  也可以在不传递任何参数的情况下调用<code>dir()</code>函数，这将返回一个包含当前作用域中所有名称的列表。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>())</span><br></pre></td></tr></table></figure><h1 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h1><h2 id="必要的库"><a href="#必要的库" class="headerlink" title="必要的库"></a>必要的库</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> os</span><br></pre></td></tr></table></figure><h2 id="读取和显示图像"><a href="#读取和显示图像" class="headerlink" title="读取和显示图像"></a>读取和显示图像</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img = Image.<span class="built_in">open</span>(img_path)  <span class="comment"># 打开图像文件</span></span><br><span class="line">img.show()  <span class="comment"># 显示图像文件（注意：这可能会打开多个图像查看器窗口）</span></span><br></pre></td></tr></table></figure><p>用<code>PIL</code>中的<code>Image</code>可以通过图像路径来打开某个图像并显示图像文件。</p><h2 id="处理图像"><a href="#处理图像" class="headerlink" title="处理图像"></a>处理图像</h2><h3 id="将PIL图像转换为numpy数组"><a href="#将PIL图像转换为numpy数组" class="headerlink" title="将PIL图像转换为numpy数组"></a>将PIL图像转换为numpy数组</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image_path = <span class="string">&quot;data/train/ants_image/0013035.jpg&quot;</span>  </span><br><span class="line">img_PIL = Image.<span class="built_in">open</span>(image_path)  </span><br><span class="line">img_array = np.array(img_PIL)</span><br></pre></td></tr></table></figure><h1 id="TensorBoard可视化"><a href="#TensorBoard可视化" class="headerlink" title="TensorBoard可视化"></a>TensorBoard可视化</h1><p>使用PyTorch进行深度学习实验时，我们经常需要跟踪和可视化训练过程中的各种指标，如损失、准确率等。TensorBoard是一个强大的可视化工具，可以帮助我们实现这一目标。在PyTorch中，我们可以通过<code>SummaryWriter</code>类轻松地将数据写入TensorBoard可以读取的日志文件。</p><blockquote><p>其就相当于一个日志</p></blockquote><h2 id="创建并启动TensorBoard"><a href="#创建并启动TensorBoard" class="headerlink" title="创建并启动TensorBoard"></a>创建并启动TensorBoard</h2><ol><li><p>从<code>torch.utils.tensorboard</code>导入<code>SummaryWriter</code>。</p></li><li><p>创建一个<code>SummaryWriter</code>对象，并指定一个日志目录，例如”logs”。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>启动TensorBoard：</p><p>要在命令行中启动TensorBoard并加载我们的日志，请使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensorboard --logdir=logs</span><br></pre></td></tr></table></figure><p>这将在本地启动一个TensorBoard服务器，并在默认浏览器中打开TensorBoard的Web界面。</p></li></ol><h2 id="写入日志文件"><a href="#写入日志文件" class="headerlink" title="写入日志文件"></a>写入日志文件</h2><h3 id="添加标量数据"><a href="#添加标量数据" class="headerlink" title="添加标量数据"></a>添加标量数据</h3><p>可以使用<code>add_scalar</code>方法将标量数据写入日志文件。这个方法接受三个参数：标签（用于在TensorBoard中标识数据），标量值，以及全局步骤值（通常用于表示训练的迭代次数或时间步）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    writer.add_scalar(<span class="string">&quot;y=x&quot;</span>, i, i)  </span><br><span class="line"></span><br><span class="line">writer.close()  <span class="comment"># 记得关闭</span></span><br></pre></td></tr></table></figure><h3 id="添加图像"><a href="#添加图像" class="headerlink" title="添加图像"></a>添加图像</h3><p>使用<code>SummaryWriter</code>的<code>add_image</code>方法将图像添加到TensorBoard中。需要注意的是，<code>add_image</code>方法要求图像数据的格式与指定的<code>dataformats</code>参数相匹配。在这里，我们指定为<code>&#39;HWC&#39;</code>，即高度、宽度和通道数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)  </span><br><span class="line">writer.add_image(<span class="string">&quot;test&quot;</span>, img_array, global_step=<span class="number">0</span>, dataformats=<span class="string">&#x27;HWC&#x27;</span>)<span class="comment">#默认是&#x27;CHW&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="Pytorch基础"><a href="#Pytorch基础" class="headerlink" title="Pytorch基础"></a>Pytorch基础</h1><h2 id="张量-Tensors"><a href="#张量-Tensors" class="headerlink" title="张量(Tensors)"></a>张量(Tensors)</h2><h3 id="创建Tensors变量"><a href="#创建Tensors变量" class="headerlink" title="创建Tensors变量"></a>创建Tensors变量</h3><p>有多种创建Tensors变量的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建未初始化的矩阵</span></span><br><span class="line">x = torch.empty(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">#随机初始化一个矩阵</span></span><br><span class="line">rand_x = torch.rand(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">#创建数值皆为 0 的矩阵（类型为 long 的矩阵）</span></span><br><span class="line">zero_x = torch.zeros(<span class="number">5</span>, <span class="number">3</span>, dtype=torch.long)</span><br><span class="line"><span class="comment">#创建数值都是 1 的矩阵</span></span><br><span class="line">one_x = torch.ones(<span class="number">5</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment">#直接传递 tensor 数值来创建</span></span><br><span class="line">tensor = torch.tensor([<span class="number">5.5</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure><p>还可以用<code>tensor.new_ones()</code>和<code>torch.randn_like()</code>从一个<code>tensor</code>变量创建另一个<code>tensor</code>变量。</p><h3 id="处理Tensors变量"><a href="#处理Tensors变量" class="headerlink" title="处理Tensors变量"></a>处理Tensors变量</h3><h4 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h4><p>加法有几种实现方式：</p><ul><li><code>+</code> 运算符</li><li><code>torch.add(tensor1, tensor2, [out=tensor3])</code></li><li><code>tensor1.add_(tensor2)</code>：直接修改 tensor 变量</li></ul><blockquote><p>可以改变 tensor 变量的操作都带有一个后缀 <code>_</code>, 例如 <code>x.copy_(y), x.t_()</code> 都可以改变 x 变量</p></blockquote><h4 id="访问tensor数据"><a href="#访问tensor数据" class="headerlink" title="访问tensor数据"></a>访问tensor数据</h4><p>可以使用索引来访问某一维的数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 访问 tensor 第一列数据</span></span><br><span class="line"><span class="built_in">print</span>(tensor[:, <span class="number">0</span>])</span><br></pre></td></tr></table></figure><h4 id="修改维度"><a href="#修改维度" class="headerlink" title="修改维度"></a>修改维度</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#对 Tensor 的尺寸修改，可以采用 torch.view()</span></span><br><span class="line">x = torch.randn(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line">y = x.view(<span class="number">16</span>)</span><br><span class="line"><span class="comment"># -1 表示除给定维度外的其余维度的乘积</span></span><br><span class="line">z = x.view(-<span class="number">1</span>, <span class="number">8</span>)</span><br><span class="line"><span class="built_in">print</span>(x.size(), y.size(), z.size())</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.Size([<span class="number">4</span>, <span class="number">4</span>]) torch.Size([<span class="number">16</span>]) torch.Size([<span class="number">2</span>, <span class="number">8</span>])</span><br></pre></td></tr></table></figure><h3 id="转换为其他数据类型"><a href="#转换为其他数据类型" class="headerlink" title="转换为其他数据类型"></a>转换为其他数据类型</h3><h4 id="转换为Numpy数组"><a href="#转换为Numpy数组" class="headerlink" title="转换为Numpy数组"></a>转换为Numpy数组</h4><p>调用 <code>tensor.numpy()</code> 可以实现这个转换操作。<strong>两者是共享同个内存空间的</strong>,修改 <code>tensor</code> 变量 <code>a</code>，Numpy 数组变量 <code>b</code>也会发生变化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = torch.ones(<span class="number">5</span>)</span><br><span class="line">b = a.numpy()</span><br></pre></td></tr></table></figure><h4 id="Numpy-数组转换为-Tensor"><a href="#Numpy-数组转换为-Tensor" class="headerlink" title="Numpy 数组转换为 Tensor"></a>Numpy 数组转换为 Tensor</h4><p>转换的操作是调用 <code>torch.from_numpy(numpy_array)</code> 方法.\</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.ones(<span class="number">5</span>)</span><br><span class="line">b = torch.from_numpy(a)</span><br></pre></td></tr></table></figure><h2 id="定义自定义数据集类"><a href="#定义自定义数据集类" class="headerlink" title="定义自定义数据集类"></a>定义自定义数据集类</h2><h3 id="创建自定义数据集类"><a href="#创建自定义数据集类" class="headerlink" title="创建自定义数据集类"></a>创建自定义数据集类</h3><p>要创建一个自定义的数据集类，我们首先需要导入必要的库，并继承<code>Dataset</code>类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyData</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, root_dir, label_dir</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        初始化函数，接收根目录和标签目录作为参数。</span></span><br><span class="line"><span class="string">        :param root_dir: 根目录路径，包含所有标签的文件夹。</span></span><br><span class="line"><span class="string">        :param label_dir: 标签目录名称，即根目录下的子文件夹名，代表某一类别。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.root_dir = root_dir</span><br><span class="line">        self.label_dir = label_dir</span><br><span class="line">        <span class="comment"># 拼接得到完整的目录路径</span></span><br><span class="line">        self.path = os.path.join(self.root_dir, self.label_dir)</span><br><span class="line">        <span class="comment"># 列出目录中的所有文件，注意这里没有进行文件类型过滤</span></span><br><span class="line">        self.img_path_list = os.listdir(self.path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        根据索引获取单个样本（图像和标签）。</span></span><br><span class="line"><span class="string">        :param idx: 样本索引。</span></span><br><span class="line"><span class="string">        :return: 返回图像和标签。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 获取图像文件名</span></span><br><span class="line">        img_name = self.img_path_list[idx]</span><br><span class="line">        <span class="comment"># 拼接得到完整的图像文件路径</span></span><br><span class="line">        img_item_path = os.path.join(self.root_dir, self.label_dir, img_name)</span><br><span class="line">        <span class="comment"># 使用PIL库打开图像文件</span></span><br><span class="line">        img = Image.<span class="built_in">open</span>(img_item_path)</span><br><span class="line">        <span class="comment"># 这里简单地将标签设置为标签目录的名称</span></span><br><span class="line">        <span class="comment"># 在实际应用中，标签可能需要更复杂的处理，比如转换为数字、one-hot编码等</span></span><br><span class="line">        label = self.label_dir</span><br><span class="line">        <span class="keyword">return</span> img, label</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        返回数据集中的样本数量（图像数量）。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.img_path_list)</span><br></pre></td></tr></table></figure><h3 id="使用自定义数据集类"><a href="#使用自定义数据集类" class="headerlink" title="使用自定义数据集类"></a>使用自定义数据集类</h3><p>创建了自定义的数据集类之后，就可以将其传递给PyTorch的数据加载器（<code>DataLoader</code>）来使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实例化自定义数据集类</span></span><br><span class="line">dataset = MyData(root_dir=<span class="string">&quot;path/to/root&quot;</span>, label_dir=<span class="string">&quot;label_a&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用DataLoader加载数据集（这里仅为示例，实际使用时需要设置batch_size等参数）</span></span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"></span><br><span class="line">dataloader = DataLoader(dataset, batch_size=<span class="number">4</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在训练循环中迭代dataloader获取数据和标签</span></span><br><span class="line"><span class="keyword">for</span> images, labels <span class="keyword">in</span> dataloader:</span><br><span class="line">    <span class="comment"># 训练代码...</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h2 id="DataLoader的使用"><a href="#DataLoader的使用" class="headerlink" title="DataLoader的使用"></a>DataLoader的使用</h2><p>需要导入必要的库。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br></pre></td></tr></table></figure><p>加载数据集：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test_loader = DataLoader(dataset=test_data, batch_size=<span class="number">64</span>, shuffle=<span class="literal">True</span>, num_workers=<span class="number">0</span>, drop_last=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><ol><li><p>dataset：</p><ul><li><strong>参数类型</strong>: <code>Dataset</code></li><li><strong>作用</strong>: 指定<code>DataLoader</code>需要加载的数据集。数据集必须实现<code>Dataset</code>接口，这样才能被<code>DataLoader</code>识别和加载。</li></ul></li><li><p>batch_size</p><ul><li><p><strong>参数类型</strong>: <code>int</code></p></li><li><p><strong>默认值</strong>: <code>1</code></p></li><li><p><strong>作用</strong>: 指定每个批次的样本数量。批次大小会影响到模型的收敛速度和更新频率。</p></li></ul></li><li><p>shuffle</p><ul><li><p><strong>参数类型</strong>: <code>bool</code></p></li><li><p><strong>默认值</strong>: <code>False</code></p></li><li><p><strong>作用</strong>: 如果设置为<code>True</code>，则每个epoch开始时，<code>DataLoader</code>会随机打乱数据集中的样本顺序。</p></li></ul></li><li><p>num_workers</p><ul><li><p><strong>参数类型</strong>: <code>int</code></p></li><li><p><strong>默认值</strong>: <code>0</code></p></li><li><p><strong>作用</strong>: 指定有多少个子进程用于加载数据。<code>0</code>表示数据将在主进程中加载（不使用子进程）。增加<code>num_workers</code>可以提高数据加载的效率，特别是在数据预处理较为复杂或者数据存储在慢速存储介质上时。</p></li></ul></li><li><p>drop_last</p><ul><li><strong>参数类型</strong>: <code>bool</code></li><li><strong>默认值</strong>: <code>False</code></li><li><strong>作用</strong>: 当样本数量不能被批次大小整除时，如果<code>drop_last</code>设置为<code>True</code>，则<code>DataLoader</code>会丢弃最后一个不完整的批次。</li></ul></li></ol><h2 id="Torchvision-Transforms"><a href="#Torchvision-Transforms" class="headerlink" title="Torchvision Transforms"></a>Torchvision Transforms</h2><h3 id="导入必要的库"><a href="#导入必要的库" class="headerlink" title="导入必要的库"></a>导入必要的库</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br></pre></td></tr></table></figure><h3 id="常用的Transforms操作"><a href="#常用的Transforms操作" class="headerlink" title="常用的Transforms操作"></a>常用的Transforms操作</h3><h4 id="PIL图像转换为Tensor"><a href="#PIL图像转换为Tensor" class="headerlink" title="PIL图像转换为Tensor"></a>PIL图像转换为Tensor</h4><p><code>torchvision.transforms</code>库中的<code>ToTensor()</code>函数可以将PIL图像或NumPy ndarray转换为FloatTensor，并且<strong>会将图像的像素值范围从0-255缩放到0-1</strong>。这对于神经网络来说是一个常见的预处理步骤。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tensor_trans = transforms.ToTensor()</span><br><span class="line">tensor_img = tensor_trans(img)</span><br></pre></td></tr></table></figure><p>使用<code>SummaryWriter</code>的<code>add_image()</code>方法将Tensor图像添加到TensorBoard中。这样，我们就可以在TensorBoard中查看和处理这个图像了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">writer.add_image(<span class="string">&quot;Tensor_img&quot;</span>, tensor_img)</span><br></pre></td></tr></table></figure><h4 id="归一化操作"><a href="#归一化操作" class="headerlink" title="归一化操作"></a>归一化操作</h4><p>下面是一个示例代码，展示了如何使用PyTorch的transforms模块进行图像归一化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Totensor</span></span><br><span class="line">trans_totensor = transforms.ToTensor()</span><br><span class="line">img_tensor = trans_totensor(img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Normalize - 注意这里的参数可能不适用于所有图像，应根据实际情况进行调整</span></span><br><span class="line">trans_norm = transforms.Normalize([<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>], [<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>])  <span class="comment"># 假设图像范围为[0, 1]，则均值和标准差都设为0.5进行归一化</span></span><br><span class="line">img_norm = trans_norm(img_tensor)</span><br></pre></td></tr></table></figure><h4 id="图像调整大小"><a href="#图像调整大小" class="headerlink" title="图像调整大小"></a>图像调整大小</h4><p>在调整大小之前，可以通过 <code>img.size</code> 属性获取原始图像的大小。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(img.size)  <span class="comment"># 输出原始图像的宽度和高度，例如：(width, height)</span></span><br></pre></td></tr></table></figure><p>创建一个 <code>transforms.Resize</code> 对象，指定新的图像大小。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trans_resize = transforms.Resize((<span class="number">512</span>, <span class="number">512</span>))  <span class="comment"># 调整图像到 512x512 像素大小</span></span><br></pre></td></tr></table></figure><p>使用创建的 <code>trans_resize</code> 转换器来调整图像大小。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img_resize = trans_resize(img)  <span class="comment"># img_resize 是调整大小后的 PIL 图像</span></span><br></pre></td></tr></table></figure><h3 id="使用Compose组合多个操作"><a href="#使用Compose组合多个操作" class="headerlink" title="使用Compose组合多个操作"></a>使用Compose组合多个操作</h3><p>在实际应用中，我们通常需要按顺序执行多个图像预处理操作。这时，可以使用<code>transforms.Compose</code>来组合这些操作，从而创建一个可重复使用的预处理流程。以下是一个示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;test04&quot;</span>)</span><br><span class="line">img = Image.<span class="built_in">open</span>(<span class="string">&quot;image.jpg&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义预处理流程：先调整大小，然后转换为张量，并进行归一化（这里省略了归一化步骤以简化示例）</span></span><br><span class="line">preprocessing = transforms.Compose([</span><br><span class="line">    transforms.Resize([<span class="number">300</span>, <span class="number">500</span>]),  <span class="comment"># 调整图像大小（注意保持纵横比或适当填充以避免失真）</span></span><br><span class="line">    transforms.ToTensor(),  <span class="comment"># 将PIL图像转换为PyTorch张量（值范围在[0, 255]内）</span></span><br><span class="line">    <span class="comment"># 添加归一化等其他操作（如果需要的话）...</span></span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用预处理流程并保存结果到TensorBoard日志中（实际应用中可能需要进一步处理或添加标签等）</span></span><br><span class="line">img_preprocessed = preprocessing(img)</span><br><span class="line">writer.add_image(<span class="string">&quot;Preprocessed Image&quot;</span>, img_preprocessed, <span class="number">0</span>)  <span class="comment"># 使用全局步数0，实际应用中应根据需要动态设置（例如训练迭代次数等）</span></span><br></pre></td></tr></table></figure><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>Pytorch中也提供了许多的损失函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># L1损失函数</span></span><br><span class="line">loss = L1Loss(reduction=<span class="string">&#x27;sum&#x27;</span>)  </span><br><span class="line">result = loss(inputs, targets)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># MSE损失函数</span></span><br><span class="line">loss_mse = nn.MSELoss()  </span><br><span class="line">result_mse = loss_mse(inputs, targets)  </span><br></pre></td></tr></table></figure><h2 id="计算正确率"><a href="#计算正确率" class="headerlink" title="计算正确率"></a>计算正确率</h2><p><code>output=model(input)</code>得到的是浮点数矩阵，如果想要知道类别，则可以用<code>.argmax()</code>函数得到输出的类别，然后用<code>predict==targets</code>得到布尔矩阵。最后对矩阵<code>torch.sum()</code>得到正确个数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch  </span><br><span class="line">outputs = torch.tensor([[<span class="number">0.1</span>, <span class="number">0.2</span>], [<span class="number">0.3</span>, <span class="number">0.4</span>]])  </span><br><span class="line"><span class="comment">#.argmax(1)是对每一行求最大值的位置，.argmax(0)是对每一列</span></span><br><span class="line"><span class="built_in">print</span>(outputs.argmax(<span class="number">1</span>))  </span><br><span class="line">preds = outputs.argmax(<span class="number">1</span>)  </span><br><span class="line">targets = torch.tensor([<span class="number">0</span>, <span class="number">1</span>])  </span><br><span class="line"><span class="built_in">print</span>(preds == targets)  </span><br></pre></td></tr></table></figure><h1 id="PyTorch卷积"><a href="#PyTorch卷积" class="headerlink" title="PyTorch卷积"></a>PyTorch卷积</h1><h2 id="PyTorch中torch-nn模块的使用"><a href="#PyTorch中torch-nn模块的使用" class="headerlink" title="PyTorch中torch.nn模块的使用"></a>PyTorch中torch.nn模块的使用</h2><p>在PyTorch中，<code>torch.nn</code>模块提供了构建神经网络所需的所有构建块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br></pre></td></tr></table></figure><p>接下来，我们定义一个模型类<code>Model</code>，它继承自<code>nn.Module</code>。在构造函数<code>__init__</code>中，我们初始化两个卷积层<code>conv1</code>和<code>conv2</code>。<code>nn.Conv2d</code>是二维卷积层，它接收的参数包括输入和输出通道数、卷积核大小等。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Model, self).__init__() <span class="comment"># 记得初始化父类</span></span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">1</span>, <span class="number">20</span>, <span class="number">5</span>)  <span class="comment"># 输入通道1，输出通道20，卷积核大小5</span></span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">20</span>, <span class="number">20</span>, <span class="number">5</span>) <span class="comment"># 输入通道20，输出通道20，卷积核大小5</span></span><br></pre></td></tr></table></figure><br>在<code>forward</code>方法中，我们定义了数据通过网络的方式。这里使用了<code>F.relu</code>作为激活函数，对每个卷积层的输出应用ReLU激活。 </p><blockquote><p>其它的一些层可以在<a href="https://pytorch.org/docs/stable/nn.functional.html">官方文档</a>中找到</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">    x = F.relu(self.conv1(x))  <span class="comment"># 第一个卷积层后接ReLU激活</span></span><br><span class="line">    <span class="keyword">return</span> F.relu(self.conv2(x))  <span class="comment"># 第二个卷积层后接ReLU激活</span></span><br></pre></td></tr></table></figure><p>这样，我们就定义了一个简单的卷积神经网络模型。在实际使用时，我们会创建这个模型类的实例，然后传入数据来进行训练和测试。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建模型实例</span></span><br><span class="line">model = Model()</span><br><span class="line"><span class="comment"># 假设我们有一些输入数据x（例如，图像数据），形状为(N, 1, 28, 28)</span></span><br><span class="line"><span class="comment"># N是批量大小，1是通道数，28x28是图像尺寸</span></span><br><span class="line">x = torch.randn(<span class="number">64</span>, <span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>)  <span class="comment"># 随机生成一些输入数据</span></span><br><span class="line"><span class="comment"># 通过模型前向传播数据</span></span><br><span class="line">output = model(x)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="built_in">print</span>(output)</span><br></pre></td></tr></table></figure><br>以上就是使用<code>torch.nn</code>模块构建和运行一个简单卷积神经网络的基本步骤。在实际应用中，模型通常会包含更多的层和更复杂的结构，但基本原理是相同的。</p><h3 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h3><h4 id="定义优化器"><a href="#定义优化器" class="headerlink" title="定义优化器"></a>定义优化器</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">optimizer = optim.SGD(model.parameters(), lr=<span class="number">0.01</span>, momentum=<span class="number">0.9</span>)  </span><br><span class="line">optimizer = optim.Adam([var1, var2], lr=<span class="number">0.0001</span>)</span><br></pre></td></tr></table></figure><p>主要要定义的有两个：</p><ol><li>模型参数：给定模型参数优化器才知道更新哪些内容</li><li>学习速率<code>lr</code></li></ol><h4 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h4><p>训练过程写法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">input</span>, target <span class="keyword">in</span> dataset:  </span><br><span class="line">    optimizer.zero_grad()  <span class="comment"># 梯度清零</span></span><br><span class="line">    output = model(<span class="built_in">input</span>)  <span class="comment"># 前向传播</span></span><br><span class="line">    loss = loss_fn(output, target)  <span class="comment">#损失</span></span><br><span class="line">    loss.backward()  <span class="comment"># 反向传播</span></span><br><span class="line">    optimizer.step()</span><br></pre></td></tr></table></figure><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><p>与自己的模型综合起来，效果大概是这样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">loss = nn.CrossEntropyLoss()  </span><br><span class="line">model = Model()  </span><br><span class="line">optim = torch.optim.SGD(tudui.parameters(), lr=<span class="number">0.01</span>)  </span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> dataloader:  </span><br><span class="line">    imgs, targets = data  </span><br><span class="line">    outputs = model (imgs)  </span><br><span class="line">    result_loss = loss(outputs, targets)  </span><br><span class="line">    optim.zero_grad()  </span><br><span class="line">    result_loss.backward()  </span><br><span class="line">    optim.step()</span><br></pre></td></tr></table></figure><h3 id="利用Sequential简化模块"><a href="#利用Sequential简化模块" class="headerlink" title="利用Sequential简化模块"></a>利用<code>Sequential</code>简化模块</h3><p><code>Sequential</code>也在<code>torch.nn</code>模块中，利用其，可以避免在前向传播的过程中手写每层的输入输出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Model, self).__init__()</span><br><span class="line">        self.model1 = Sequential(</span><br><span class="line">            Conv2d(<span class="number">3</span>, <span class="number">32</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            Conv2d(<span class="number">32</span>, <span class="number">32</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            Conv2d(<span class="number">32</span>, <span class="number">64</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            Flatten(),</span><br><span class="line">            Linear(<span class="number">1024</span>, <span class="number">64</span>),</span><br><span class="line">            Linear(<span class="number">64</span>, <span class="number">10</span>)</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.model1(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h3 id="可视化模块"><a href="#可视化模块" class="headerlink" title="可视化模块"></a>可视化模块</h3><ol><li>可以用<code>print(Model)</code>将模型显示在控制台</li><li>用<code>SummaryWriter</code>的<code>add_graph(Model,input)</code>在TensorBorad中显示</li></ol><h3 id="保存模型"><a href="#保存模型" class="headerlink" title="保存模型"></a>保存模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"></span><br><span class="line"><span class="comment">#保存</span></span><br><span class="line"><span class="comment">#方式一，保存整个模型</span></span><br><span class="line">torch.save(vgg16, <span class="string">&quot;vgg16_method1.pth&quot;</span>)</span><br><span class="line"><span class="comment">#方式二，只保存参数</span></span><br><span class="line">torch.save(vgg16.state_dict(), <span class="string">&quot;vgg16_method2.pth&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#加载</span></span><br><span class="line"><span class="comment">#方式一对应的加载模式</span></span><br><span class="line">model = torch.load(<span class="string">&quot;vgg16_method1.pth&quot;</span>)</span><br><span class="line"><span class="comment">#方式二对应的加载模式</span></span><br><span class="line">vgg16 = torchvision.models.vgg16(pretrained=<span class="literal">False</span>)</span><br><span class="line">vgg16.load_state_dict(torch.load(<span class="string">&quot;vgg16_method2.pth&quot;</span>))</span><br></pre></td></tr></table></figure><p>加载自身的模型的时候需要给出类的定义。</p><h2 id="PyTorch-2D卷积"><a href="#PyTorch-2D卷积" class="headerlink" title="PyTorch 2D卷积"></a>PyTorch 2D卷积</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br></pre></td></tr></table></figure><h3 id="1-创建输入张量和卷积核"><a href="#1-创建输入张量和卷积核" class="headerlink" title="1. 创建输入张量和卷积核"></a>1. 创建输入张量和卷积核</h3><p>输入张量（<code>input</code>）和卷积核（<code>kernel</code>）被定义为多维张量。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">input</span> = torch.tensor([</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">    [<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">])</span><br><span class="line">kernel = torch.tensor([</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">])</span><br></pre></td></tr></table></figure></p><h3 id="2-调整张量的形状"><a href="#2-调整张量的形状" class="headerlink" title="2. 调整张量的形状"></a>2. 调整张量的形状</h3><p>为了进行二维卷积操作，我们需要将输入张量和卷积核的形状调整为四维张量。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">input</span> = torch.reshape(<span class="built_in">input</span>, (<span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">kernel = torch.reshape(kernel, (<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure><br>在PyTorch中，使用<code>torch.nn.functional.conv2d</code>函数进行卷积操作时，输入和卷积核需要是四维张量。这四个维度分别是：</p><ol><li><strong>批量大小（Batch size）</strong>：表示输入数据的数量。</li><li><strong>通道数（Channels）</strong>：对于彩色图像，通常是3（红、绿、蓝）。</li><li><strong>高度（Height）</strong>：图像的高度。</li><li><strong>宽度（Width）</strong>：图像的宽度。</li></ol><p><code>input = torch.reshape(input, (1, 1, 5, 5))</code>和<code>kernel = torch.reshape(kernel, (1, 1, 3, 3))</code>这两行代码的作用是将输入和卷积核的形状从二维扩展到四维，以满足<code>conv2d</code>函数的要求。</p><h3 id="3-进行卷积操作"><a href="#3-进行卷积操作" class="headerlink" title="3.进行卷积操作"></a>3.进行卷积操作</h3><p>使用<code>F.conv2d</code>函数进行卷积操作，并设置步长（<code>stride</code>）为1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">output = F.conv2d(<span class="built_in">input</span>, kernel, stride=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>在卷积操作中，<code>stride</code>（步幅）是一个非常重要的参数，它定义了卷积核在输入张量上移动时的步长。</p><p>还可以设置<code>padding</code>参数：<code>padding</code>参数定义了在卷积操作之前，输入数据周围是否要添加额外的边界（通常为0）。</p><h2 id="最大池化层"><a href="#最大池化层" class="headerlink" title="最大池化层"></a>最大池化层</h2><p>最大池化与卷积的区别是，卷积是对窗口中的数对应相乘后求和，最大池化是求窗口中的最大值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个最大池化层，池化窗口大小为2x2，步长为2</span></span><br><span class="line">max_pool = nn.MaxPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>其的主要参数为：</p><ol><li><code>kernel_size</code>：表示池化窗口的大小。对于二维最大池化，它可以是单个整数或两个整数的元组（height, width）。如果是一个整数，则池化窗口将是一个正方形。</li><li><code>stride</code>：这是一个元组或整数，表示池化窗口在输入张量上移动的步长。<strong>默认情况下，<code>stride</code>与<code>kernel_size</code>相同。</strong></li><li><code>padding</code>：这是一个元组或整数，表示在输入张量的每个边上添加的填充数量。默认情况下，没有填充（<code>padding=0</code>）。</li></ol><h1 id="完整的训练过程"><a href="#完整的训练过程" class="headerlink" title="完整的训练过程"></a>完整的训练过程</h1><ol><li><p>准备数据集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">train_data = datasets.CIFAR10(root=<span class="string">&quot;/data&quot;</span>, train=<span class="literal">True</span>, transform=transforms.ToTensor(), download=<span class="literal">True</span>)</span><br><span class="line">test_data = datasets.CIFAR10(root=<span class="string">&quot;/data&quot;</span>, train=<span class="literal">False</span>, transform=transforms.ToTensor(), download=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></li><li><p>加载数据集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">train_dataloader = DataLoader(train_data, batch_size=<span class="number">64</span>)</span><br><span class="line">test_dataloader = DataLoader(test_data, batch_size=<span class="number">64</span>)</span><br></pre></td></tr></table></figure></li><li><p>搭建神经网络</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 搭建神经网络   </span></span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span>(nn.Module):     </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_init_</span>(<span class="params">self</span>):      </span><br><span class="line">        <span class="built_in">super</span>(Model, self)._init_()       </span><br><span class="line">        self.model = nn.Sequential(                  </span><br><span class="line">            nn.Conv2d(<span class="number">3</span>, <span class="number">32</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>),           </span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>),               </span><br><span class="line">            nn.Conv2d(<span class="number">32</span>, <span class="number">32</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>),          </span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>),                </span><br><span class="line">            nn.Conv2d(<span class="number">32</span>, <span class="number">64</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>),           </span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>),                </span><br><span class="line">            nn.Flatten(),                </span><br><span class="line">            nn.Linear(<span class="number">64</span>*<span class="number">4</span>*<span class="number">4</span>, <span class="number">64</span>),              </span><br><span class="line">            nn.Linear(<span class="number">64</span>, <span class="number">10</span>))             </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):                  </span><br><span class="line">        x = self.model(x)                  </span><br><span class="line">        <span class="keyword">return</span> x  </span><br></pre></td></tr></table></figure></li><li><p>创建网络模型，定义损失函数及优化器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建网络模型  </span></span><br><span class="line">model = Model()  </span><br><span class="line"><span class="comment">#损失函数  </span></span><br><span class="line">loss_fn = nn.CrossEntropyLoss()  </span><br><span class="line"><span class="comment">#优化器  </span></span><br><span class="line">learning_rate = <span class="number">0.01</span>  </span><br><span class="line">optimizer = torch.optim.SGD(model.parameters(), lr=learning_rate)</span><br></pre></td></tr></table></figure></li><li><p>设置训练网络中的参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置训练网络的一些参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 记录训练的次数</span></span><br><span class="line">total_train_step = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 记录测试的次数</span></span><br><span class="line">total_test_step = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练的轮数</span></span><br><span class="line">epoch = <span class="number">10</span></span><br></pre></td></tr></table></figure></li><li><p>开始训练</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(epoch):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;--------第&#123;&#125;轮训练开始-------&quot;</span>.<span class="built_in">format</span>(i+<span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 训练步骤开始</span></span><br><span class="line">    model.train() <span class="comment"># 如果有Dropout层，调用这个会激活其</span></span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> train_dataloader:</span><br><span class="line">        imgs, targets = data</span><br><span class="line">        outputs = model(imgs)</span><br><span class="line">        loss = loss_fn(outputs, targets)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 优化器优化模型</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        total_train_step = total_train_step + <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;训练次数:&#123;&#125;, Loss:&#123;&quot;</span>.<span class="built_in">format</span>(total_train_step,loss.item()))</span><br></pre></td></tr></table></figure></li><li><p>在测试集上测试模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#测试步骤开始</span></span><br><span class="line">model.<span class="built_in">eval</span>() <span class="comment"># 如果有Dropout层，调用这个会将其失效</span></span><br><span class="line">total_test_loss =<span class="number">0</span>  </span><br><span class="line"><span class="keyword">with</span> torch.no_grad():    </span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> test_dataloader:     </span><br><span class="line">        imgs, targets = data      </span><br><span class="line">        outputs = model(imgs)       </span><br><span class="line">        loss = loss_fn(outputs, targets)           </span><br><span class="line">        total_test_loss = total_test_loss + loss</span><br></pre></td></tr></table></figure></li></ol><h2 id="在GPU上训练"><a href="#在GPU上训练" class="headerlink" title="在GPU上训练"></a>在GPU上训练</h2><p>可以用Python命令<code>!nvidia-smi</code>查看GPU配置。</p><h3 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h3><p>对模型<code>model</code>、训练和测试时的数据<code>imgs,targets</code>、损失函数<code>loss</code>，调用<code>.cuda()</code>，让它们转移到GPU上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> torch.cuda.is_available():  </span><br><span class="line">    model = model.cuda()</span><br></pre></td></tr></table></figure><h3 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h3><p>可以用以下内容代替<code>.cuda()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">device = torch.device(<span class="string">&quot;gpu&quot;</span>)</span><br><span class="line">model = model.to(device)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 重生之我是程序员 </category>
          
          <category> Python笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python与操作系统交互</title>
      <link href="/post/772417664.html"/>
      <url>/post/772417664.html</url>
      
        <content type="html"><![CDATA[<h1 id="Python执行命令行指令"><a href="#Python执行命令行指令" class="headerlink" title="Python执行命令行指令"></a>Python执行命令行指令</h1><h2 id="执行命令行指令"><a href="#执行命令行指令" class="headerlink" title="执行命令行指令"></a>执行命令行指令</h2><p>首先导入<code>subprocess</code>模块，然后通过<code>subprocess.run</code>来执行命令行指令。</p><blockquote><p>指令是在当前运行的脚本的工作目录下执行的</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = subprocess.run(<span class="string">f&#x27;ls&#x27;</span>, shell=<span class="literal">True</span>, stdout=subprocess.PIPE, stderr=subprocess.PIPE,text=<span class="literal">True</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br></pre></td></tr></table></figure><p>函数的参数说明如下：</p><ul><li><code>args</code>：这个参数可以是一个字符串，也可以是一个程序参数列表。如果是字符串，需要加上<code>shell=True</code>参数，以便通过shell来解释这个命令。在这个例子中，<code>args</code>是<code>f&#39;ls&#39;</code>，表示执行<code>ls</code>命令。</li><li><code>shell=True</code>：这个参数指示<code>subprocess.run()</code>使用shell来执行这个命令。</li><li><code>stdout=subprocess.PIPE</code>和<code>stderr=subprocess.PIPE</code>：这两个参数表示子进程的标准输出和标准错误输出将被捕获，并通过<code>CompletedProcess</code>对象的<code>stdout</code>和<code>stderr</code>属性提供。如果这两个参数没有被设置，子进程的标准输出和标准错误输出将直接显示在屏幕（Python控制台）上。</li><li><code>text=True</code>：这个参数表示在<code>stdout</code>和<code>stderr</code>中的输出将以文本形式返回，而不是字节形式。这个参数需要Python 3.7或更高版本支持。</li><li><code>encoding=&#39;utf-8&#39;</code>：这个参数指定了编码方式，用于将字节转换为文本。在这个例子中，使用的是UTF-8编码。</li></ul><p>可以打印出标准输出和标准错误：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(result.stdout)</span><br><span class="line"><span class="built_in">print</span>(result.stderr)</span><br></pre></td></tr></table></figure><h2 id="更改工作目录"><a href="#更改工作目录" class="headerlink" title="更改工作目录"></a>更改工作目录</h2><p>因为<code>subprogress.run</code>是在当前工作目录下执行，所以需要切换工作目录，才能在指定的地方执行命令行指令。</p><p>在Python中，<code>os.chdir()</code> 函数用于改变当前工作目录到指定的路径。这个函数是<code>os</code>模块的一部分。另外可以用<code>os.getcwd()</code>来获取当前的工作目录。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前工作目录</span></span><br><span class="line">current_directory = os.getcwd()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;当前工作目录：&quot;</span>, current_directory)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改变工作目录到 &#x27;/path/to/another/directory&#x27;</span></span><br><span class="line">os.chdir(<span class="string">&#x27;/path/to/another/directory&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次获取当前工作目录</span></span><br><span class="line">current_directory = os.getcwd()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;改变后的工作目录：&quot;</span>, current_directory)</span><br></pre></td></tr></table></figure><h1 id="Python与文件管理"><a href="#Python与文件管理" class="headerlink" title="Python与文件管理"></a>Python与文件管理</h1><h2 id="构建完整路径"><a href="#构建完整路径" class="headerlink" title="构建完整路径"></a>构建完整路径</h2><p><code>os.path.join(root, file)</code>，这个函数用于将两个或多个路径组件合并为一个完整的路径。它智能地处理目录分隔符（如UNIX系统中的<code>/</code>或Windows系统中的<code>\</code>），并确保路径的正确性。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">root = <span class="string">&#x27;/path/to/directory&#x27;</span></span><br><span class="line">file = <span class="string">&#x27;example.txt&#x27;</span></span><br><span class="line">full_path = os.path.join(root, file)</span><br></pre></td></tr></table></figure><h2 id="列出目录下的文件和子目录"><a href="#列出目录下的文件和子目录" class="headerlink" title="列出目录下的文件和子目录"></a>列出目录下的文件和子目录</h2><p><code>os.listdir(path)</code>，这个函数用于列出指定路径下的所有文件和目录（子目录）的名称。它返回一个列表，包含<code>path</code>指定的目录中的所有文件和子目录的名称。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">new_articles_dir = <span class="string">&#x27;/path/to/directory&#x27;</span></span><br><span class="line">files_and_dirs = os.listdir(new_articles_dir)</span><br></pre></td></tr></table></figure><h2 id="检查给定路径是否是文件"><a href="#检查给定路径是否是文件" class="headerlink" title="检查给定路径是否是文件"></a>检查给定路径是否是文件</h2><p><code>os.path.isfile(path)</code>，这个函数用于检查给定的路径是否是一个文件。如果<code>path</code>是一个存在的文件，它返回<code>True</code>；如果<code>path</code>不存在或者是一个目录，它返回<code>False</code>。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">path = <span class="string">&#x27;/path/to/file.txt&#x27;</span></span><br><span class="line"><span class="keyword">if</span> os.path.isfile(path):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;path&#125;</span> 是一个文件&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;path&#125;</span> 不是一个文件&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="删除指定文件"><a href="#删除指定文件" class="headerlink" title="删除指定文件"></a>删除指定文件</h2><p><code>os.remove(file_path)</code>，这个函数用于删除指定的文件。如果<code>file_path</code>是一个文件并且删除成功，函数不会有任何返回值。如果文件不存在或者由于某些原因（如权限问题）无法删除，会抛出一个<code>OSError</code>异常。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">file_path = <span class="string">&#x27;/path/to/file.txt&#x27;</span></span><br><span class="line">os.remove(file_path)</span><br></pre></td></tr></table></figure><h2 id="删除给定文件夹"><a href="#删除给定文件夹" class="headerlink" title="删除给定文件夹"></a>删除给定文件夹</h2><p><code>shutil.rmtree()</code> 函数用于<strong>递归删除目录及其所有子目录和文件</strong>。<code>shutil</code> 是 Python 的一个模块，提供了许多文件操作的高级函数。</p><p><code>shutil.rmtree(path, ignore_errors=False, onerror=None)</code> 函数的参数说明如下：</p><ul><li><code>path</code>：这是一个字符串，表示要删除的目录的路径。</li><li><code>ignore_errors</code>：这是一个布尔值，默认为<code>False</code>。如果设置为<code>True</code>，则在删除过程中忽略发生的错误。</li><li><code>onerror</code>：这是一个函数，用于处理在删除过程中发生的错误。如果指定了这个参数，它应该是一个接受三个参数的函数：(errno, strerror, filename)。在这个函数中，你可以定义错误处理逻辑。</li></ul><p>这是一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要删除的目录路径</span></span><br><span class="line">dir_path = <span class="string">&#x27;/path/to/directory&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归删除目录及其所有子目录和文件</span></span><br><span class="line">shutil.rmtree(dir_path)</span><br></pre></td></tr></table></figure><h2 id="复制给定文件夹"><a href="#复制给定文件夹" class="headerlink" title="复制给定文件夹"></a>复制给定文件夹</h2><p><code>shutil.copytree()</code> 函数用于递归地复制一个目录树从一个位置到另一个位置。</p><p><code>shutil.copytree(src, dst)</code> 中参数说明如下：</p><ul><li><code>src</code>：这是一个字符串，表示源目录的路径，即要复制的目录。</li><li><code>dst</code>：这是一个字符串，表示目标目录的路径，即复制的目录将被放置的地方。<strong>如果目标目录已经存在，<code>shutil.copytree()</code> 将会抛出一个 <code>FileExistsError</code> 异常</strong>。如果目标目录不存在，它将会被创建。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="comment"># 源目录和目标目录的路径</span></span><br><span class="line">source_item = <span class="string">&#x27;/path/to/source_directory&#x27;</span></span><br><span class="line">destination_item = <span class="string">&#x27;/path/to/destination_directory&#x27;</span></span><br><span class="line"><span class="comment"># 递归复制目录树</span></span><br><span class="line">shutil.copytree(source_item, destination_item)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 重生之我是程序员 </category>
          
          <category> Python笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从零开始搭建一个简易神经网络</title>
      <link href="/post/2484359005.html"/>
      <url>/post/2484359005.html</url>
      
        <content type="html"><![CDATA[<h1 id="神经网络简述"><a href="#神经网络简述" class="headerlink" title="神经网络简述"></a>神经网络简述</h1><h2 id="神经元"><a href="#神经元" class="headerlink" title="神经元"></a>神经元</h2><p>神经网络通过模拟人神经元的活动，通过输入预测输出。</p><p><img src="/images/从零开始搭建一个简易神经网络.assets/image-20240424091712887.png" alt="image-20240424091712887"></p><p>神经网络中的一个神经元的树突接触到输入，然后经过计算之后从轴突上传出信号。</p><p>经过抽象之后，一个神经元就长这样：</p><p><img src="/images/从零开始搭建一个简易神经网络.assets/image-20240430201657690.png" alt="image-20240430201657690"></p><p>其接受3个输入，$x_1,x_2,x_3$，经过线性运算$w^Tx+b$，和激活函数$\sigma(z)$后，输出$a$​​。</p><blockquote><p>$w$是一个$3\times1$的列向量，$x$是一个$3\times1$的列向量，$b$是一个实数</p></blockquote><h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><p>多个神经元（cell）一起就组成了神经网络，一个神经网络可以表示为如下这样：</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  %%{ init : { &#39;flowchart&#39; : { &#39;curve&#39; : &#39;basis&#39; }}}%%flowchart LRage((年龄))salary((薪水))age-.-&gt;x1((cell)) &amp; x2((cell)) &amp; x3((cell))salary-.-&gt;x1 &amp; x2 &amp; x3x1 &amp; x2 &amp; x3-.-&gt;x4((cell)) &amp; x5((cell)) &amp; x6((cell)) -.-&gt;output((sigmoid))--&gt;y((结果))  </pre></div><p>其中从左到右第一层称为输入层，第二、三层称为隐藏层，第四层成为输出层。</p><h2 id="神经网络的工作方式"><a href="#神经网络的工作方式" class="headerlink" title="神经网络的工作方式"></a>神经网络的工作方式</h2><p>神经网络的每一层都是由多个神经元组成的，这里取这样的一层神经元：</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  %%{ init : { &#39;flowchart&#39; : { &#39;curve&#39; : &#39;basis&#39; }}}%%flowchart LRage((x1))salary((x2))age-.-&gt;x1((cell)) &amp; x2((cell)) &amp; x3((cell))salary-.-&gt;x1 &amp; x2 &amp; x3x1--&gt;y1((y1))x2--&gt;y2((y2))x3--&gt;y3((y3))  </pre></div><p>那么：</p><ul><li>第一个神经元计算$a_1=w_1^Tx+b_1$与$y_1=\sigma(a_1)$。</li><li>第二个神经元计算$a_2=w_2^Tx+b_2$与$y_2=\sigma(a_2)$</li><li>第三个神经元计算$a_3=w_3^Tx+b_1$与$y_3=\sigma(a_3)$</li></ul><blockquote><p>这里，$w_i$是一个$2\times1$的列向量，$x$是一个$2\times1$的列向量，$b$​是一个实数</p></blockquote><p>因为每个神经元执行的操作类似，所以可以将$w_i$和$b$堆叠起来，以表示输入通过这一层神经元得到的输出。</p><p>我们将所有的 $w^T_i$ 按行堆叠成一个矩阵$W$，其中每一行对应一个神经元的权重向量的转置 $w^T_i$。</p><script type="math/tex; mode=display">W = \left[ \begin{array}{cc}w_1^T \\w_2^T \\w_3^T\end{array} \right]</script><p>将所有的偏置 $b_i$ 按行堆叠成一个列向量，其中每个元素对应一个神经元的偏置 $b_i$。因此，堆叠后的 $b$ 将是一个 $3 \times 1$ 的列向量：</p><script type="math/tex; mode=display">b = \left[ \begin{array}{c}b_1 \\b_2 \\b_3\end{array} \right]</script><p>这里，每个 $b_i$ 是一个实数。</p><p>现在，我们可以用堆叠后的 $W$ 和 $b$ 来表示所有神经元的输出：</p><script type="math/tex; mode=display">Y =\sigma( WX + b)</script><p>其中，$Y$ 是一个 $3 \times 1$ 的列向量，包含了所有神经元的输出；$X$ 是一个 $2 \times 1$ 的列向量，表示输入特征。</p><h2 id="多样本"><a href="#多样本" class="headerlink" title="多样本"></a>多样本</h2><p>到目前为止，神经网络的输入还是单样本，但在实际的问题中，遇到的都是多样本，如果一个个样本输入则太慢了。</p><p>又考虑到每个样本$x_i$在神经网络中所经过的计算是相似的。所以，同样的想法，可以将样本$x_1,x_2,\cdots,x_n$按列的方式堆叠成一个矩阵$X$。</p><script type="math/tex; mode=display">X = \left[\begin{array}{cccc}| & | &  & | \\x^{(1)} & x^{(2)} & \cdots & x^{(n)} \\| & | &  & |\end{array}\right]</script><p>展开来就是：</p><script type="math/tex; mode=display">X = \left[\begin{array}{cccc}x^{(1)}_1 & x^{(2)}_1 & \cdots & x^{(n)}_1 \\x^{(1)}_2 & x^{(2)}_2 & \cdots & x^{(n)}_2 \\\vdots & \vdots & \ddots & \vdots \\x^{(1)}_{m} & x^{(2)}_{m} & \cdots & x^{(n)}_{m}\end{array}\right]</script><blockquote><p>$m$个特征，$n$个样本</p></blockquote><p>而每层的计算方式并没有因为样本的堆叠发生改变，仍然是：</p><script type="math/tex; mode=display">Y =\sigma( WX + b)</script><blockquote><p>这里意思是每一列都加上$b$</p></blockquote><p>只不过矩阵的维度发生了变化：</p><ul><li>$X$维度变为$(m,n)$</li><li>$Y$的维度变为$(m’,n)$​</li></ul><blockquote><p>$W$矩阵的维度是$(m’,m)$​维</p></blockquote><h2 id="更新参数"><a href="#更新参数" class="headerlink" title="更新参数"></a>更新参数</h2><p>刚才所述统都属于前向传播的过程，而到这里还有一个关键的问题没有解决，就是神经网络的参数$W$和$b$​​要怎么更新。如果不更新，神经网络就无法学习样本中的特征。所以就需要引入反向传播算法，用于更新这两个参数。</p><p>而反向传播算法中常用的是梯度下降。</p><h3 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h3><p>考虑一个函数$z=f(x,y)$，在高数中学过，其在$x_0,y_0$增长最快的方向就是函数$f(x,y)$在这一点的梯度向量的方向。而$f(x,y)$在$(x_0,y_0)$处的梯度向量是$(\frac{\partial f}{\partial x}|_{x_0,y_0},\frac{\partial f}{\partial y}|_{x_0,y_0})$。所以$(x_0+\frac{\partial f}{\partial x}|_{x_0,y_0},y_0+\frac{\partial f}{\partial y}|_{x_0,y_0})$可以使得$f(x,y)$​增长最快。</p><p>那么相反的（如果一个函数是凸的），函数的减小最快的方向就是梯度向量的反方向，即$(x_0-\frac{\partial f}{\partial x}|_{x_0,y_0},y_0-\frac{\partial f}{\partial y}|_{x_0,y_0})$</p><h3 id="神经网络中的梯度下降"><a href="#神经网络中的梯度下降" class="headerlink" title="神经网络中的梯度下降"></a>神经网络中的梯度下降</h3><p>在神经网络中也是类似的，损失函数$f$（也就是神经网络预测的$\hat y$和实际的$y$的偏差）是各层权重矩阵$W$和偏置向量$b$的函数。</p><p>所以也可以用同样的方法去更新$W$和$b$​：</p><script type="math/tex; mode=display">W=W-\alpha \cdot \frac{\partial f}{\partial W}\\b=b-\alpha \cdot \frac{\partial f}{\partial b}</script><blockquote><p>这里的$\alpha$​是学习率</p></blockquote><p>下面直接给出神经网络中单层的梯度下降公式：</p><ul><li><p>计算 $dZ^{[l]}$：$dZ^{[l]} = dA^{[l]} * g^{[l]’}(Z^{[l]})$</p></li><li><p>计算 $dW^{[l]}$：$dW^{[l]} = \frac{1}{m} dZ^{[l]} \cdot A^{[l-1]T}$</p></li><li><p>计算 $db^{[l]}$：$db^{[l]} = \frac{1}{m}np.sum(dZ^{[l]},axis=1,keepdims=True)$</p></li><li><p>计算 $dA^{[l-1]}$：$dA^{[l-1]} = W^{[l]T} \cdot dZ^{[l]}$</p></li></ul><blockquote><p>其中，$dA^{[l]}$ 是损失函数对 $A^{[l]}$ 的梯度，$dZ^{[l]}$ 是损失函数对 $Z^{[l]}$​ 的梯度。上标$[l]$指的是第$l$​层。以此类推。</p><p>[!NOTE]</p><p>如果想看详细的证明，推荐吴恩达在B站的深度学习课程，这是相关的几节：</p><p><a href="https://www.bilibili.com/video/BV1FT4y1E74V?p=10&amp;vd_source=a72ba0205e5decee94fccb8c6b66a1e2">梯度下降法</a>、<a href="https://www.bilibili.com/video/BV1FT4y1E74V?p=15&amp;vd_source=a72ba0205e5decee94fccb8c6b66a1e2">逻辑回归中的梯度下降法</a>、<a href="https://www.bilibili.com/video/BV1FT4y1E74V?p=16">m个样本的梯度下降</a>、<a href="https://www.bilibili.com/video/BV1FT4y1E74V?p=33&amp;vd_source=a72ba0205e5decee94fccb8c6b66a1e2">神经网络中的梯度下降</a>、<a href="https://www.bilibili.com/video/BV1FT4y1E74V?p=34&amp;vd_source=a72ba0205e5decee94fccb8c6b66a1e2">直观理解反向传播</a></p></blockquote><h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><p>采用<code>Python</code>编写程序，需要用到的库有：</p><ul><li><code>numpy</code>：用于矩阵计算</li><li><code>tensorboard</code>（可选）：用来记录训练数据</li></ul><h1 id="单层神经元"><a href="#单层神经元" class="headerlink" title="单层神经元"></a>单层神经元</h1><p>因为可以将神经网络拆分成一层层神经元的堆叠，所以只要写好一层，将这层复制多份，就可以构建一个神经网络。所以可以创建一个名叫<code>Layer</code>的类，代表一层神经元</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  flowchart LRsubgraph 神经网络layer1[layer]layer2[layer]endinput--&gt;layer1--&gt;layer2--&gt;output  </pre></div><p>而如刚才所述，每一层都进行前向传播和反向传播。而在实现前向传播和反向传播之前，先来考虑每一层中应该有什么元素。</p><h2 id="Layer类中的变量"><a href="#Layer类中的变量" class="headerlink" title="Layer类中的变量"></a>Layer类中的变量</h2><p>再回头看抽象出来的神经元以及前向传播和反向传播的过程：</p><p>可以看出，每一层需要有权重矩阵<code>W</code>，偏置矩阵<code>b</code>，还有选用的激活函数$\sigma$。</p><p>除此之外，构建权重矩阵<code>W</code>时还需要知道该层结点数目；在实现反向传播的时候还需要知道该层神经网络的输入$A^{[l-1]}$、该层神经网络的输出对损失函数的导数$dA^{[l]}$、学习率$\alpha$、$WX+b$的输出$Z$以及样本数$m$。</p><p>所以类的成员变量如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Layer</span>:</span><br><span class="line">    <span class="comment"># 神经元参数</span></span><br><span class="line">    __W = <span class="literal">None</span>  <span class="comment"># 权重矩阵</span></span><br><span class="line">    __b = <span class="literal">None</span>  <span class="comment"># 偏置部分</span></span><br><span class="line">    __A_last_layer = <span class="literal">None</span>  <span class="comment"># 上层的输入</span></span><br><span class="line">    __Z = <span class="literal">None</span>  <span class="comment"># Wx+b得到的Z，之后会在反向传播中运用</span></span><br><span class="line">    __activation_function = <span class="literal">None</span>  <span class="comment"># 激活函数类型</span></span><br><span class="line">    __node_amount = <span class="literal">None</span>  <span class="comment"># 结点数目</span></span><br><span class="line">    __alpha = <span class="literal">None</span>  <span class="comment"># 学习率</span></span><br><span class="line">    __sample_amount = <span class="literal">None</span>  <span class="comment"># 样本数</span></span><br></pre></td></tr></table></figure><p>再给出构造函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, last_layer_node_amount, node_amount=<span class="number">4</span>, activation_function=<span class="string">&quot;relu&quot;</span>, alpha=<span class="number">0.1</span></span>):</span><br><span class="line">    <span class="comment"># 初始化节点数量和激活函数类型</span></span><br><span class="line">    self.__node_amount = node_amount</span><br><span class="line">    self.__activation_function = activation_function</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化权重矩阵</span></span><br><span class="line">    self.__W = np.random.randn(node_amount, last_layer_node_amount) * np.sqrt(<span class="number">2</span> / last_layer_node_amount)</span><br><span class="line">    <span class="comment"># 初始化偏置矩阵</span></span><br><span class="line">    self.__b = np.random.randn(node_amount, <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 设置学习率</span></span><br><span class="line">    self.__alpha = alpha</span><br></pre></td></tr></table></figure><h2 id="前向传播"><a href="#前向传播" class="headerlink" title="前向传播"></a>前向传播</h2><p>之后，就可以开始实现最简单的前向传播算法，总共就只有两步：</p><ol><li>计算$WX+b$得到$Z$​</li><li>根据激活函数的不同，选择不同的激活函数计算$Y=\sigma(Z)$</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, X: np.ndarray</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    前向传播</span></span><br><span class="line"><span class="string">    :param X: 每一列是一个样本，每一行是一个特征</span></span><br><span class="line"><span class="string">    :return: 该层的输出，保持每一列是一个样本，每一行是一个特征</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 设置样本数</span></span><br><span class="line">    self.__sample_amount = X.shape[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 前向传播</span></span><br><span class="line">    self.__A_last_layer = X</span><br><span class="line">    self.__Z = np.dot(self.__W, X) + self.__b  <span class="comment"># 计算WX+b</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.__activation_function == <span class="string">&quot;relu&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> activation_function.relu(self.__Z)</span><br><span class="line">    <span class="keyword">elif</span> self.__activation_function == <span class="string">&quot;sigmoid&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> activation_function.sigmoid(self.__Z)</span><br><span class="line">    <span class="keyword">elif</span> self.__activation_function == <span class="string">&quot;linear&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> activation_function.linear(self.__Z)</span><br><span class="line">    <span class="keyword">elif</span> self.__activation_function == <span class="string">&quot;tanh&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> activation_function.tanh(self.__Z)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> <span class="string">&quot;invalid activation function!&quot;</span></span><br></pre></td></tr></table></figure><p>这里以<code>relu</code>为例，给出激活函数的实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">relu</span>(<span class="params">Z: np.ndarray</span>):</span><br><span class="line">    <span class="keyword">return</span> np.where(Z &gt; <span class="number">0</span>, Z, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h2><p>反向传播是整个代码中最复杂的部分，但只要掌握这四条公式，也是四个步骤，写下来也不难：</p><ol><li>计算 $dZ^{[l]}$：$dZ^{[l]} = dA^{[l]} * g^{[l]’}(Z^{[l]})$</li><li><p>计算 $dW^{[l]}$：$dW^{[l]} = \frac{1}{m} dZ^{[l]} \cdot A^{[l-1]T}$</p></li><li><p>计算 $db^{[l]}$：$db^{[l]} = \frac{1}{m}np.sum(dZ^{[l]},axis=1,keepdims=True)$</p></li><li><p>计算 $dA^{[l-1]}$：$dA^{[l-1]} = W^{[l]T} \cdot dZ^{[l]}$</p></li></ol><p>转换为对应代码，即为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self, dA</span>):</span><br><span class="line">    dZ = <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 计算dZ</span></span><br><span class="line">    <span class="keyword">if</span> self.__activation_function == <span class="string">&quot;relu&quot;</span>:</span><br><span class="line">        dZ = dA * activation_function.d_relu(self.__Z)</span><br><span class="line">    <span class="keyword">elif</span> self.__activation_function == <span class="string">&quot;sigmoid&quot;</span>:</span><br><span class="line">        dZ = dA * activation_function.d_sigmoid(self.__Z)</span><br><span class="line">    <span class="keyword">elif</span> self.__activation_function == <span class="string">&quot;linear&quot;</span>:</span><br><span class="line">        dZ = dA * activation_function.d_linear(self.__Z)</span><br><span class="line">    <span class="keyword">elif</span> self.__activation_function == <span class="string">&quot;tanh&quot;</span>:</span><br><span class="line">        dZ = dA * activation_function.d_tanh(self.__Z)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> <span class="string">&quot;invalid activation function!&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算上一层的dA</span></span><br><span class="line">    dA_last_layer = np.dot(self.__W.T, dZ)</span><br><span class="line">    <span class="comment"># 更新权重矩阵</span></span><br><span class="line">    self.__W -= self.__alpha * (<span class="number">1</span> / self.__sample_amount) * np.dot(dZ, self.__A_last_layer.T)</span><br><span class="line">    <span class="comment"># 更新偏置量</span></span><br><span class="line">    self.__b -= (<span class="number">1</span> / self.__sample_amount) * np.<span class="built_in">sum</span>(dZ, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dA_last_layer</span><br></pre></td></tr></table></figure><p>这里以<code>relu</code>为例，给出激活函数导数的实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">d_relu</span>(<span class="params">Z: np.ndarray</span>):</span><br><span class="line">    <span class="keyword">return</span> np.where(Z &gt; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h1 id="神经网络的封装"><a href="#神经网络的封装" class="headerlink" title="神经网络的封装"></a>神经网络的封装</h1><p>写好单层之后，将单层神经元进行堆叠就可以得到完整的神经网络。</p><p>定义一个Network类，用于保存神经网络。以下是其的成员变量和构造函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Network</span>:</span><br><span class="line">    __layers = []  <span class="comment"># 保存隐藏层和输出层</span></span><br><span class="line">    __X_train, __Y_train, __X_test, __Y_test = <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>  <span class="comment"># 训练集和测试集</span></span><br><span class="line">    __loss_function = <span class="literal">None</span>  <span class="comment"># 损失函数</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, nodes_amount: <span class="built_in">list</span>, X_train, Y_train, X_test, Y_test, learning_speed,</span></span><br><span class="line"><span class="params">             output_layer_function=<span class="string">&quot;sigmoid&quot;</span>,</span></span><br><span class="line"><span class="params">             hidden_layer_function=<span class="string">&quot;relu&quot;</span>,</span></span><br><span class="line"><span class="params">             loss_function=<span class="string">&quot;cross entropy&quot;</span></span>):  <span class="comment"># 通过字符串来选择隐藏层，输出层的激活函数，还有损失函数</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    初始化神经网络</span></span><br><span class="line"><span class="string">    :param nodes_amount: 每层的结点数</span></span><br><span class="line"><span class="string">    :param X_train: 训练数据，每行是不同特征，每列是不同样本</span></span><br><span class="line"><span class="string">    :param Y_train: 训练标签，每行使不同特征，每列是不同样本</span></span><br><span class="line"><span class="string">    :param X_test: 测试数据，每行是不同特征，每列是不同样本</span></span><br><span class="line"><span class="string">    :param Y_test: 测试标签，每行是不同特征，每列是不同样本</span></span><br><span class="line"><span class="string">    :param learning_speed: 学习速率</span></span><br><span class="line"><span class="string">    :param output_layer_function: 输出层激活函数</span></span><br><span class="line"><span class="string">    :param hidden_layer_function: 隐藏层激活函数</span></span><br><span class="line"><span class="string">    :param loss_function: 损失函数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 判断维度是否正确</span></span><br><span class="line">    <span class="keyword">if</span> X_train.shape[<span class="number">0</span>] != X_test.shape[<span class="number">0</span>] <span class="keyword">or</span> Y_train.shape[<span class="number">0</span>] != Y_test.shape[<span class="number">0</span>] <span class="keyword">or</span> X_train.shape[<span class="number">1</span>:] != \</span><br><span class="line">            Y_train.shape[<span class="number">1</span>:] <span class="keyword">or</span> X_test.shape[<span class="number">1</span>:] != Y_test.shape[<span class="number">1</span>:]:</span><br><span class="line">        <span class="keyword">raise</span> <span class="string">&quot;dimension error&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存损失函数</span></span><br><span class="line">    <span class="keyword">if</span> loss_function == <span class="string">&quot;cross entropy&quot;</span>:</span><br><span class="line">        self.__loss_function = loss_function</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> <span class="string">&quot;loss function name error&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存训练集、测试集</span></span><br><span class="line">    self.__X_train = X_train</span><br><span class="line">    self.__X_test = X_test</span><br><span class="line">    self.__Y_train = Y_train</span><br><span class="line">    self.__Y_test = Y_test</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化神经网络</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nodes_amount)):</span><br><span class="line">        <span class="keyword">if</span> index == <span class="number">0</span>:</span><br><span class="line">            self.__layers.append(</span><br><span class="line">                layer.Layer(X_train.shape[<span class="number">0</span>], nodes_amount[index], hidden_layer_function, learning_speed))</span><br><span class="line">        <span class="keyword">elif</span> index &lt; <span class="built_in">len</span>(nodes_amount) - <span class="number">1</span>:</span><br><span class="line">            self.__layers.append(</span><br><span class="line">                layer.Layer(nodes_amount[index - <span class="number">1</span>], nodes_amount[index], hidden_layer_function, learning_speed))</span><br><span class="line">        <span class="keyword">elif</span> index == <span class="built_in">len</span>(nodes_amount) - <span class="number">1</span>:</span><br><span class="line">            self.__layers.append(</span><br><span class="line">                layer.Layer(nodes_amount[index - <span class="number">1</span>], nodes_amount[index], output_layer_function, learning_speed))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="神经网络的训练"><a href="#神经网络的训练" class="headerlink" title="神经网络的训练"></a>神经网络的训练</h2><p>因为每一层的前向传播和反向传播都是已经写好的。所以在整个神经网络的训练过程中，只需要逐层调用前向传播和反向传播即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">self, times</span>):</span><br><span class="line">    <span class="comment"># 增加计数器</span></span><br><span class="line">    count = increment_counter()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#tensorboard记录</span></span><br><span class="line">    writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> iteration <span class="keyword">in</span> <span class="built_in">range</span>(times):</span><br><span class="line">        <span class="comment"># 正向传播</span></span><br><span class="line">        layer_input = self.__X_train</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.__layers)):</span><br><span class="line">            layer = self.__layers[index]</span><br><span class="line">            layer_input = layer.forward(layer_input)</span><br><span class="line"></span><br><span class="line">        dA = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> self.__loss_function == <span class="string">&quot;cross entropy&quot;</span>:</span><br><span class="line">            <span class="comment"># 计算误差。最后一层对下一层的输入就是最终输出</span></span><br><span class="line">            loss = loss_function.cross_entropy(layer_input, self.__Y_train)</span><br><span class="line">            <span class="comment">#记录数据</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;iteration:<span class="subst">&#123;iteration&#125;</span>,loss:<span class="subst">&#123;loss&#125;</span>&#x27;</span>)</span><br><span class="line">            writer.add_scalar(<span class="string">f&#x27;loss<span class="subst">&#123;count&#125;</span>&#x27;</span>, loss, iteration)</span><br><span class="line">            <span class="comment"># 计算最终输出对损失函数的偏导数</span></span><br><span class="line">            dA = loss_function.d_cross_entropy(layer_input, self.__Y_train)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#反向传播</span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.__layers) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            layer = self.__layers[index]</span><br><span class="line">            dA = layer.backward(dA)</span><br><span class="line">    writer.close()</span><br></pre></td></tr></table></figure><p>因为在反向传播的时候需要给出该层神经元输出对损失函数的偏导数，所以需要计算最终输出对损失函数的偏导数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dA = loss_function.d_cross_entropy(layer_input, self.__Y_train)</span><br></pre></td></tr></table></figure><p>这里的损失函数采取的是交叉熵函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cross_entropy</span>(<span class="params">A: np.ndarray, Y: np.ndarray</span>):</span><br><span class="line">    <span class="keyword">if</span> A.shape != Y.shape:</span><br><span class="line">        <span class="keyword">raise</span> <span class="string">&quot;dimension is not match&quot;</span></span><br><span class="line">    m = A.shape[<span class="number">1</span>]</span><br><span class="line">    loss = Y * np.log(A) + (<span class="number">1</span> - Y) * np.log(<span class="number">1</span> - A)</span><br><span class="line">    loss = (-<span class="number">1</span> / m) * np.<span class="built_in">sum</span>(loss, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> loss</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">d_cross_entropy</span>(<span class="params">A: np.ndarray, Y: np.ndarray</span>):</span><br><span class="line">    <span class="keyword">if</span> A.shape != Y.shape:</span><br><span class="line">        <span class="keyword">raise</span> <span class="string">&quot;dimension is not match&quot;</span></span><br><span class="line">    dA = -(Y * (<span class="number">1</span> / A) + (Y - <span class="number">1</span>) * (<span class="number">1</span> / (<span class="number">1</span> - A)))</span><br><span class="line">    <span class="keyword">return</span> dA</span><br></pre></td></tr></table></figure><p>至此，整个训练过程的代码就写完了</p><h2 id="神经网络的预测"><a href="#神经网络的预测" class="headerlink" title="神经网络的预测"></a>神经网络的预测</h2><p>神经网络的预测实际上就是对特征矩阵做一次前向传播，神经网络的输出就是预测结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, X</span>):</span><br><span class="line">    layer_input = X</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.__layers)):</span><br><span class="line">        layer = self.__layers[index]</span><br><span class="line">        layer_input = layer.forward(layer_input)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> layer_input</span><br></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>至此，整个神经网络的框架就搭建好了。主要的两个类是单层神经元<code>Layer</code>以及神经网络类<code>Network</code>：<code>Layer</code>类需要实现前向传播和反向传播，<code>Network</code>类需要实现训练的过程。</p><p>其他的例如激活函数的改变、损失函数的改变，只需要在原有的框架下写一些条件判断即可。</p>]]></content>
      
      
      <categories>
          
          <category> 重生之我是程序员 </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>爬虫笔记</title>
      <link href="/post/498308509.html"/>
      <url>/post/498308509.html</url>
      
        <content type="html"><![CDATA[<h1 id="模拟发送-HTTP-请求"><a href="#模拟发送-HTTP-请求" class="headerlink" title="模拟发送 HTTP 请求"></a>模拟发送 HTTP 请求</h1><h2 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h2><p>GET请求是HTTP协议中定义的一种请求方法，用于从服务器获取数据。当发起一个GET请求时，客户端（通常是用户的网页浏览器）向服务器发送一个请求，请求服务器返回指定的资源或数据。当我们用浏览器打开网页时，其实发送的最原始的请求就是 GET 请求</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests </span><br><span class="line">res = requests.get(<span class="string">&#x27;http://www.douban.com&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(res) </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(res)) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line">&lt;Response [<span class="number">200</span>]&gt; </span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;requests.models.Response&#x27;</span>&gt; </span><br></pre></td></tr></table></figure><p>可以看到，我们得到的是一个 <code>Response</code> 对象</p><p>如果我们要获取网站返回的数据，可以使用 <code>text</code> 或者 <code>content</code> 属性来获取</p><p><code>text</code>：是以字符串的形式返回数据</p><p><code>content</code>：是以二进制的方式返回数据</p><h2 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h2><p>POST请求是HTTP协议中定义的另一种请求方法，用于向服务器提交数据。当发起一个POST请求时，客户端向服务器发送数据，并且这些数据通常作为HTTP请求的一部分（称为请求体）被发送。</p><p>对于 POST 请求，一般就是提交一个表单。<code>data</code> 当中，就是需要传递的表单信息，是一个字典类型的数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r = requests.post(<span class="string">&#x27;http://www.xxxx.com&#x27;</span>, data=&#123;<span class="string">&quot;key&quot;</span>: <span class="string">&quot;value&quot;</span>&#125;) </span><br></pre></td></tr></table></figure><h2 id="header-增强"><a href="#header-增强" class="headerlink" title="header 增强"></a>header 增强</h2><p>requests 发送的请求所带的请求头中 User-Agent 会标识为 python 程序发送的请求。</p><p>由于这种行为仅仅是消耗服务器资源带来成本，但是不会给对方带来任何好处（搜索引擎的爬虫除外），所以有一些网站会加入反爬机制，通过识别 headers 来拒绝对你的请求进行响应。</p><p>所以需要做一些 header 增强。比如：UA，Cookie，host 等等信息。</p><p>浏览器访问网站时的 headers 可以在<a href="https://link.zhihu.com/?target=https%3A//httpbin.org/headers">httpbin.org/headers</a> 中得到。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;headers&quot;: &#123;</span><br><span class="line">    &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;, </span><br><span class="line">    &quot;Accept-Encoding&quot;: &quot;gzip, deflate, br&quot;, </span><br><span class="line">    &quot;Accept-Language&quot;: &quot;zh-CN,zh-Hans;q=0.9&quot;, </span><br><span class="line">    &quot;Host&quot;: &quot;httpbin.org&quot;, </span><br><span class="line">    &quot;Referer&quot;: &quot;https://link.zhihu.com/?target=https%3A//httpbin.org/headers&quot;, </span><br><span class="line">    &quot;Sec-Fetch-Dest&quot;: &quot;document&quot;, </span><br><span class="line">    &quot;Sec-Fetch-Mode&quot;: &quot;navigate&quot;, </span><br><span class="line">    &quot;Sec-Fetch-Site&quot;: &quot;cross-site&quot;, </span><br><span class="line">    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.4.1 Safari/605.1.15&quot;, </span><br><span class="line">    &quot;X-Amzn-Trace-Id&quot;: &quot;Root=1-662b0580-3525d80357418fc75f2d3472&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的请求头复制下来，传给 <code>requests.get()</code> 函数，即可将请求伪装成浏览器。</p><p><code>requests.get()</code> 的语法是：<code>requests.get(url,kwargs)</code>。</p><p>其中，url 是我们想要访问的链接，kwargs 是可选参数，包括params、data、json、headers、cookies、auth、files、timeout、proxies、stream、verify、cert等。常用的参数有data、headers。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://httpbin.org/headers&#x27;</span></span><br><span class="line"></span><br><span class="line">headers= &#123;</span><br><span class="line">    <span class="string">&quot;Accept&quot;</span>: <span class="string">&quot;image/gif, image/jpeg, image/pjpeg, application/x-ms-application, application/xaml+xml, application/x-ms-xbap, */*&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Accept-Encoding&quot;</span>: <span class="string">&quot;gzip, deflate&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Accept-Language&quot;</span>: <span class="string">&quot;zh-Hans-CN,zh-Hans;q=0.8,en-US;q=0.5,en;q=0.3&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Host&quot;</span>: <span class="string">&quot;httpbin.org&quot;</span>, </span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; Tablet PC 2.0; wbx 1.0.0; wbxapp 1.0.0; Zoom 3.6.0)&quot;</span>, </span><br><span class="line">    <span class="string">&quot;X-Amzn-Trace-Id&quot;</span>: <span class="string">&quot;Root=1-628b672d-4d6de7f34d15a77960784504&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">response = requests.get(url,headers=headers)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">    <span class="built_in">print</span>(response.text) </span><br></pre></td></tr></table></figure><h1 id="解析-HTML"><a href="#解析-HTML" class="headerlink" title="解析 HTML"></a>解析 HTML</h1><p>现在我们已经获取到了网页返回的数据，即 HTML 代码，下面就需要解析 HTML，来提取其中有效的信息。</p><h2 id="BeautifulSoup"><a href="#BeautifulSoup" class="headerlink" title="BeautifulSoup"></a>BeautifulSoup</h2><p><code>BeautifulSoup</code> 是 Python 的一个库，最主要的功能是从网页解析数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup  <span class="comment"># 导入 BeautifulSoup 的方法 </span></span><br><span class="line"><span class="comment"># 可以传入一段字符串，或者传入一个文件句柄。一般都会先用 requests 库获取网页内容，然后使用 soup 解析。 </span></span><br><span class="line">soup = BeautifulSoup(html_doc,<span class="string">&#x27;html.parser&#x27;</span>)  <span class="comment"># 这里一定要指定解析器，可以使用默认的 html，也可以使用 lxml。 </span></span><br><span class="line"><span class="built_in">print</span>(soup.prettify())  <span class="comment"># 按照标准的缩进格式输出获取的 soup 内容。 </span></span><br></pre></td></tr></table></figure><blockquote><p><code>bs4</code> 是 <code>BeautifulSoup</code> 库的简称，它是一个用于解析 HTML 和 XML 文档的 Python 库，通常用于网页抓取和数据分析。<code>BeautifulSoup</code> 能够处理复杂的 HTML 网页内容，并提供简单易用的 API 来访问和修改数据。</p><p><code>BeautifulSoup</code> 库的名字来源于一个儿童故事中的角色，这个角色喜欢“把字符串咀嚼成美味的网络抓取汤”，因此得名“BeautifulSoup”。</p></blockquote><h3 id="BeautifulSoup-的一些简单用法"><a href="#BeautifulSoup-的一些简单用法" class="headerlink" title="BeautifulSoup 的一些简单用法"></a>BeautifulSoup 的一些简单用法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(soup.title)  <span class="comment"># 获取文档的 title </span></span><br><span class="line"><span class="built_in">print</span>(soup.title.name)  <span class="comment"># 获取 title 的 name 属性 </span></span><br><span class="line"><span class="built_in">print</span>(soup.title.string)  <span class="comment"># 获取 title 的内容 </span></span><br><span class="line"><span class="built_in">print</span>(soup.p)  <span class="comment"># 获取文档中第一个 p 节点 </span></span><br><span class="line"><span class="built_in">print</span>(soup.p[<span class="string">&#x27;class&#x27;</span>])  <span class="comment"># 获取第一个 p 节点的 class 内容 </span></span><br><span class="line"><span class="built_in">print</span>(soup.find_all(<span class="string">&#x27;a&#x27;</span>))  <span class="comment"># 获取文档中所有的 a 节点，返回一个 list </span></span><br><span class="line"><span class="built_in">print</span>(soup.find_all(<span class="string">&#x27;span&#x27;</span>, attrs=&#123;<span class="string">&#x27;style&#x27;</span>: <span class="string">&quot;color:#ff0000&quot;</span>&#125;))  <span class="comment"># 获取文档中所有的 span 且 style 符合规则的节点，返回一个 list </span></span><br></pre></td></tr></table></figure><p>在HTML和XML文档中，<code>p</code> 结点通常指的是 <code>&lt;p&gt;</code> 标签创建的元素，它代表一个段落（Paragraph）。<code>&lt;p&gt;</code> 标签是块级元素，用于定义文本的一个段落。在网页中，浏览器会在段落之间添加一些垂直的空白，以区分不同的段落。<br>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是另一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上面的HTML代码中，每个 <code>&lt;p&gt;</code> 元素都定义了一个文本段落。<br>同样，<code>a</code> 结点指的是 <code>&lt;a&gt;</code> 标签创建的元素，它代表一个锚点（Anchor）。<code>&lt;a&gt;</code> 标签用于创建超链接，允许用户通过点击跳转到其他网页、文件、位置或其他资源。<code>&lt;a&gt;</code> 标签可以包含文本、图片等任何内容，并且通常有一个 <code>href</code> 属性，指定了链接的目标URL。<br>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.example.com&quot;</span>&gt;</span>访问示例网站<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上面的HTML代码中，<code>&lt;a&gt;</code> 元素创建了一个文本为“访问示例网站”的超链接，当用户点击这个链接时，浏览器会跳转到 <code>https://www.example.com</code> 这个URL。</p><h3 id="find-all"><a href="#find-all" class="headerlink" title="find_all"></a>find_all</h3><p>在Python的<code>BeautifulSoup</code>库中，<code>find_all</code>方法用于搜索HTML或XML文档，并返回所有匹配指定条件的元素。<code>find_all</code>方法可以接受多种参数，包括要查找的标签名、属性、CSS类等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data = content.find_all(<span class="string">&#x27;div&#x27;</span>, attrs=&#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;cover&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure><p>这行代码的作用是：</p><ol><li><code>content</code> 是一个 <code>BeautifulSoup</code> 对象，它代表了已经解析的HTML文档。</li><li><code>find_all</code> 方法被调用，第一个参数 <code>&#39;div&#39;</code> 指定了要搜索的标签名，即 <code>&lt;div&gt;</code>。</li><li><code>attrs=&#123;&#39;class&#39;: &#39;cover&#39;&#125;</code> 参数指定了要搜索的 <code>&lt;div&gt;</code> 标签必须具有 <code>class</code> 属性，且属性值包含 <code>cover</code>。这意味着 <code>find_all</code> 方法将返回所有类名为 <code>cover</code> 的 <code>&lt;div&gt;</code> 元素。</li></ol><p>结果 <code>data</code> 将是一个列表，包含了文档中所有匹配的 <code>&lt;div&gt;</code> 元素。每个元素都是一个 <code>Tag</code> 对象，你可以对这些对象进行进一步的操作，例如提取文本、属性或其他嵌套的标签。</p><p>例如，如果您想要遍历这些 <code>&lt;div&gt;</code> 元素并打印它们的文本内容，可以这样做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> div <span class="keyword">in</span> data:</span><br><span class="line">    <span class="built_in">print</span>(div.get_text())</span><br></pre></td></tr></table></figure><p>这将会打印出每个类名为 <code>cover</code> 的 <code>&lt;div&gt;</code> 元素中的文本内容。</p><blockquote><p><code>&lt;div&gt;</code>元素是HTML文档中的一个块级元素，它用于定义文档中的一个区域或部分，并且可以用来组合其他HTML元素。<code>&lt;div&gt;</code>是 “division” 的缩写，意为“分区”。</p></blockquote><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>在 <code>BeautifulSoup</code> 中，<code>find</code> 方法用于搜索当前元素下的子元素，并返回第一个匹配的元素。如果找到了多个匹配的元素，<code>find</code> 方法只返回第一个匹配的元素。如果没有找到匹配的元素，则返回 <code>None</code>。</p><p>例如，假设我们有以下HTML代码片段：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cover&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;image1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图片1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;image2.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图片2&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果我们已经有一个 <code>BeautifulSoup</code> 对象 <code>d</code>，它代表上面的 <code>&lt;div&gt;</code> 元素，那么我们可以使用 <code>d.find(&#39;img&#39;)</code> 来找到第一个 <code>&lt;img&gt;</code> 子元素。</p><p>我们可以进一步从 <code>img_tag</code> 中获取 <code>src</code> 属性，得到图片的URL：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img_url = img_tag[<span class="string">&#x27;src&#x27;</span>]</span><br></pre></td></tr></table></figure><p>在这里，<code>img_url</code> 的值将是 <code>&quot;image1.jpg&quot;</code>。</p><h3 id="get-text"><a href="#get-text" class="headerlink" title="get_text"></a>get_text</h3><p>在 <code>BeautifulSoup</code> 中，<code>get_text()</code> 方法是一个用于提取标签内文本内容的方法。它将返回一个字符串，该字符串包含指定标签及其所有子标签的文本内容，而不包含任何HTML标签或属性。</p><p><code>get_text()</code> 方法可以用于任何 <code>Tag</code> 对象，它会递归地提取所有子标签的文本，并将它们连接成一个字符串。<br>这里有一些 <code>get_text()</code> 方法的基本用法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="comment"># 假设我们有以下HTML内容</span></span><br><span class="line">html_doc = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">&lt;head&gt;</span></span><br><span class="line"><span class="string">    &lt;title&gt;Page Title&lt;/title&gt;</span></span><br><span class="line"><span class="string">&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;p&gt;这是一个段落。&lt;/p&gt;</span></span><br><span class="line"><span class="string">        &lt;a href=&quot;http://example.com&quot;&gt;这是一个链接&lt;/a&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 使用 BeautifulSoup 解析 HTML</span></span><br><span class="line">soup = BeautifulSoup(html_doc, <span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取整个文档的文本内容</span></span><br><span class="line">text = soup.get_text()</span><br><span class="line"><span class="built_in">print</span>(text)</span><br></pre></td></tr></table></figure><p>输出将会是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Page Title</span><br><span class="line">这是一个段落。</span><br><span class="line">这是一个链接</span><br></pre></td></tr></table></figure><br>你也可以在特定的标签上调用 <code>get_text()</code> 方法来提取该标签及其子标签的文本：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取特定标签 &lt;div&gt; 的文本内容</span></span><br><span class="line">div_text = soup.div.get_text()</span><br><span class="line"><span class="built_in">print</span>(div_text)</span><br></pre></td></tr></table></figure><br>输出将会是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这是一个段落。</span><br><span class="line">这是一个链接</span><br></pre></td></tr></table></figure><br><code>get_text()</code> 方法还有一些参数，可以用来控制如何提取文本：</p><ul><li><code>strip</code>: 布尔值，默认为 <code>False</code>，表示是否去除文本前后的空白字符。</li><li><code>separator</code>: 字符串，用于连接各个文本片段的分隔符，默认为 “”，表示不添加分隔符。</li></ul><h1 id="下载图片"><a href="#下载图片" class="headerlink" title="下载图片"></a>下载图片</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">download_picture</span>(<span class="params">pic_l</span>): </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">r&#x27;picture&#x27;</span>): </span><br><span class="line">        os.mkdir(<span class="string">r&#x27;picture&#x27;</span>) </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> pic_l: </span><br><span class="line">        pic = requests.get(i) </span><br><span class="line">        p_name = i.split(<span class="string">&#x27;/&#x27;</span>)[<span class="number">7</span>] </span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;picture\\&#x27;</span> + p_name, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f: </span><br><span class="line">            f.write(pic.content) </span><br></pre></td></tr></table></figure><ol><li><code>if not os.path.exists(r&#39;picture&#39;):</code><ul><li>这个条件判断语句检查在当前目录下是否存在一个名为 <code>picture</code> 的文件夹。<code>os.path.exists</code>是一个检查路径是否存在的函数，<code>r&#39;picture&#39;</code> 表示 <code>picture</code> 文件夹的路径，<code>r</code> 前缀表示这是一个原始字符串，不处理反斜杠 <code>\</code> 作为转义字符。</li></ul></li><li><code>os.mkdir(r&#39;picture&#39;)</code><ul><li>如果上述条件成立（即 <code>picture</code> 文件夹不存在），这行代码会创建一个名为 <code>picture</code> 的新文件夹。</li></ul></li><li><code>pic = requests.get(i)</code><ul><li>在循环内部，这行代码使用 <code>requests.get</code> 函数从互联网上获取（下载）URL <code>i</code> 指向的图片内容，并将响应内容赋值给变量 <code>pic</code>。</li></ul></li><li><code>p_name = i.split(&#39;/&#39;)[7]</code><ul><li>这行代码将URL <code>i</code> 按照斜杠 <code>/</code> 分割成多个部分，并取出第8个部分（列表索引为7）作为图片的文件名。这里假设URL的第八部分是图片的文件名。</li></ul></li><li><code>with open(&#39;picture\\&#39; + p_name, &#39;wb&#39;) as f:</code><ul><li>这行代码打开一个文件，文件路径是 <code>picture</code> 文件夹加上图片的文件名 <code>p_name</code>，文件以二进制写模式（‘wb’）打开。<code>with</code> 语句确保文件使用后会被正确关闭。变量 <code>f</code> 是打开文件的引用。</li></ul></li><li><code>f.write(pic.content)</code><ul><li>最后，这行代码将下载的图片内容 <code>pic.content</code> 写入到文件 <code>f</code> 中，完成图片的保存。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 重生之我是程序员 </category>
          
          <category> Python笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>你好</title>
      <link href="/post/10739.html"/>
      <url>/post/10739.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

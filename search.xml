<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Pycharm设置运行配置</title>
      <link href="/post/1176275894.html"/>
      <url>/post/1176275894.html</url>
      
        <content type="html"><![CDATA[<p>Pycharm中运行python程序的时候不会调用<code>source ~/.bashrc</code>，所以有很多环境变量可能没有。</p><p>所以可以提前开一个终端，然后将所有环境变量保存下来</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env &gt; ./environment.env</span><br></pre></td></tr></table></figure><p>然后再在Pycharm运行配置中填入<code>.env</code>文件的路径。方便的加载环境变量。</p>]]></content>
      
      
      <categories>
          
          <category> 重生之我是程序员 </category>
          
          <category> Python笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学海泛舟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在pycharm中重命名项目</title>
      <link href="/post/3715959065.html"/>
      <url>/post/3715959065.html</url>
      
        <content type="html"><![CDATA[<h1 id="噩梦伊始"><a href="#噩梦伊始" class="headerlink" title="噩梦伊始"></a>噩梦伊始</h1><p>在Pycharm中创建一个项目之后，我们可能对自己取的项目名称不满意：</p><p><img src="/images/在pycharm中重命名项目.assets/image-20240904221248828.png" alt="image-20240904221248828"></p><p>比如，此时我想把名称A改为名称B。此时我们会发现，在Pycharm中有一个重命名项目的功能：</p><p><img src="/images/在pycharm中重命名项目.assets/image-20240904221350510.png" alt="image-20240904221350510"></p><p>在执行完两个重构：重命名项目和重命名目录之后，可以发现如我们所愿，项目和目录名称都变了。</p><p><img src="/images/在pycharm中重命名项目.assets/image-20240904221506234.png" alt="image-20240904221506234"></p><p>但这时如果运行原来的程序，会直接报错运行出错：</p><p><img src="/images/在pycharm中重命名项目.assets/image-20240904221654579.png" alt="image-20240904221654579"></p><h1 id="匆忙逃窜"><a href="#匆忙逃窜" class="headerlink" title="匆忙逃窜"></a>匆忙逃窜</h1><p>这是因为，目录名称改了，但是工作目录的名称没改。也就是运行配置没改。</p><p>此时就需要编辑配置：</p><p><img src="/images/在pycharm中重命名项目.assets/image-20240904221638157.png" alt="image-20240904221638157"></p><p><img src="/images/在pycharm中重命名项目.assets/image-20240904221719165.png" alt="image-20240904221719165"></p><p>发现有三个地方需要更改：</p><ol><li>需要将第一个解释器改为<code>~/PycharmProjects/B/.venv/bin.python</code></li><li>需要更改脚本路径为<code>/Users/wanhuabai/PycharmProjects/B/.venv/bin.python</code></li><li>需要更改工作目录为<code>/Users/wanhuabai/PycharmProjects/B</code></li></ol><p>第二三项可以直接点击旁边的文件夹图标进行更改，而第一项的修改比较麻烦。</p><p>首先进入设置，改掉Python解释器的路径。在这个界面点击全部显示。</p><p><img src="/images/在pycharm中重命名项目.assets/image-20240904222247329.png" alt="image-20240904222247329"></p><p>先移除解释器：</p><p><img src="/images/在pycharm中重命名项目.assets/image-20240904222331858.png" alt="image-20240904222331858"></p><p>然后再添加解释器：</p><p><img src="/images/在pycharm中重命名项目.assets/image-20240904222354808.png" alt="image-20240904222354808"></p><p>更改完这个之后运行配置中的解释器也会跟着改变。现在就可以正常运行项目了：</p><p><img src="/images/在pycharm中重命名项目.assets/image-20240904222459668.png" alt="image-20240904222459668"></p><h1 id="重获新生"><a href="#重获新生" class="headerlink" title="重获新生"></a>重获新生</h1><p>但此时还没完，因为现在打开终端，会发现找不到虚拟环境中的<code>pip</code>。</p><p><img src="/images/在pycharm中重命名项目.assets/image-20240904222758867.png" alt="image-20240904222758867"></p><p>同时查看<code>VIRTUAL_ENV</code>环境变量，会发现它没有变化：</p><p><img src="/images/在pycharm中重命名项目.assets/image-20240904222842882.png" alt="image-20240904222842882"></p><p>这是因为这个环境变量的地址是硬编码在<code>./.venv/bin/activate</code>等文件中的，需要手动进行替换。打开文件，可以发现这里的路径还是没更改项目名称前的路径名。</p><p><img src="/images/在pycharm中重命名项目.assets/image-20240904223043500.png" alt="image-20240904223043500"></p><p>使用<code>Pycharm</code>的在文件中替换的功能：</p><p><img src="/images/在pycharm中重命名项目.assets/image-20240904223027304.png" alt="image-20240904223027304"></p><p>将<code>./.venv/bin/</code>下所有错误的路径都替换掉：</p><p><img src="/images/在pycharm中重命名项目.assets/image-20240904223242875.png" alt="image-20240904223242875"></p><p>一键替换全部之后。再重新打开终端，可以发现一切都正常了：</p><p><img src="/images/在pycharm中重命名项目.assets/image-20240904223350052.png" alt="image-20240904223350052"></p><p>至此整个重命名项目的过程就结束了，推荐用<code>anaconda</code>或者<code>miniconda</code>来管理环境，就不会遇到<code>.venv</code>那么折腾的报错了。</p>]]></content>
      
      
      <categories>
          
          <category> 重生之我是程序员 </category>
          
          <category> Python笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学海泛舟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>体素、网格与点云</title>
      <link href="/post/2370170588.html"/>
      <url>/post/2370170588.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>网上的关于体素（Voxel）、网格（Mesh）和点云（Point Cloud）的资料比较分散，而它们又是三维重建中很基础且重要的内容。故写了一篇文章总结了一下网上的相关资料。</p><p><img src="/images/体素、网格与点云.assets/v2-5baf89ccc42a1ce346121266bbdacf1f_1440w.png" alt="什么是体素(Voxel)?"></p><blockquote><p>一个三维空间中的物体在计算机中可以有不同的表达形式，图a是用点云（Point Cloud）表达，图b是用体素（Voxel）表达，图c是用网格（Mesh）表达</p></blockquote><h1 id="体素"><a href="#体素" class="headerlink" title="体素"></a>体素</h1><p>二维的图片可以用一个个像素来表示，将二维图片看成一个$n\times n$的矩阵，则矩阵中存储的每一个数就是一个像素。如果这个矩阵仅存储0和1，那就有一张黑白的图片；如果这个矩阵每个数都是8位无符号数，那么就有了一张灰度图像。</p><p>三维中的物体也可以用同样的思想来表示，即将一个三维的物体看成$n\times n\times n$的矩阵，矩阵中存储的每一个数就是一个体素。同样的，这个体素可以只有1位，也可以是8位或32位数。</p><p><img src="/images/体素、网格与点云.assets/image-20240808143801248.png" alt="image-20240808143801248"></p><h1 id="网格"><a href="#网格" class="headerlink" title="网格"></a>网格</h1><p>多边形网格，也被称为“Mesh”，这里简称为网格，是计算机图形学中用于为各种不规则物体建立模型的一种数据结构。现实世界中的物体表面直观上看都是由曲面构成的，而在计算机里，曲面是由无数个小的多边形面片去组成的。Mesh既可以由三角形组成，也可以由其他平面形状如四边形，五边形等组成。而三角网格是最常用的一种。下面是几个由三角形网格表示的三维模型：</p><p><img src="/images/体素、网格与点云.assets/o_skull-surface.png" alt="img"></p><p><img src="/images/体素、网格与点云.assets/o_sphere-surface.png" alt="img"></p><p>三角面片在计算机中存储的时候只需要存储其的三个顶点就可以了，一般是将所有顶点的$(x,y,z)$坐标存为一个数组，然后每个面片就可以用三个数组索引来表示。</p><p>假设有这样的一个顶点数组：</p><div class="table-container"><table><thead><tr><th style="text-align:center">索引</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th></tr></thead><tbody><tr><td style="text-align:center">坐标</td><td style="text-align:center">$(1,2,3)$</td><td style="text-align:center">$(4,5,6)$</td><td style="text-align:center">$(7,8,9)$</td><td style="text-align:center">$(10,11,12)$</td></tr></tbody></table></div><p>那么一个由点$(1,2,3)、(4,5,6)、(10,11,12)$的面片就可以以索引$1、2、4$来表示。</p><h1 id="点云"><a href="#点云" class="headerlink" title="点云"></a>点云</h1><p>点云就是点的集合，在最基础的形式中，它是一个包含多个三维坐标点$(x,y,z)$的集合。当然，也可以给这些点加上颜色信息、强度信息等附加信息。但它们本质都是一组点的集合，可以表示为$(\text{point}_1,\text{point}_2,\text{point}_3,\cdots)$。</p><p><img src="/images/体素、网格与点云.assets/v2-0ab74f0b4ba273d0a630263afaeffec9_1440w.jpg" alt="《三维点云处理》学习笔记（5）Deep Learning for Point Cloud - 知乎"></p>]]></content>
      
      
      <categories>
          
          <category> 重生之我是程序员 </category>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学海泛舟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《文化理论与大众文化导论》约翰·斯道雷</title>
      <link href="/post/3226699343.html"/>
      <url>/post/3226699343.html</url>
      
        <content type="html"><![CDATA[<h1 id="《文化理论与大众文化导论》约翰·斯道雷"><a href="#《文化理论与大众文化导论》约翰·斯道雷" class="headerlink" title="《文化理论与大众文化导论》约翰·斯道雷"></a>《文化理论与大众文化导论》约翰·斯道雷</h1><blockquote><p>我想用《导论》的结尾作这篇随笔的开头：“因此，大众文化研究便兼有两重新使命，一是全力批判自以为是的精英主义价值观，二是避免掉入疲弱无力的反理智主义(anti-intellectualism)的窠臼。尽管本书未能开创一套全新的理论体系，但我仍竭力就现有视角勾勒一幅学术地图供大众文化的研习者参考，并期望读者诸君能够有所体悟，开创新的未来。”</p></blockquote><p>实际上，在读到第10章前，我对本书的印象还只是介绍文化研究中的各个流派，读毕我虽能对各个流派有所了解、认识了一些新名词和新观点，但似乎也只是停留在了解的层面，不知是否要作评价，也不知和自己的关系如何，更多像是“看客”。</p><p>但直至作者在第10-11章开始收束全书内容时，我不仅获得了更宏观、更统一的“文化观”，更是获得了文化与“我”的关系，愈是临近结尾，我愈是喜欢上这本《导论》。</p><p>作者就像是和蔼而学识丰富的引路人，从“何谓大众文化”作为全书《导论》中的“导论”起始，依次带我“游览”了<u>“文化与文明”传统、文化主义、马克思主义、精神分析、结构主义与后结构主义、性别与性取向、“种族”、种族主义与表征、后现代主义</u>，直至第10章开始与我讨论<u>大众文化的物质性</u>，到11章收束讨论<u>大众文化政治</u>。</p><h2 id="一、2～9章：对两个共同问题的回答"><a href="#一、2～9章：对两个共同问题的回答" class="headerlink" title="一、2～9章：对两个共同问题的回答"></a>一、2～9章：对两个共同问题的回答</h2><p>读毕全书，我想，不妨将本书2-9章提到的诸多流派“主义”归结为对这样两个共同问题的回答：什么是文化/大众文化？什么决定文化？</p><ol><li><p><strong>在第一个问题上</strong>，<u>“文化与文明”传统</u>虽然将大众文化带入学术研究的视野，但认为“文化是少数人的专利”，坚持“高雅文化”与“群氓文化”的分野；而<u>文化主义</u>开始倾向于认为文化是“普通人”在与日常生活的文本与实践的互动中获取的“活的经验”；<u>法兰克福学派</u>将文本意义与消费的相关问题从消极的沉思转化为积极的政治斗争；而<u>阿尔都塞主义</u>讨论文化与环境产生关联的“意识形态”；<u>结构主义</u>者则将文化与实践当作语言来研究；<u>后马克思主义</u>文化研究将文化定义为意义的生产、流通和消费过程，认为文化是与他人、与我们置身其中的社会世界进行意义共享和意义争斗的场所。</p></li><li><p><strong>而对于第二个问题</strong>，<u>霸权理论</u>认为统治阶级通过操纵文化的方式对社会加以引导而非统治，文化是自“上”而“下”的；<u>结构主义</u>认为文化的决定性因素是潜藏的结构，<u>后结构主义</u>则认为不存在牢不可破的潜在结构；<u>马克思主义文化观</u>将生产文本和实践的历史条件带入讨论；从<u>精神分析理论</u>开始，学者开始关注人在文本阐释中的主体性；<u>后马克思主义文化观</u>则进一步认为，大众文化是人们在积极主动地消费文化工业的文本与实践之中被生产出来的。</p></li><li><p>除了两个大的共同问题外，<strong>性别与种族</strong>也是文化研究议题中的一部分。其中，酷儿理论在性别议题上的激进性给我留下了很深的印象（理论认为所谓的生理性别也是文化建构的结果），但其在文本分析上的应用与解读，又与当今时代理念有部分地贴合，它提出反常性作为大众文化的接受实践，为各种各样的人所共享；在对种族的讨论中，人类生物学从未将人类化为不同的“种族”，只有种族主义（以及反种族主义）才坚持强调人种间的差异，而“做种族”这一行为的实质，在于将一个人简化为他的生物属性所“规定”的那些一成不变的“本质性”特征。</p></li></ol><p>诚然，以上对于理论的描述都很简略，也因此丢失了一些信息而显得过于武断。但从我的阅读体验而言，</p><p> <strong>似乎一切理论进入文化空间都产生了它的变体，与文化本身的特性相接合，从这种角度上看，不同的理论似乎照见了文化不同的侧面，文化的影子在各种理论的交锋中若隐若现。</strong></p><h2 id="二、10～11章：全书的收束"><a href="#二、10～11章：全书的收束" class="headerlink" title="二、10～11章：全书的收束"></a>二、10～11章：全书的收束</h2><p>在第10章，我们讨论了文化的物质性，这也是使我获得辩证文化观的重要一章：</p><ul><li>一方面，我们承认文化赖于客观存在的物质基础，人与人、人与物、物与物之间始终存在着行动与互动，也由此我们得以从中看见大众文化的物质性；</li><li>但另一方面，大众文化从来都不仅仅是物质性的，而且始终是意义、物质性和社会实践的合成体，文本的意义、物质的意义始终由人来构建——<strong>“是人，将鲜活的身份带入商品与文化商品的消费过程中；是人，带来了与商业遭遇的经验、感觉、社会地位与社会归属。”</strong> </li></ul><p>在最后一章大众文化中，作者提到，我们每个人，都应该视自己为文化的积极参与者。我非常非常喜欢这个论点。</p><ul><li>一方面，我们承认文化受资本参与的生产过程所制约，也无可否认消费具有被动色彩，无法否认工业文化的操纵性本质；</li><li>但更重要的是，另一方面，我们并不消解个人的主体性，我们从来不是被动的、只能对文化商品进行审美认同或误认的“群氓”消费者，即使我们没有选择的选择权，我们依旧在选择中、超脱选择之外，参与意义的建构，参与文化的建构。</li></ul><p>我想，这是我很喜欢的对文化与个体关系的回答。文化，这个词足够宏观，前9章的种种学术理念听起来是绚烂而浩瀚的寰宇，很大，但似乎离个体、离我很遥远，社会的结构性力量也好，经济基础也好，似乎我完完全全是被建构、被操纵的个体。但文化从来也在日常生活，大众文化在乎你我，即使作为个体，我们的意义从不被消解，我们的主体性从不被解构。</p><blockquote><p>再一次地，我想引用一段原文作为讨论的结尾：<strong>“我们每个人——不仅仅是先锋知识分子——都应当将自己视为文化的积极参与者，我们要通过选择、拒绝、制造意义、分配价值、抵抗，以及被蒙蔽、被控制等种种文化投入到文化中。”</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 偷得浮生半日闲 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人工智能</title>
      <link href="/post/3254563453.html"/>
      <url>/post/3254563453.html</url>
      
        <content type="html"><![CDATA[<h1 id="人工智能的三大学派"><a href="#人工智能的三大学派" class="headerlink" title="人工智能的三大学派"></a>人工智能的三大学派</h1><p>人工智能主要学派分为符号主义、连接主义、行为主义。</p><ul><li><p>符号主义（Symbolicism）学派：认为人工智能源于数理逻辑。该学派将数学严格公理化，从公理出发，由逻辑推理得到引理，定理，推论。</p></li><li><p>连接主义（Connectionism）学派：认为人工智能源于仿生学，特别是对人脑模型的研究。</p></li><li><p>行为主义（Actionism）学派：来源于控制论及“感知—动作”型控制系统。该学派认为智能取决于感知和行动，人工智能可以像人类智能一样逐步进化，以及智能行为只能在现实世界中与周围环境交互作用而表现出来。</p><script type="math/tex; mode=display">\begin{array}{|c|c|c|}\hline \text { 学习模式 } & \text { 优势 } & \text { 不足 } \\\hline \text { 用规则教 } & \begin{array}{c}\text { 与人类逻辑推理相似, 解 } \\\text { 释性强 }\end{array} & \begin{array}{c}\text { 难以构建完备的知识规则 } \\\text { 库 }\end{array} \\\hline \text { 用数据学 } & \text { 直接从数据中学 } & \begin{array}{c}\text { 以深度学习为例: 依赖于 } \\\text { 数据、解释性不强 }\end{array} \\\hline \text { 用问题引导 } & \begin{array}{c}\text { 从经验中进行能力的持续 } \\\text { 学习 }\end{array} & \begin{array}{c}\text { 非穷举式搜索而需更好策 } \\\text { 略 }\end{array} \\\hline\end{array}</script></li></ul><h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><h2 id="智能之根：数据"><a href="#智能之根：数据" class="headerlink" title="智能之根：数据"></a>智能之根：数据</h2><ul><li>人工智能的本质是从数据中挖掘知识，实现机器智能化的过程。</li><li>样例学习是智能体的基本学习方式之一。</li></ul><h2 id="数据的认识"><a href="#数据的认识" class="headerlink" title="数据的认识"></a>数据的认识</h2><ul><li>数据概念：数据对象及其属性的集合。</li><li>属性（变量、特征）：对象的属性或特性。</li><li>属性值：属性分配的数字或符号。<strong>属性值不一定反映出属性</strong></li><li>数据类型：类别属性、顺序属性、区间属性、比率属性。</li></ul><h2 id="数据集的类型"><a href="#数据集的类型" class="headerlink" title="数据集的类型"></a>数据集的类型</h2><ul><li>记录型数据（Record Data）：包含固定属性集的记录集合。</li><li>图/网络数据（Graph Data）：如社交网络、分子结构等。</li><li>有序数据（Ordered Data）：序列数据、时间序列数据、时空数据等。</li></ul><h2 id="数据质量"><a href="#数据质量" class="headerlink" title="数据质量"></a>数据质量</h2><p>数据的质量决定了算法的上限</p><ul><li>数据质量问题：噪声、异常值、缺失值、重复数据。</li><li>数据预处理：聚合、采样、降维、离散化、属性转换、特征创建、特征子集选择。</li></ul><h2 id="数据预处理技术"><a href="#数据预处理技术" class="headerlink" title="数据预处理技术"></a>数据预处理技术</h2><ul><li>聚合（Aggregation）：将多个属性或对象合并为单一属性或对象。</li><li>采样（Sampling）：数据选择的主要技术，用于初步调研和最终分析。</li><li><p>降维（Dimensionality Reduction）：减少数据集的维度，避免“维度的诅咒”。</p><ul><li>数据的维度越高，数据分散的就越分散。很多机器学习的方法都是基于距离的，在高维的表现不好，所以要将维度下降下来。常用的有PCA，T-SNE，SVD。</li></ul></li></ul><blockquote><p>T-SNE（t-Distributed Stochastic Neighbor Embedding）是一种非线性降维技术，通常用于高维数据的可视化。它是由Laurens van der Maaten和Geoffrey Hinton在2008年提出的。T-SNE的主要目的是将高维空间中的数据点映射到低维空间（通常是2维或3维），同时保持原始数据中的相似性结构。<br>T-SNE的特点包括但不限于：</p><ol><li><strong>非线性降维</strong>：与传统的线性降维技术（如PCA）不同，T-SNE能够捕捉数据中的非线性结构。</li><li><strong>相似性保持</strong>：T-SNE尝试在低维空间中保持高维空间中数据点之间的相似性。这意味着在高维空间中相似的数据点在低维空间中仍然相似，而不相似的数据点在低维空间中则被拉开。</li></ol><ul><li>离散化（Discretization）：将连续属性转换为分类属性。</li><li>属性转换（Attribute Transformation）：对属性值集映射到新的替代值集。</li><li>特征创建（Feature Creation）：从原始数据创建新特征，以更有效地捕捉重要信息。</li><li>特征子集选择（Feature Subset Selection）：减少数据维度，剔除冗余和不相关特征。</li></ul></blockquote><h2 id="从数据到智能的不同理解方式"><a href="#从数据到智能的不同理解方式" class="headerlink" title="从数据到智能的不同理解方式"></a>从数据到智能的不同理解方式</h2><ul><li>符号主义（Symbolism）：使用符号系统和规则来理解数据。</li><li>连接主义（Connectionism）：使用网络和学习算法来理解数据。</li><li>行为主义（Behaviorism）：使用环境和反馈来理解数据。</li></ul><h1 id="知识的表示与推理"><a href="#知识的表示与推理" class="headerlink" title="知识的表示与推理"></a>知识的表示与推理</h1><p>人工智能的本质是知识的表示</p><ul><li>人工智能的成功与否取决于其知识表示的清晰度。</li></ul><p>知识与数据、信息的区别：</p><ul><li>数据：单独的事实、信号、符号，是信息的载体。</li><li>信息：由符号组成，如文字和数字，赋予符号一定的意义。</li><li>知识：在信息的基础上增加上下文信息，提供更多意义。</li></ul><p>知识表示：将知识符号化并输入到计算机的过程和方法。</p><p>知识表示的两种基本观点：</p><ul><li>陈述性知识表示：知识表示与应用分开处理。</li><li>过程性知识表示：知识表示与应用结合，知识与程序融合。</li></ul><h2 id="现代逻辑学"><a href="#现代逻辑学" class="headerlink" title="现代逻辑学"></a>现代逻辑学</h2><h3 id="命题逻辑"><a href="#命题逻辑" class="headerlink" title="命题逻辑"></a>命题逻辑</h3><p><strong>命题</strong>：具有真假意义的陈述句。</p><p><strong>命题逻辑的组成</strong>：</p><ul><li>原子命题：最基本的命题。</li><li>复合命题：由联结词、标点符号和原子命题复合构成。</li></ul><blockquote><p>具体的公式参考离散数学以及人工智能课件</p></blockquote><h2 id="归结推理"><a href="#归结推理" class="headerlink" title="归结推理"></a>归结推理</h2><h3 id="1-子句"><a href="#1-子句" class="headerlink" title="1. 子句"></a>1. 子句</h3><p>在归结推理中，<strong>子句</strong>是一个关键概念。一个子句是逻辑公式的一个特殊形式，可以表示为：</p><script type="math/tex; mode=display">L_1 \vee L_2 \vee \ldots \vee L_n</script><p>其中，每个 $ L_i $ 都是一个文字（literal），文字可以是原子公式或其否定。子句也可以是空的，表示为 $\square$ 或 $\bot$，这在逻辑中代表矛盾或“假”。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>子句可以包含任意数量的文字。</li><li>子句中的文字可以是正的（原子公式）或负的（原子公式的否定）。</li><li>空子句表示逻辑矛盾。<h3 id="2-谓词公式转子句集"><a href="#2-谓词公式转子句集" class="headerlink" title="2. 谓词公式转子句集"></a>2. 谓词公式转子句集</h3></li></ul><p>要将下列谓词公式化为子句集：</p><script type="math/tex; mode=display">\forall x\{[\neg P(x) \vee \neg Q(x)] \rightarrow \exists y[S(x, y) \wedge Q(x)]\} \wedge \forall x[P(x) \vee B(x)]</script><ol><li><p><strong>消去蕴涵符号</strong><br>将原公式中的蕴涵符号（$\rightarrow$）转换为或（$\vee$）与非（$\wedge$）的组合：</p><script type="math/tex; mode=display">\forall x\{\neg[\neg P(x) \vee \neg Q(x)] \vee \exists y[S(x, y) \wedge Q(x)]\} \wedge \forall x[P(x) \vee B(x)]</script></li><li><p><strong>移动否定符号</strong><br>将否定符号（$\neg$）移到每个谓词前：</p><script type="math/tex; mode=display">\forall x\{[P(x) \wedge Q(x)] \vee \exists y[S(x, y) \wedge Q(x)]\} \wedge \forall x[P(x) \vee B(x)]</script></li><li><p><strong>变量标准化</strong><br>为了避免变量冲突，对变量进行标准化处理：</p><script type="math/tex; mode=display">\forall x\{[P(x) \wedge Q(x)] \vee \exists y[S(x, y) \wedge Q(x)]\} \wedge \forall w[P(w) \vee B(w)]</script></li><li><p><strong>消去存在量词</strong><br>设 $y$ 的Skolem函数是 $f(x)$，则：</p><script type="math/tex; mode=display">\forall x\{[P(x) \wedge Q(x)] \vee[S(x, f(x)) \wedge Q(x)]\} \wedge \forall w[P(w) \vee B(w)]</script></li><li><p><strong>化为前束型</strong><br>将公式化为前束型，即将量词移至公式最前面：</p><script type="math/tex; mode=display">\forall x \forall w\{\{[P(x) \wedge Q(x)] \vee[S(x, f(x)) \wedge Q(x)]\} \wedge[P(w) \vee B(w)]\}</script></li><li><p><strong>化为标准形</strong><br>将公式化为标准形，包括整理合取与析取：</p><script type="math/tex; mode=display">\begin{array}{l}\forall x \forall w\{\{[Q(x) \wedge P(x)] \vee[Q(x) \wedge S(x, f(x))]\} \wedge[P(w) \vee B(w)]\} \\\forall x \forall w\{Q(x) \wedge[P(x) \vee S(x, f(x))] \wedge[P(w) \vee B(w)]\}\end{array}</script></li><li><p><strong>略去全称量词</strong><br>在这一步中，我们去掉全称量词：</p><script type="math/tex; mode=display">Q(x) \wedge[P(x) \vee S(x, f(x))] \wedge[P(w) \vee B(w)]</script></li><li><p><strong>消去合取词</strong><br>将公式分解为子句集，每个合取词对应一个子句：</p><script type="math/tex; mode=display">\{Q(x),(P(x), S(x, f(x))),(P(w), B(w))\}</script></li><li><p><strong>子句变量标准化</strong><br>对子句中的变量进行标准化处理：</p><script type="math/tex; mode=display">\{Q(x),(P(y), S(y, f(y))),(P(w), B(w))\}</script></li></ol><h3 id="3-归结式"><a href="#3-归结式" class="headerlink" title="3. 归结式"></a>3. 归结式</h3><p><strong>归结式</strong>（Resolution Inference Rule）是归结推理的核心。它是一个推导规则，用于从两个子句推导出一个新的子句。归结式的应用基于以下原则：</p><ul><li>选择两个子句，它们至少有一个共同的文字，且在一个子句中为正，在另一个中为反。</li><li>删除这两个子句中的共同文字及其否定。</li><li>合并剩余的文字形成一个新的子句。<h4 id="归结式的表示"><a href="#归结式的表示" class="headerlink" title="归结式的表示"></a>归结式的表示</h4>如果 $ C_1 $ 和 $ C_2 $ 是两个子句，并且它们有一个共同的文字 $ L $ 和它的否定 $ \neg L $，则归结式可以表示为：<script type="math/tex; mode=display">C_1, C_2 \rightarrow C_1 \cup C_2 - \{L, \neg L\}</script>其中 $ C_1 \cup C_2 $ 表示两个子句文字的并集，$ -\{L, \neg L\} $ 表示去除共同的文字和它的否定。</li></ul><p>假设有两个子句：</p><ul><li>$ C_1: A \vee B \vee \neg C $</li><li>$ C_2: \neg A \vee D $<br>它们可以通过归结式来推导出一个新的子句：</li><li>共同文字：$ A $ 和 $ \neg A $</li><li>应用归结式：删除 $ A $ 和 $ \neg A $，得到新的子句 $ B \vee \neg C \vee D $</li></ul><h3 id="4-归结推导"><a href="#4-归结推导" class="headerlink" title="4. 归结推导"></a>4. 归结推导</h3><h4 id="命题逻辑-1"><a href="#命题逻辑-1" class="headerlink" title="命题逻辑"></a>命题逻辑</h4><ol><li>前提转换：将所有前提转换为子句的合取范式。</li><li>归结：应用归结规则，选择两个子句进行归结，生成新的子句。</li><li>重复归结：使用新生成的子句重复归结步骤。</li><li>检查结果：检查是否生成了空子句。如果生成了空子句，则推导成功（说明之前的亲本子句也是假的，一直向前传递）；如果没有生成空子句且无法继续归结，则推导失败。</li></ol><h4 id="谓词逻辑"><a href="#谓词逻辑" class="headerlink" title="谓词逻辑"></a>谓词逻辑</h4><p><strong>谓词逻辑在归结的时候还可能需要进行置换和合一</strong>。</p><h5 id="置换和合一"><a href="#置换和合一" class="headerlink" title="置换和合一"></a>置换和合一</h5><p>置换：可以用$t_1 /v_1$或$v_1=t_1$来表示用$t_1$置换$v_1$​</p><ul><li>$t_i$不允许包含与$v_i$有关的项</li><li>不允许$v_i$循环出现在另一个$t_i$​中作置换</li></ul><p>合一：存在置换$\lambda$使得$\mathrm{F}_{1} \lambda=\mathrm{F}_{2} \lambda$，则$\lambda$称为一个合一。（不唯一）</p><p>最一般合一：定义设  $\sigma$  是公式集$F$的一个合一，如果对任一个合一  $\theta$  都存在一个置换  $\lambda$ , 使得  $\theta=\sigma\circ \lambda$ 则称  $\sigma$​​  是一个最一般合一（MGU）。（唯一）</p><h5 id="最一般合一算法"><a href="#最一般合一算法" class="headerlink" title="最一般合一算法"></a>最一般合一算法</h5><ol><li><p>令 $k=0$, $F_k=F$, $\sigma_k=\varepsilon$。其中 $\varepsilon$ 是空置换。</p></li><li><p>若 $F_k$ 只含一个表达式，则算法停止，$\sigma_k$ 就是最一般合一。</p></li><li><p>找出 $F_k$ 的差异集 $D_k$。</p></li><li><p>若 $D_k$ 中存在元素 $x_k$ 和 $t_k$，其中 $x_k$ 是变元，$t_k$ 是项，且 $x_k$ 不在 $t_k$ 中出现，则置：</p><script type="math/tex; mode=display">\begin{align*}F_{k+1} & = F_k \{ t_k / x_k \} \\\sigma_{k+1} & = \sigma_k \{ t_k / x_k \} \\k & = k + 1\end{align*}</script><p>然后转 (2)。若不存在这样的 $x_k$ 和 $t_k$ 则算法停止。</p></li><li><p>算法终止，$F$​的最一般合一不存在。</p></li></ol><h3 id="5-归结实例"><a href="#5-归结实例" class="headerlink" title="5. 归结实例"></a>5. 归结实例</h3><p>设A、B、C三人中有人从不说真话，也有人从不说假话。某人向这三人分别提出同一个问题：谁是说谎者？以下是他们的回答：</p><ul><li>A答：“B和C都是说谎者”；</li><li>B答：“A和C都是说谎者”；</li><li>C答：“A和B中至少有一个是说谎者”。</li></ul><p>求谁是老实人，谁是说谎者？</p><p>先写出公式：</p><script type="math/tex; mode=display">\begin{array}{l} \mathrm{T}(\mathrm{C}) \vee \mathrm{T}(\mathrm{A}) \vee \mathrm{T}(\mathrm{B}) \\\neg \mathrm{T}(\mathrm{C}) \vee \neg \mathrm{T}(\mathrm{A}) \vee \neg \mathrm{T}(\mathrm{B}) \\\mathrm{T}(\mathrm{A}) \rightarrow \neg \mathrm{T}(\mathrm{B}) \wedge \neg \mathrm{T}(\mathrm{C}) \\\neg \mathrm{T}(\mathrm{A}) \rightarrow \mathrm{T}(\mathrm{B}) \vee \mathrm{T}(\mathrm{C}) \\\mathrm{T}(\mathrm{B}) \rightarrow \neg \mathrm{T}(\mathrm{A}) \wedge \neg \mathrm{T}(\mathrm{C}) \\\neg \mathrm{T}(\mathrm{B}) \rightarrow \mathrm{T}(\mathrm{A}) \vee \mathrm{T}(\mathrm{C}) \\\mathrm{T}(\mathrm{C}) \rightarrow \neg \mathrm{T}(\mathrm{A}) \vee \neg \mathrm{T}(\mathrm{B}) \\\neg \mathrm{T}(\mathrm{C}) \rightarrow \mathrm{T}(\mathrm{A}) \wedge \mathrm{T}(\mathrm{B})\end{array}</script><p>然后，我们把上述回答公式化成子句集S：</p><ol><li>¬T(A) ∨ ¬T(B) （如果A不是老实人，则B不是老实人）</li><li>¬T(A) ∨ ¬T(C) （如果A不是老实人，则C不是老实人）</li><li>T(C) ∨ T(A) ∨ T(B) （C、A、B中至少有一个是老实人）</li><li>¬T(B) ∨ ¬T(C) （如果B不是老实人，则C不是老实人）</li><li>¬T(C) ∨ ¬T(A) ∨ ¬T(B) （C、A、B中至少有一个不是老实人）</li><li>T(A) ∨ T(C) （A或C是老实人）</li><li>T(B) ∨ T(C) （B或C是老实人）</li></ol><p>下面先求谁是老实人。把¬T(x) ∨ Answer(x)并入$S$得到$S_1$。即多一个子句：</p><ol><li>¬T(x) ∨ Answer(x) （如果x不是老实人，则x是答案）</li></ol><p>应用归结原理对$S_1$进行归结：</p><ol><li>¬T(A) ∨ T(C) （子句1和子句7归结）</li><li>T(C) （子句6和子句9归结）</li><li>Answer(C) （子句8和子句10归结）</li></ol><p>所以C是老实人，即C从不说假话。</p><h3 id="6-归结策略"><a href="#6-归结策略" class="headerlink" title="6. 归结策略"></a>6. 归结策略</h3><p>宽度优先、支持集策略、线性输入策略（不完备）、单文字策略（不完备）、祖先过滤策略。</p><p>删除策略：纯文字删除法、重言式删除法、包孕删除法。</p><h2 id="知识图谱"><a href="#知识图谱" class="headerlink" title="知识图谱"></a>知识图谱</h2><p>知识图谱是由一些相互连接的实体及其属性构成的</p><p>三元组是知识图谱的一种通用表示方式：</p><ul><li>(实体1-关系-实体2)：中国-首都-北京</li><li>(实体-属性-属性值)：北京-人口-2069万</li></ul><p><strong>知识库推理包括基于符号的推理和基于统计的推理。</strong></p><h3 id="知识图谱推理：FOIL算法"><a href="#知识图谱推理：FOIL算法" class="headerlink" title="知识图谱推理：FOIL算法"></a>知识图谱推理：FOIL算法</h3><ol><li><p><strong>初始化</strong>：选择一个目标谓词（例如，<code>Father(X, Y)</code>），这是我们想要学习推理规则的谓词。</p></li><li><p><strong>前提约束谓词的选择</strong>：从知识图谱中选择可能作为目标谓词前提约束的谓词（例如，<code>Mother(X, Y)</code>, <code>Sibling(X, Y)</code> 等）。</p></li><li><p><strong>正例和反例的构造</strong>：根据知识图谱中的信息，构造出目标谓词的正例和反例。正例是已知满足目标谓词的实体对，而反例是不满足目标谓词的实体对。</p></li><li><p><strong>信息增益计算</strong>：对于每个候选的前提约束谓词，计算其加入推理规则后的信息增益值。</p><script type="math/tex; mode=display">\text {增益值 }=\widehat{m_{+}} \cdot\left(\log _{2} \frac{\widehat{m_{+}}}{\widehat{m_{+}}+\widehat{m_{-}}}-\log _{2} \frac{m_{+}}{m_{+}+m_{-}}\right)</script></li><li><p><strong>选择最佳前提</strong>：基于信息增益值，选择最佳的前提约束谓词加入到推理规则中。</p></li><li><p><strong>推理规则的构建</strong>：将选定的前提约束谓词与目标谓词结合，形成新的推理规则（例如，<code>Couple(X, Z) -&gt; Father(X, Y)</code>）。将训练样例中与该推理规则不符的样例（正例和反例）去掉。</p></li><li><p><strong>规则评估</strong>：评估新构建的推理规则是否满足所有正例并且不覆盖任何反例。如果满足，规则学习完成，得到最终的推理规则；如果不满足，返回步骤5，选择另一个前提约束谓词并重复过程。</p></li></ol><h1 id="搜索技术"><a href="#搜索技术" class="headerlink" title="搜索技术"></a>搜索技术</h1><h2 id="盲目搜索"><a href="#盲目搜索" class="headerlink" title="盲目搜索"></a>盲目搜索</h2><p>盲目搜索有三个特点：</p><ul><li>这些策略都采用固定的规则来选择下一需要被扩展的状态</li><li>这些规则不会随着要搜索解决的问题的变化而变化</li><li>这些策略不考虑任何与要解决的问题领域相关的信息</li></ul><p>搜索算法的重要特征：</p><ul><li>完备性（Completeness）: 搜索算法是否总能在问题存在解的情况下找到解</li><li>最优性（Optimality）: 当问题中的动作是需要成本时，搜索算法是否总能找到成本最小的解</li><li>时间复杂度（Time complexity）: 搜索算法最多需要探索/生成多少个节点来找到解</li><li>空间复杂度（Space complexity）: 搜索算法最多需要将多少个节点储存在内存中</li></ul><h3 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法"></a>常用的方法</h3><ul><li>深度优先：把当前要扩展的状态的后继状态放在边界的最前面<ul><li>时间复杂度为$O(b^m),m是遍历过程中最长路径的长度$​</li><li>空间复杂度为$O(bm)$，线性复杂度</li><li>不具有完备性和最优性</li></ul></li><li>宽度优先：把当前要扩展的状态的后继状态放在边界的最后<ul><li>时间复杂度为$O(b^{d+1}),d=最短解的个数$</li><li>空间复杂度高</li><li>具有完备性和最优性</li></ul></li><li>一致代价：边界中，按路径的成本升序排列；总是扩展成本最低的那条路径<ul><li>只是将宽度优先算法的队列换成了优先队列</li><li>如果最优解为$C<em>$，则时间和空间复杂度为 $O\left(b^{C </em> / s+1}\right)$</li></ul></li><li>深度受限：深度优先搜索，但是预先限制了搜索的深度 $L$​<ul><li>不具有完备性和最优性</li><li>时间复杂度$O(b^L)$，空间复杂度$O(bL)$</li></ul></li><li><p>迭代加深搜索：一开始设置深度限制为$L = 0$，迭代地增加深度限制，对于每个深度限制都进行深度受限搜索</p><ul><li>具有完备性和最优性</li><li>时间复杂度为$O(b^{d}),d=最短解的个数$​</li><li>空间复杂度$O(bd)$</li></ul></li><li><p>双向搜索：同时进行从初始状态向前的搜索和从目标节点向后搜索，在</p><p>两个搜索在中间相遇时停止搜索</p><ul><li>难点：如何向后搜索</li></ul></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><div class="table-container"><table><thead><tr><th style="text-align:center">标准</th><th style="text-align:left">广度优先搜索</th><th>统一成本搜索</th><th>深度优先搜索</th><th>深度受限搜索</th><th>迭代深化搜索</th><th>双向搜索（如果适用）</th></tr></thead><tbody><tr><td style="text-align:center">是否完整？</td><td style="text-align:left">是 (a)</td><td>是 (a, b)</td><td>否</td><td>否</td><td>是 (a)</td><td>是 (a, d)</td></tr><tr><td style="text-align:center">时间复杂度</td><td style="text-align:left">$O(b^d)$</td><td>$O(b^{1+\lfloor C^*/\varepsilon \rfloor})$</td><td>$O(b^m)$</td><td>$O(b^\ell)$</td><td>$O(b^d)$</td><td>$O(b^{d/2})$</td></tr><tr><td style="text-align:center">空间复杂度</td><td style="text-align:left">$O(b^d)$</td><td>$O(b^{1+\lfloor C^*/\varepsilon \rfloor})$</td><td>$O(bm)$</td><td>$O(b\ell)$</td><td>$O(bd)$</td><td>$O(b^{d/2})$</td></tr><tr><td style="text-align:center">是否最优？</td><td style="text-align:left">是 (c)</td><td>是</td><td>否</td><td>否</td><td>是 (c)</td><td>是 (c, d)</td></tr></tbody></table></div><h3 id="路径检测"><a href="#路径检测" class="headerlink" title="路径检测"></a>路径检测</h3><p>路径检测：当扩展节点$n$来获得子节点$c$时，确保节点$c$不等于到达节点$c$的路径上的任何祖先节点。</p><p>环检测：记录下在之前的搜索过程中扩展过的所有节点，当扩展节点 $n_k$ 获得子节点$c$​时，确保节点c不等于<strong>之前任何扩展过的节点</strong></p><ul><li><p>对于一致代价搜索，使用环检测后仍能找到最优的解</p></li><li><p>对于启发式搜索，这个性质不一定会成立</p></li></ul><h2 id="启发搜索"><a href="#启发搜索" class="headerlink" title="启发搜索"></a>启发搜索</h2><p>常见的启发函数$h(n)$：欧氏距离、曼哈顿距离</p><p>欧氏距离：$\sqrt{(x_1 - y_1)^2 + (x_2 - y_2)^2 + … + (x_n - y_n)^2}$​</p><p>曼哈顿距离：$| x_1 - y_1 | + | x_2 - y_2 | + … + | x_n - y_n |$</p><p>贪心最佳优先搜索：只考虑启发式函数$h(n)$​来对边界上的节点进行排序</p><ul><li>但是，这种做法忽略了从初始状态到达节点𝑛的成本</li><li>其是不完备的</li></ul><h3 id="A搜索"><a href="#A搜索" class="headerlink" title="A搜索"></a>A搜索</h3><p>盲目搜索只考虑了前半部分，能计算出从初始节点走到当前节点的优劣。启发函数则只“估计”了当前节点到最终节点的优劣。</p><p>两者相结合，就是启发式搜索策略，典型的代表是A算法。</p><p>其定义了评价函数$𝑓 (𝑛)$，利用节点对应的$𝑓 (𝑛)$值来对边界上的节点进行排序，并总扩展边界中具有最小$𝑓$​ 值的节点。$g(n)$是到$n$点的实际开销，$h(n)$是$n$点到终点的估计距离。</p><script type="math/tex; mode=display">f(n)=g(n)+h(n)</script><p>算法步骤：</p><ol><li>将初始节点的加入优先队列中。</li><li>取优先队列中$f(n)$最小的结点。</li><li>如果这个结点不是目标结点，则计算其相邻的结点的$f(n)$值，并将这些节点加入优先队列中。转2。</li><li>算法终止。</li></ol><h4 id="启发函数的要求"><a href="#启发函数的要求" class="headerlink" title="启发函数的要求"></a>启发函数的要求</h4><ul><li>如果启发函数的值太大，超出了实际的cost，就无法找到最优解</li><li>如果启发函数的值太小，A搜索就变为了一致代价搜索</li></ul><h3 id="A-搜索"><a href="#A-搜索" class="headerlink" title="A*搜索"></a>A*搜索</h3><p>在A算法中，如果代价函数  $f(n)=g(n)+h(n)$  始终满足  $h(n) \leqq h^{<em>}(n)$  那么该算法就是  $\mathbf{A}^{</em>}$​  算法。</p><p>一个好的$h(n)$​要满足的条件有两个：</p><blockquote><p>$ h(n)=0  时，对于任何  \mathrm{n}  这个启发式函数都是单调的。  \mathrm{A} *  搜索会退化成一致代价搜索$</p></blockquote><ul><li>可采纳性：</li></ul><script type="math/tex; mode=display">\text { 当对于所有节点 } n \text { ，满足 } h(n) \leq h^{*}(n) ， h(n) \text { 是可采纳的 }</script><p>可采纳的启发式函数<strong>低估了当前节点到达目标节点的成本</strong>，使得实际成本最小的最优路径能够被选上。</p><p><mark>可采纳性意味着最优性</mark>：$\text { 最优解一定会在所有成本大于 } C^{*} \text { 的路径之前被扩展到 }$</p><ul><li><p>单调性（一致性）：</p><script type="math/tex; mode=display">对于任意节点  n_{1}  和  n_{2} , 若，h\left(n_{1}\right) \leq c\left(n_{1} \rightarrow n_{2}\right)+h\left(n_{2}\right)，则  h(n)  具有单调性</script><p>如果是大于号，代表过大估计了cost。</p><p>如果具有单调性，则具有下面以下性质：</p><ol><li><p><mark><strong>满足一致性的启发式函数也一定满足可采纳性</strong></mark></p></li><li><p><mark><strong>在进行环检测之后仍然保持最优性</strong></mark></p></li><li>一条路径上的节点的 $f$​ 函数值应该是非递减的</li><li>如果节点  $n_2$  在节点  $n_1$  之后被扩展, 则有$f(n_1) \leq f(n_2)$</li><li>在遍历节点$n$时，所有$𝑓$值小于$𝑓(𝑛)$​​的节点都已经被遍历过了</li><li>A*搜索第一次扩展到某个状态，其已经找到到达该状态的最小成本路径</li></ol><blockquote><p>拓展指的是将该节点相邻的结点加入边界，遍历指的是探索这个结点</p></blockquote></li></ul><p>如果$h(n)$只满足可采纳性但是不满足单调性：</p><ol><li>虽然确实可以找到最优路径，但是搜索过程可能会更久。</li><li><strong>如果启发式函数只有可采纳性，则不一定能在使用了环检测之后仍保持最优性</strong>。若出现到达已遍历过节点但成本更低的路径，则需重新扩展而不能剪枝。</li></ol><h3 id="IDA-算法"><a href="#IDA-算法" class="headerlink" title="IDA*算法"></a>IDA*算法</h3><p>A∗搜索 和宽度优先搜索（BFS）或一致代价搜索（UCS）一样存在潜在的空间复杂度过大的问题。 IDA∗ （迭代加深的A∗搜索）与迭代加深搜索一样用于解决空间复杂度的问题。</p><p>但用于划定界限的不是深度，而是使用 $f$ 值$\left(g+h\right)$​</p><p>当启发函数h为可采纳时， IDA* 是最优的。</p><h3 id="松弛问题"><a href="#松弛问题" class="headerlink" title="松弛问题"></a>松弛问题</h3><p>可以通过放宽原始问题中的一些约束条件来简化问题，从而使得问题更容易解决。</p><blockquote><p>例如，在8数码问题中，原始问题要求将一些乱序的数字块通过滑动操作（只能移动到相邻的空格）恢复到正确的顺序。为了构建启发式函数，我们可以设计一个松弛问题，其中允许我们在任何时候都将一个数字块移动到目标位置，而不需要考虑是否相邻或空位的限制。这样的松弛问题简化了原始问题，因为它忽略了移动的约束条件，从而更容易计算出解决方案的成本。</p></blockquote><p>在松弛问题中，到达某个节点的最优成本可作为原始问题中到达该节点的可采纳的启发式函数值。</p><h2 id="对抗性搜索"><a href="#对抗性搜索" class="headerlink" title="对抗性搜索"></a>对抗性搜索</h2><p>上述的两个搜索算法都假设智能体对环境有完全的控制。</p><p>对抗搜索（博弈）的主要特点：超过两个以上玩家且均可以改变状态。难点在于对方会如何行动。博弈有确定的和随机的、完全的信息和不完全的信息等不同的特征.</p><p>经典的博弈问题就是双人博弈的问题，主要关注扩展形式的博弈：</p><ul><li>两个玩家：游戏的状态或决策可以映射为离散的值，游戏的状态或可以采取的行动的种类是有限的。</li><li>零和博弈：游戏的一方赢了，则另一方输掉了同等的数量</li><li>确定性：没有不确定的因素</li><li>完整的信息：任何层面的状态都是可观察的</li></ul><h3 id="MinMax策略"><a href="#MinMax策略" class="headerlink" title="MinMax策略"></a>MinMax策略</h3><p>对这种扩展式的双人博弈，采用MINMAX搜索。搜索的步骤如下：</p><ul><li>构建完整的博弈树（每个叶子节点都表示终止状态）</li><li>反向传播效益值$U(n)$：<ul><li>叶子节点的$U(n)$是提前定义的</li><li>如果结点$n$是一个$Min$节点：$U(n)=min\{U(c):c是n的子节点\}$</li><li>如果结点$n$是一个$Max$节点：$U(n)=Max\{U(c):c是n的子节点\}$</li></ul></li></ul><p>为了解决博弈树太大的问题，需要使用深度优先搜索算法来实现MinMax。</p><h3 id="Alpha-Beta剪枝"><a href="#Alpha-Beta剪枝" class="headerlink" title="Alpha-Beta剪枝"></a>Alpha-Beta剪枝</h3><p>为了进一步提高MinMax执行效率，可以对没有必要探索的分支进行剪枝。</p><p>Alpha-Beta剪枝的算法如下：（考试要求写的Alpha-Beta算法）</p><ol><li>初始化根节点的$\alpha$值为$-\infty$，$\beta$值为$+\infty$​</li><li>以后序遍历遍历整棵博弈树。<ol><li>每一个子节点都继承父节点的$\alpha$值和$\beta$值</li><li>每当一个子节点的被遍历完或$\alpha \geq \beta$时，停止遍历其并将结点值返回父节点并更新其父节点的结点值和$\alpha$值或$\beta$值。</li><li>MAX结点更新$\alpha$值，MIN结点更新$\beta$值</li></ol></li></ol><p>具体而言，如果一个节点是MIN结点，其的$\alpha$值是继承父节点MAX结点的，$\beta$值是自己更新的。当$\alpha \geq \beta$的时候，因为MIN结点的取值只会越来越小，而父节点（MAX结点）能取到的值已经大于该子节点的值了，所以已经不需要继续遍历了，可以直接返回。</p><p>如果一个节点是MAX结点，其的$\beta$值是继承父节点MIN节点的,$\alpha$值是自己更新的。当$\alpha \geq \beta$​的时候，因为MAX结点的取值只会越来越大，而父节点（MIN结点）能取到的值已经小于该子节点的值了，所以已经不需要继续遍历了，可以直接返回。</p><p>算法的伪代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">SearchGameTree</span>(<span class="params">alpha,beta,root,level</span>):</span><br><span class="line">  <span class="comment">#叶节点则返回节点的值</span></span><br><span class="line">  <span class="keyword">if</span> IsLeaf(root):</span><br><span class="line">    <span class="keyword">return</span> root.value</span><br><span class="line">  </span><br><span class="line">  value=infinity <span class="keyword">if</span> level==<span class="string">&quot;Min&quot;</span> <span class="keyword">else</span> -infinity</span><br><span class="line">  <span class="comment">#其他结点则返回alpha或beta值</span></span><br><span class="line">  <span class="keyword">for</span> child <span class="keyword">in</span> childsOf(root):</span><br><span class="line">    <span class="comment">#每有一个子节点更新，则更新结点的值，并</span></span><br><span class="line">    <span class="keyword">if</span>(level==<span class="string">&quot;Max&quot;</span>):</span><br><span class="line">    value=<span class="built_in">max</span>(value,SearchGameTree(alpha,beta,child,<span class="string">&quot;Min&quot;</span>))</span><br><span class="line">      alpha=<span class="built_in">max</span>(alpha,value)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">    value=<span class="built_in">min</span>(value,SearchGameTree(alpha,beta,child,<span class="string">&quot;Max&quot;</span>))</span><br><span class="line">      beta=<span class="built_in">min</span>(beta,value)</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">if</span>(alpha&gt;=beta):</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure><blockquote><p>一种优化的Alpha-Beta剪枝的算法如下：</p><ol><li>初始化根节点的$\alpha$值为$-\infty$，$\beta$值为$+\infty$​</li><li>以后序遍历遍历整棵博弈树。<ol><li>每一个子节点都继承父节点的$\alpha$值和$\beta$值</li><li>每当一个节点遍历完或其的$\alpha \geq \beta$，如果其是MAX结点返回$\alpha$值，MIN结点返回$\beta$值</li><li>MIN结点只更新$\beta$值，MAX结点只更新$\alpha$​值</li></ol></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">SearchGameTree</span>(<span class="params">alpha,beta,root,level</span>):</span><br><span class="line">  <span class="comment">#叶节点则返回节点的值</span></span><br><span class="line">  <span class="keyword">if</span> IsLeaf(root):</span><br><span class="line">    <span class="keyword">return</span> root.value</span><br><span class="line">  </span><br><span class="line">  <span class="comment">#其他结点则返回alpha或beta值</span></span><br><span class="line">  <span class="keyword">for</span> child <span class="keyword">in</span> childsOf(root):</span><br><span class="line">    <span class="comment">#每有一个子节点更新，则更新结点的alpha-beta值</span></span><br><span class="line">    <span class="keyword">if</span>(level==<span class="string">&quot;Max&quot;</span>):</span><br><span class="line">    alpha=<span class="built_in">max</span>(alpha,SearchGameTree(alpha,beta,child,<span class="string">&quot;Min&quot;</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">    beta=<span class="built_in">min</span>(beta,SearchGameTree(alpha,beta,child,<span class="string">&quot;Max&quot;</span>))</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">if</span>(alpha&gt;=beta):</span><br><span class="line">      <span class="keyword">return</span> alpha <span class="keyword">if</span> level==<span class="string">&quot;Max&quot;</span> <span class="keyword">else</span> beta</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> alpha <span class="keyword">if</span> level==<span class="string">&quot;Max&quot;</span> <span class="keyword">else</span> beta</span><br></pre></td></tr></table></figure></blockquote><h2 id="高级搜索"><a href="#高级搜索" class="headerlink" title="高级搜索"></a>高级搜索</h2><p>如果目标路径与问题解不相关，将考虑各种根本不关心路径（耗散）的算法，其中占据重要地位的就是局部搜索算法。</p><p>局部搜索算法: 局部搜索算法从单独的一个当前状态出发，通常只移动到与之相邻的状态</p><h3 id="爬山算法"><a href="#爬山算法" class="headerlink" title="爬山算法"></a>爬山算法</h3><p>爬山搜索算法是一种局部搜索算法。当它达到一个峰值，没有邻居有更高的值时，它将终止。</p><p>伪代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Hill_Climbing</span>(<span class="params">problem</span>):</span><br><span class="line">  current=problem</span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    neighbor=highest_valued_neighbor(neighbors_of(current));</span><br><span class="line">    <span class="keyword">if</span> neighbor.value&lt;=current.value:</span><br><span class="line">      <span class="keyword">return</span> current</span><br><span class="line">    current=neighbor</span><br></pre></td></tr></table></figure><p>爬山算法存在以下问题：</p><ul><li><strong>局部极大值</strong>：当前状态的邻居状态值都低于当前状态，导致搜索停止。</li><li><strong>高原或山肩</strong>：多个局部极大值连成一片，搜索可能无法找到最优解。</li></ul><p>所以爬山法搜索成功与否在很大程度上取决于状态空间地形图的形状</p><h3 id="模拟退火算法"><a href="#模拟退火算法" class="headerlink" title="模拟退火算法"></a>模拟退火算法</h3><p>模拟退火算法（Simulated Annealing, SA）是一种模拟物理退火过程的优化算法，用于解决NP难题和避免陷入局部最优。</p><h4 id="基本要素"><a href="#基本要素" class="headerlink" title="基本要素"></a>基本要素</h4><p>三函数两准则一初温：</p><ul><li>三函数<ul><li>状态产生函数</li><li>状态接受函数：常使用$min(1,e^{-\frac{\Delta C}{t}})$（会以一定几率接受劣解）</li><li>温度更新函数：常使用$t_{k+1}=\alpha t_k$</li></ul></li><li>两准则<ul><li>内循环终止准则</li><li>外循环终止准则</li></ul></li><li>初始温度</li></ul><h4 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h4><p><img src="/images/人工智能.assets/image-20240407194610480.png" alt="image-20240407194610480"></p><blockquote><p>计算接受概率$P(t_k)=e^{-[\frac{f(j)-f(i)}{t_k}]}$</p></blockquote><h3 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a>遗传算法</h3><h4 id="基本流程-1"><a href="#基本流程-1" class="headerlink" title="基本流程"></a>基本流程</h4><p>遗传算法（Genetic Algorithms, GA）是一类借鉴生物进化机制的随机搜索算法，适用于解决复杂和非线性优化问题。</p><p>伪代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">procedure Simple_GA(<span class="built_in">input</span> GA_parameters):</span><br><span class="line">    <span class="comment"># 输入：遗传算法参数</span></span><br><span class="line">    <span class="comment"># 输出：最佳解决方案</span></span><br><span class="line">    generation = <span class="number">0</span>  <span class="comment"># 代数</span></span><br><span class="line">    Population = initialize_population(GA_parameters)  <span class="comment"># 种群</span></span><br><span class="line">    Population.evaluate_fitness()  <span class="comment"># 评估种群的适应度</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 主循环，直到满足终止条件</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> termination_condition(t, GA_parameters):</span><br><span class="line">        Children = crossover(P_t, GA_parameters)  <span class="comment"># Children：交叉后产生的后代</span></span><br><span class="line">        Children = mutate(Children, GA_parameters)  <span class="comment"># 变异Children</span></span><br><span class="line">        Children.evaluate_fitness()  <span class="comment"># 评估Children的适应度</span></span><br><span class="line">        Population = select_next_generation(Population, Children, GA_parameters)  <span class="comment"># 选择下一代的种群</span></span><br><span class="line">        generation = generation + <span class="number">1</span>  <span class="comment"># 增加代数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 输出最佳解决方案</span></span><br><span class="line">    best_solution = get_best_solution(Population)</span><br><span class="line">    <span class="keyword">return</span> best_solution</span><br></pre></td></tr></table></figure><h4 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a>编码方式</h4><p>为了交叉（<code>crossover</code>）和变异（<code>mutate</code>），需要对问题状态进行编码，常用编码方式有：</p><ul><li>二进制编码</li><li>格雷编码</li><li>实数编码</li><li>多参数映射编码（把每个参数先进行二进制编码得到子串，再把这些子串连成一个完整的染色体）</li></ul><h4 id="适应度计算方式"><a href="#适应度计算方式" class="headerlink" title="适应度计算方式"></a>适应度计算方式</h4><p>若目标函数为<strong>最大化</strong>问题，则$Fitness(f(x))=f(x)$。若目标函数为<strong>最小化</strong>问题，则$Fitness(f(x))=\frac 1 {f(x)}$。</p><p>在遗传算法中，将所有妨碍适应度值高的个体产生，从而影响遗传算法正常工作的问题统称为<strong>欺骗问题</strong>。常见的有过早收敛、停滞现象等。</p><p>解决方法有：</p><ul><li>缩小这些个体的适应度，以降低这些超级个体的竞争力；</li><li>或改变原始适应值对应的比例关系，以提高个体之间的竞争力；</li><li>或对适应度函数值域的某种映射变换。</li></ul><h4 id="选择子代方式"><a href="#选择子代方式" class="headerlink" title="选择子代方式"></a>选择子代方式</h4><p>常见的选择子代方式有；</p><ul><li>适应度比例方法：各个个体被选择的概率和其适应度值成比例。个体$i$被选择的概率为：$\quad p_{s i}=\frac{f_{i}}{\sum_{i=1}^{M} f_{i}}$​</li><li>排序方法：排序选择进入下一代的个体</li><li>赌盘轮转法：按个体的选择概率产生一个轮盘，轮盘每个区的角度与个体的选择概率成比例。产生一个随机数，它落入转盘的哪个区域就选择相应的个体。</li><li>锦标赛选择方法：从群体中随机选择个个体，将其中适应度最高的个体保存到下一代。</li></ul><h4 id="交叉方式"><a href="#交叉方式" class="headerlink" title="交叉方式"></a>交叉方式</h4><p>常见的交叉方式有；</p><ul><li>一点交叉：在个体串中随机设定一个交叉点，实行交叉时，该点前或后的两个个体的部分结构进行互换，并生成两个新的个体。</li><li>两点交叉：随机设置两个交叉点，将两个交叉点之间的码串相互交换。</li></ul><h1 id="贝叶斯分类器"><a href="#贝叶斯分类器" class="headerlink" title="贝叶斯分类器"></a>贝叶斯分类器</h1><h2 id="贝叶斯定理"><a href="#贝叶斯定理" class="headerlink" title="贝叶斯定理"></a>贝叶斯定理</h2><script type="math/tex; mode=display">P(C|A) = \frac{P(A|C)P(C)}{P(A)}</script><p>其中：</p><ul><li>$P(C|A)$  是后验概率，即在已知特征A的情况下，样本属于类别C的概率。</li><li>$P(A|C)$ 是似然概率，即在已知类别C的情况下，观察到特征A的概率。</li><li>$P(C)$  是先验概率，即在没有观察到任何特征之前，样本属于类别C的概率。</li><li>$P(A)$  是边缘概率，即样本具有特征A的概率。</li></ul><h2 id="朴素贝叶斯分类器"><a href="#朴素贝叶斯分类器" class="headerlink" title="朴素贝叶斯分类器"></a>朴素贝叶斯分类器</h2><p>朴素贝叶斯分类器是贝叶斯分类器的一种，它假设所有特征在给定类别的条件下都是相互独立的。</p><script type="math/tex; mode=display">P(A_1, A_2, ..., A_n | C) = P(A_1 | C)P(A_2 | C)...P(A_n | C)</script><p>朴素贝叶斯分类器通过以下方式从数据中估计概率：</p><ul><li>对于离散属性，使用类别下具有特定属性的样本数除以该类别的总样本数。</li><li>对于连续属性，可以离散化，也可以假设属性服从正态分布，并使用数据的均值和方差来估计分布的参数，然后利用这些参数来估计条件概率。</li></ul><h3 id="Laplace-平滑"><a href="#Laplace-平滑" class="headerlink" title="Laplace 平滑"></a>Laplace 平滑</h3><p>为了避免在计算概率时出现零概率的问题，可以使用Laplace平滑（也称为加一平滑）。</p><script type="math/tex; mode=display">P(c) = \frac{N_c + 1}{N + K}</script><p>其中，$N_c$ 是类别c的样本数量，$N$ 是所有样本的总数，$K$ 是类别总数。通过添加1，可以避免计算得到的概率为零的情况。</p><p>对于条件概率，Laplace平滑也可以应用于特征值和类别组合的计数：</p><script type="math/tex; mode=display">P(x|c) = \frac{N_{xc} + 1}{N_c + V}</script><p>其中，$N_{xc}$ 是在类别c下特征x取某个值的样本数量，$V$ 是特征x的所有可能值的数量。同样地，通过添加1，可以避免在训练集中没有出现过的特征值-类别组合导致概率为零的情况。</p><h3 id="分类过程"><a href="#分类过程" class="headerlink" title="分类过程"></a>分类过程</h3><p>给定一个新的样本，贝叶斯分类器通过计算其属于每个类别的后验概率$\frac{P(A|C)P(C)}{P(A)}$，然后选择具有最大后验概率的类别作为预测结果。</p><h2 id="贝叶斯网络"><a href="#贝叶斯网络" class="headerlink" title="贝叶斯网络"></a>贝叶斯网络</h2><p>朴素贝叶斯的局限性在于它要求所有特征在给定类别的条件下都是相互独立的。而贝叶斯网络则考虑了不同特特征之间的依赖关系。</p><p>贝叶斯网络由以下两个部分组成：</p><ul><li>一个有向无环图</li><li>多个条件概率表</li></ul><p>一个贝叶斯网络如下：</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  flowchart LRa((A))--&gt;b((B))--&gt;c((C))--&gt;d((D))--&gt;e((E))  </pre></div><p>为了计算$P(A,B,C,D,E)$，就需要计算$P(E|A,B,C,D)P(D|A,B,C)P(C|A,B)P(B|A)P(A)$。计算这个式子比较复杂。</p><p>而又观察到，在B发生的情况下，A和C是条件独立的（A发不发生都不影响C，因为A只能通过影响B发生的概率影响C，而B已经发生）。所以可以化简$P(C|A,B)$为$P(C|B)$。</p><p>所以将原来的式子化简，可以得到$P(A,B,C,D,E)=P(E|D)P(D|C)P(C|B)P(B|A)P(A)$​，这样就简化了计算。</p><blockquote><p>[!NOTE]</p><p><strong>基于因果关系的变量序列可以获得更加自然紧致的贝叶斯网络结构</strong></p></blockquote><h3 id="三类条件独立"><a href="#三类条件独立" class="headerlink" title="三类条件独立"></a>三类条件独立</h3><p>所以如果能找到条件独立的变量，就能进行化简。条件独立的变量有三类。</p><hr><h4 id="传递"><a href="#传递" class="headerlink" title="传递"></a>传递</h4><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  flowchart LRa((A))--&gt;b((B))--&gt;c((C))  </pre></div><p>在B发生的条件下，A和C条件独立。</p><h4 id="共因"><a href="#共因" class="headerlink" title="共因"></a>共因</h4><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  %%{init:{&#39;flowchart&#39;:{&#39;curve&#39;:&#39;basis&#39;}}}%%flowchart TBa((A))--&gt;b((B)) &amp; c((C))  </pre></div><p>当A发生的条件下，B和C条件独立。</p><blockquote><p>反过来说，如果A还不知道发不发生，B发生了。说明A很有可能发生，进而C有可能发生，因此不独立。</p></blockquote><h4 id="共果"><a href="#共果" class="headerlink" title="共果"></a>共果</h4><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  %%{init:{&#39;flowchart&#39;:{&#39;curve&#39;:&#39;basis&#39;}}}%%flowchart TBa((A)) &amp; b((B)) --&gt; c((C))--&gt;d((D))  </pre></div><p>A和B相互独立。但在C（或者其子节点D）发生的条件下，它们没有条件独立。</p><blockquote><p>如果C（或D）发生了，说明可能是A或B发生了。如果此时A没发生，那说明很可能是B发生了。</p></blockquote><hr><p>判断有向无环图中在特定条件下两个变量是否条件独立，可以看两个变量之间是否有连通的路（这里的路是无方向的）。<strong>连通不独立，独立不联通</strong>。</p><ul><li>传递链路上的事件发生，会阻塞路</li><li>共因的因发生，会阻塞路</li><li>共果的果发生，会连通路</li></ul><p>举一个例子：</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  %%{init:{&#39;flowchart&#39;:{&#39;curve&#39;:&#39;basis&#39;}}}%%flowchart LRa((A))--&gt;b((B))--&gt;c((C))--&gt;d((D))e((E))--&gt;a &amp; cb &amp; g((G))--&gt;f((F))  </pre></div><p>当C发生的时候，C阻塞了传递链路，因此E和D独立</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  %%{init:{&#39;flowchart&#39;:{&#39;curve&#39;:&#39;basis&#39;}}}%%flowchart LRclassDef red fill:#f96;a((A))-.-&gt;b((B))-.-&gt;c((C))--&gt;d((D))e((E))-.-&gt;a &amp; cb &amp; g((G))--&gt;f((F))class c red;  </pre></div><p>当E和B发生的时候，E和B产生阻塞，因此A和D独立</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  %%{init:{&#39;flowchart&#39;:{&#39;curve&#39;:&#39;basis&#39;}}}%%flowchart LRclassDef red fill:#f96;a((A))-.-&gt;b((B))--&gt;c((C))--&gt;d((D))e((E))-.-&gt;ae((E))--&gt;cb &amp; g((G))--&gt;f((F))class b red;class e red;  </pre></div><p>当F发生的时候，F是一个通路，因此B和G不独立</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  %%{init:{&#39;flowchart&#39;:{&#39;curve&#39;:&#39;basis&#39;}}}%%flowchart LRclassDef green fill:#90ee90;a((A))--&gt;b((B))--&gt;c((C))--&gt;d((D))e((E))--&gt;ae((E))--&gt;cb &amp; g((G))&#x3D;&#x3D;&gt;f((F))class f green;  </pre></div><h3 id="分类过程-1"><a href="#分类过程-1" class="headerlink" title="分类过程"></a>分类过程</h3><p>给定一个新的样本，贝叶斯网络也是通过计算其属于每个类别的后验概率$\frac{P(A|C)P(C)}{P(A)}$，然后选择具有最大后验概率的类别作为预测结果。只不过此时$P(A)$和$P(A|C)$​​在展开的时候用的不是相互独立而是条件独立去计算。</p><p>比如，在下面这个贝叶斯网络。计算$P(+b,+j,+m)$的时候就用条件独立代替了相互独立。</p><p><img src="/images/人工智能.assets/image-20240420102307131.png" alt="image-20240420102307131"></p><script type="math/tex; mode=display">\begin{aligned}P(+b,+j,+m)= & P(+b) P(+e) P(+a \mid+b,+e) P(+j \mid+a) P(+m \mid+a)+ \\& P(+b) P(+e) P(-a \mid+b,+e) P(+j \mid-a) P(+m \mid-a)+ \\& P(+b) P(-e) P(+a \mid+b,-e) P(+j \mid+a) P(+m \mid+a)+ \\& P(+b) P(-e) P(-a \mid+b,-e) P(+j \mid-a) P(+m \mid-a)\end{aligned}</script><h4 id="变量消除"><a href="#变量消除" class="headerlink" title="变量消除"></a>变量消除</h4><p>如果直接枚举所有的情况，变量还是太多。这时候，就可以消除一些变量。</p><h5 id="合并因子"><a href="#合并因子" class="headerlink" title="合并因子"></a>合并因子</h5><p><img src="/images/人工智能.assets/image-20240420103339493.png" alt="image-20240420103339493"></p><p>比如果知道了$P(R)$和$P(T|R)$的概率表，就可以将其变为$P(R,T)$的概率表。</p><blockquote><p>如果$P(R)*P(T|R)$在一串式子中，那么两个乘积就可以变为一个乘积。</p></blockquote><h5 id="消除因子"><a href="#消除因子" class="headerlink" title="消除因子"></a>消除因子</h5><p><img src="/images/人工智能.assets/image-20240420105425960.png" alt="image-20240420105425960"></p><p>如果知道$R$不会以$-R$或$+R$的形式出现在表达式当中。就可以将这个因子消除。将$P(R,T)$的概率表变为$P(T)$的概率表。</p><h5 id="已知取值变量"><a href="#已知取值变量" class="headerlink" title="已知取值变量"></a>已知取值变量</h5><p><img src="/images/人工智能.assets/image-20240420110635467.png" alt="image-20240420110635467"></p><p>如果一个变量的取值已知，那它也可以被消除。</p><h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><h2 id="机器学习基础"><a href="#机器学习基础" class="headerlink" title="机器学习基础"></a>机器学习基础</h2><p>机器学习基本类别有两种：</p><ul><li>回归：函数的输出是一个数值</li><li>分类：函数的输出是一个类别</li></ul><p>这两类的目的都是找到一个最优的函数，而寻找函数的三个步骤是：</p><ol><li>确定候选函数的集合（Model）</li><li>确定「评价函数好坏」的标准（Loss）</li><li>找出最好的函数（最优化Optimization）</li></ol><p>根据学习模式对机器学习进行分类，机器学习可以分为：</p><ul><li>监督学习</li><li>无监督学习</li><li>半监督学习</li><li>强化学习</li></ul><h2 id="聚类算法"><a href="#聚类算法" class="headerlink" title="聚类算法"></a>聚类算法</h2><p>聚类算法目的是找到几个组，使组内相似度较高，而组间相似度较少。</p><p>聚类（clustering）是由一系列集群（clusters）组成的集合。其的类别有：</p><ul><li><p>分割式聚类：将数据对象划分为不重叠的子集(簇) ，这样每个数据对象都恰好在一个子集中。</p><p><img src="/images/人工智能.assets/image-20240427160359945.png" alt="image-20240427160359945"></p></li><li><p>阶层式聚类：一组嵌套的集群，组织成一个层次树。</p><p><img src="/images/人工智能.assets/image-20240427160411657.png" alt="image-20240427160411657"></p></li></ul><h3 id="K-means算法"><a href="#K-means算法" class="headerlink" title="K-means算法"></a>K-means算法</h3><p>算法流程：</p><ol><li>选择K个点作为初始的聚类中心</li><li>计算所有点到K个初始聚类中心的距离，每个点被划分到距离最近的聚类中心的那个簇。</li><li>重新计算每个簇的聚类中心（求坐标的平均值）</li><li>如果聚类中心没有变化，则算法结束，否则转2</li></ol><p>初始的聚类中心通常是随机选择的。也是因为随机选择，所以可能聚类效果并不好。</p><h4 id="算法评价方法"><a href="#算法评价方法" class="headerlink" title="算法评价方法"></a>算法评价方法</h4><p>可以用SSE（Sum of Squared Errors误差平方和）来评估聚类的质量。SSE 越小，表示数据点在聚类内部越紧密，聚类效果越好。</p><script type="math/tex; mode=display">SSE=∑_{i=1}^{K} ∑_{x∈C_i} d^2(m_i, x)</script><p>其中，K 是聚类的数量，$C_i$ 是第 $i$ 个聚类，$m_i$ 是第 $i$ 个聚类的中心点，$x$ 是聚类 $C_i$ 中的一个数据点，$d(m_i, x)$ 是点 $x$ 到中心点 $m_i$ 的距离。</p><h4 id="K-means算法的改进"><a href="#K-means算法的改进" class="headerlink" title="K-means算法的改进"></a>K-means算法的改进</h4><h5 id="K-means"><a href="#K-means" class="headerlink" title="K-means++"></a>K-means++</h5><p>改进了初始选择聚类中心的方法：</p><ol><li>第一个聚类中心随机选取</li><li>以每个点分别为$\frac{D\left(x^{\prime}\right)^{2}}{\sum_{x \in \mathcal{X}} D(x)^{2}}$的概率选择下一个聚类中心。$D(x)$是数据点$x$到已经选择的最近的聚类中心的距离，也就是会选尽量与已选择的聚类中心较远的点作为聚类中心。</li><li>如果没选择到K个聚类中心则转2。</li></ol><p>但其也有缺点：每次选择聚类中心都需要遍历一次剩下的点，一共K次遍历。</p><h5 id="K-means-1"><a href="#K-means-1" class="headerlink" title="K-means||"></a>K-means||</h5><p>K-means||也叫稳定的K-means。</p><p>主要思路在于改变每次遍历时的取样策略，并非按照 kmeans++ 那样每次遍历只取样一个样本，而是每次遍历取样 $O(k)$ 个样本，重复该取样过程大约 $O(logn)$ 次，共得到 $O(klogn)$ 个样本点组成的集合。然后再聚类这 $O(klogn)$ 个点成 $k$ 个点，最后将这 $k$ 个点作为初始聚类中心。</p><h3 id="DBSCAN"><a href="#DBSCAN" class="headerlink" title="DBSCAN"></a>DBSCAN</h3><p>DBSCAN是一个基于密度的算法。（密度：指定半径内的点数）</p><p>给定$Eps$作为半径、$MinPts$作为最小的点的数量，其将点分为三类：</p><ul><li><p>核心点（core point）：在$Eps$（半径范围内）就有超过指定数量（$MinPts$）的点。</p></li><li><p>边界点（border point）：在$Eps$内少于$MinPts$个点，但它位于一个核心点的邻域内</p></li><li>噪声点（noise point）：其他点。</li></ul><p>算法流程：</p><ol><li>对所有点进行标记，核心点、边界点或噪声点</li><li>消除所有的噪声点。</li><li>对于所有核心点，如果在$Eps$范围内，则它们之间添加一条边。</li><li>将相连的核心点组成不同的簇</li><li>将每个边界点分配到它相关的核心点的某个簇中</li></ol><p>但其对$Eps$和$MinPts$的选择有要求。</p><h3 id="评价方法"><a href="#评价方法" class="headerlink" title="评价方法"></a>评价方法</h3><ol><li>相似度矩阵</li><li>SSE（凝聚度）和SSB（分离度）两者之和是定值（TSS）<ul><li>$SSE = \sum_{i=1}^{k} \sum_{x \in C_i} | x - m_i |^2$ </li><li>$SSB = \sum_{i=1}^{k} n_i | m_i - m |^2$。其中，$k$ 是聚类的数量，$n_i$ 是第 $i$个聚类中的点的数量，$m_i$ 是第 $i$个聚类的中心点，$m$是所有数据点的中心点（通常是所有点的均值）。</li></ul></li></ol><h3 id="谱聚类"><a href="#谱聚类" class="headerlink" title="谱聚类"></a>谱聚类</h3><p><a href="https://zhuanlan.zhihu.com/p/29849122">参考文章</a></p><p>谱聚类(Spectral Clustering)要求比K-means少，结果比K-means好，复杂度比K-means小。</p><h4 id="图的一些概念"><a href="#图的一些概念" class="headerlink" title="图的一些概念"></a>图的一些概念</h4><ul><li><p>$|A|$：图中顶点的个数</p></li><li><p>$vol(A)$：图的所有顶点的度数之和</p></li><li><p>相似度矩阵：</p><ul><li>$A(i, j)=0。如果i,j不相邻$</li><li>$A(i, j)=s(i, j)。如果i,j相邻$</li></ul></li><li><p>度矩阵：</p><ul><li><p>$D(i, j)=0。如果i\neq j$</p></li><li><p>$D(i,j)=d(v_i)。如果i=j相邻$​</p><blockquote><p>对角线上是每个节点自己的度</p></blockquote></li></ul></li><li><p>拉普拉斯矩阵：$L=D-W$​，其有如下性质：</p><blockquote><p>D是度矩阵，W是邻接矩阵</p></blockquote><ul><li><p><strong>对称性</strong>：由于D和W都是对称的，L也是对称的。</p></li><li><p><strong>半正定性</strong>：拉普拉斯矩阵的所有 eigenvalues（特征值）都是非负的，这意味着对于所有的向量$x，x^T L x ≥ 0$。</p></li><li><p><strong>最小特征值</strong>：拉普拉斯矩阵的最小特征值是0，对应的特征向量是所有元素都是1的常数向量。</p></li><li><p><strong>特征值排序</strong>：拉普拉斯矩阵的特征值可以按照非递减的顺序排列：$0 = λ_1 ≤ λ_2 ≤ … ≤ λ_N$。</p></li><li><p><strong>特征值之间的差距</strong>：最小非零特征值$λ_2$被称为谱隙（spectral gap），它度量了图结构的扩展性。</p></li><li><p><strong>特征向量的正交性</strong>：拉普拉斯矩阵有一组完整的正交特征向量。</p></li><li><p>对于任意的向量有</p><script type="math/tex; mode=display">f^{T} L f=\frac{1}{2} \sum_{i, j=1}^{n} w_{i j}\left(f_{i}-f_{j}\right)^{2}</script></li></ul></li></ul><h4 id="图分割"><a href="#图分割" class="headerlink" title="图分割"></a>图分割</h4><p>图分割要求把一个图分割为几个子图，并使得那些被切断的边的权值之和最小。</p><p><img src="/images/人工智能.assets/image-20240429203641057.png" alt="image-20240429203641057"></p><h5 id="无向图切图"><a href="#无向图切图" class="headerlink" title="无向图切图"></a>无向图切图</h5><h6 id="Cut"><a href="#Cut" class="headerlink" title="Cut"></a>Cut</h6><p>对于任意两个子图点的集合 $A, B \subset V$，其中 $A \cap B=\emptyset$，定义 $A$ 和 $B$ 之间的切图权重为：</p><script type="math/tex; mode=display">W(A, B)=\sum_{i \in A, j \in B} w_{ij}</script><p>其中 $w_{ij}$ 表示点 $i$ 和点 $j$ 之间的权重。</p><p>对于 $k$ 个子图点的集合 $A_{1}, A_{2}, \ldots A_{k}$，定义切图Cut为：</p><script type="math/tex; mode=display">\operatorname{cut}(A_{1}, A_{2}, \ldots A_{k})=\frac{1}{2} \sum_{i=1}^{k} W\left(A_{i}, \bar{A}_{i}\right)</script><p>这里，$\bar{A}_{i}$ 表示 $A_{i}$ 的补集，即除 $A_{i}$ 子集外其他 $V$ 的子集的并集。</p><blockquote><p>一个好的切图，要让切图Cut最小</p></blockquote><p>但是仅使用这个Cut定义，会得到不够好的切图：</p><p><img src="/images/人工智能.assets/image-20240429211438139.png" alt="image-20240429211438139"></p><h6 id="RatioCut"><a href="#RatioCut" class="headerlink" title="RatioCut"></a>RatioCut</h6><p>RatioCut切图对每个切图，不光考虑最小化$\operatorname{cut}(A_{1}, A_{2}, \ldots A_{k})$ ，它还同时考虑最大化每个子图点的个数：</p><script type="math/tex; mode=display">\operatorname{RatioCut}\left(A_{1}, A_{2}, \ldots A_{k}\right)=\frac{1}{2} \sum_{i=1}^{k} \frac{W\left(A_{i}, \bar{A}_{i}\right)}{\left|A_{i}\right|}</script><p>而要最小化RatioCut，需要引入指示向量：$h_{j} \in\left\{h_{1}, h_{2}, . . h_{k}\right\} ,j=1,2, \ldots k$，它是一个$n$维向量。$h_{ij}$定义为：</p><script type="math/tex; mode=display">h_{i j}=\left\{\begin{array}{ll}0 & v_{i} \notin A_{j} \\\frac{1}{\sqrt{\left|A_{j}\right|}} & v_{i} \in A_{j}\end{array}\right.</script><p>意思是如果点$v_i$属于$A_j$集合，则$h_{ij}=\frac{1}{\sqrt{\left|A_{j}\right|}}$。</p><p>有了指示向量后，RatioCut就可以化简为：</p><script type="math/tex; mode=display">\operatorname{RatioCut}\left(A_{1}, A_{2}, \ldots A_{k}\right)=\sum_{i=1}^{k} h_{i}^{T} L h_{i}=\sum_{i=1}^{k}\left(H^{T} L H\right)_{i i}=\operatorname{tr}\left(H^{T} L H\right)</script><p>要最小化RatioCut，需要优化每一个$h_{i}^{T} L h_{i}$。其中 $h$ 是单位正交基， $L$ 为对称矩阵，此时 $h^T L h$ 的最大值为 $L$ 的最大特征值，最小值是 $L$ 的最小特征值。</p><p>所以通过找到$L$的最小的$k$个特征值，可以得到对应的$k$个特征向量，这$k$个特征向量组成一个$n\cdot k$维度的矩阵，即为$H$​。</p><p>由于在使用维度规约的时候损失了少量信息，导致得到的优化后的指示向量$h$对应的$H$现在不能完全指示各样本的归属。</p><blockquote><p>如果没有损失信息，$h_{ij}=\frac{1}{\sqrt{\left|A_{j}\right|}}$代表点$v_i$属于$A_j$集合。</p></blockquote><p>因此一般在得到$n\cdot k$维度的矩阵$H$后还需要对每一行进行一次传统的聚类，比如使用K-Means聚类。</p><h6 id="NCut"><a href="#NCut" class="headerlink" title="NCut"></a>NCut</h6><p>Ncut切图和RatioCut切图很类似，但是把RatioCut的分母 $|A_i|$ 换成 $\text{vol}(A_i)$：</p><script type="math/tex; mode=display">\operatorname{NCut}\left(A_{1}, A_{2}, \ldots A_{k}\right)=\frac{1}{2} \sum_{i=1}^{k} \frac{W\left(A_{i}, \bar{A}_{i}\right)}{\operatorname{vol}\left(A_{i}\right)}</script><p>同样选取指示向量：</p><script type="math/tex; mode=display">h_{i j}=\left\{\begin{array}{ll}0 & v_{i} \notin A_{j} \\\frac{1}{\sqrt{\operatorname{vol}\left(A_{j}\right)}} & v_{i} \in A_{j}\end{array}\right.</script><p>将优化目标转换为：</p><script type="math/tex; mode=display">\operatorname{NCut}\left(A_{1}, A_{2}, \ldots A_{k}\right)=\sum_{i=1}^{k} h_{i}^{T} L h_{i}=\sum_{i=1}^{k}\left(H^{T} L H\right)_{i i}=\operatorname{tr}\left(H^{T} L H\right)</script><p>此时$H$中的指示向量$h$并不是标准正交基，而是$H^{T} D H=I$，所以在RatioCut里面的降维思想不能直接用。</p><p>令$H=D^{-1 / 2} F$,则$H^{T} L H=F^{T} D^{-1 / 2} L D^{-1 / 2} F$。此时$H^{T} D H=F^{T} F=I$。可以继续按照RatioCut的方法降维，求出 $D^{-1/2} L D^{-1/2}$ 的最小的前$k$个特征值，然后求出对应的特征向量，并标准化，得到最后的特征矩阵 $F$，最后对 $F$ 进行一次传统的聚类（比如K-Means）即可。</p><h4 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h4><h5 id="构建图"><a href="#构建图" class="headerlink" title="构建图"></a>构建图</h5><p>用于构建图的方法有：</p><ul><li>全连接图</li><li>$r$-邻接图（结点与以其为圆心，$r$为半径内的其他结点相连）</li><li>$k$-最近邻图（结点与最近的$k$个邻居相连）</li></ul><h5 id="构建拉普拉斯矩阵"><a href="#构建拉普拉斯矩阵" class="headerlink" title="构建拉普拉斯矩阵"></a>构建拉普拉斯矩阵</h5><p>根据相似矩阵$S$构建邻接矩阵$W$，构建度矩阵$D$。然后计算拉普拉斯矩阵$L=D-W$​。</p><h5 id="根据切图方法计算特征值"><a href="#根据切图方法计算特征值" class="headerlink" title="根据切图方法计算特征值"></a>根据切图方法计算特征值</h5><p>以下$k_1$为降维后的维度</p><ul><li>RatioCut计算 $L$ 的最小的前$k_1$个特征值</li><li>NCut计算$D^{-1/2} L D^{-1/2}$ 的最小的前$k_1$​​个特征值</li></ul><h5 id="计算特征矩阵"><a href="#计算特征矩阵" class="headerlink" title="计算特征矩阵"></a>计算特征矩阵</h5><p>将各自对应的特征向量$f$组成的矩阵按行标准化，最终组成$n\cdot k_1$维的特征矩阵$F$​。</p><h5 id="对特征矩阵聚类"><a href="#对特征矩阵聚类" class="headerlink" title="对特征矩阵聚类"></a>对特征矩阵聚类</h5><p>对$F$中的每一行作为一个$k_1$维的样本，共$n$个样本，用输入的聚类方法（比如K-means）进行聚类，聚类维数为$k_2$（划分为$k_2$个簇）。</p><p>最后得到簇划分 $C(c_1, c_2, \ldots, c_{k})$。</p><h2 id="SVM-不考"><a href="#SVM-不考" class="headerlink" title="SVM(不考)"></a>SVM(不考)</h2><blockquote><p><a href="https://blog.csdn.net/v_JULY_v/article/details/7624837">参考文章</a>，这篇博客写的非常透彻，强推。</p></blockquote><p>SVM（Support Vector Machine）也称支持向量机，是一个将数据单元表示在多维空间中，然后对这个空间做划分的算法。而支持向量指的是支撑平面上把两类类别划分开来的超平面的向量点。</p><p>SVM在解决<strong>小样本</strong>、<strong>非线性</strong>、及<strong>高维模式识别</strong>中有很多优势。</p><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><h4 id="结构风险"><a href="#结构风险" class="headerlink" title="结构风险"></a>结构风险</h4><p>结构风险 = 经验风险 + 置信风险。</p><ul><li><strong>经验风险</strong>：在给定样本上的误差。</li><li><strong>置信风险</strong>：在多大程度上可以信任分类器在未知样本上分类的结果。</li></ul><p>SVM 的目标是最小化结构风险，而不再只是优化经验风险，否则会过拟合。</p><h4 id="几何间隔"><a href="#几何间隔" class="headerlink" title="几何间隔"></a>几何间隔</h4><p>几何间隔，指的是点到超平面距离（不同于点到平面的距离）：</p><script type="math/tex; mode=display">\tilde{\gamma}=y \gamma=\frac{\hat{\gamma}}{\|w\|}=\frac{y\left(w^{T} x+b\right)}{\|w\|}</script><p>其中，超平面为$y=\omega^T x+b$。$\hat y$是函数间隔。</p><h3 id="SVM目标函数"><a href="#SVM目标函数" class="headerlink" title="SVM目标函数"></a>SVM目标函数</h3><h4 id="原问题"><a href="#原问题" class="headerlink" title="原问题"></a>原问题</h4><p> 对一个数据点进行分类，当超平面离数据点的“间隔”越大，分类的效果就越好。所以对所有点来说，应该使得平面恰好夹在两类点的中间。</p><p><img src="/images/人工智能.assets/image-20240516101840880.png" alt="image-20240516101840880"></p><p>所以就需要使最靠近分界线的点离分界线的几何间隔最大。所以目标函数定义为：</p><script type="math/tex; mode=display">\max \tilde{\gamma}\\约束条件:y_{i}\left(w^{T} x_{i}+b\right)=\hat{\gamma}_{i} \geq \hat{\gamma}, \quad i=1, \ldots, n</script><p>如果令函数间隔 $\hat{\gamma}$​ 等于1（方便推导和优化，且这样做对目标函数的优化没有影响）。则目标问题变为：</p><script type="math/tex; mode=display">\max \frac{1}{\|w\|} \\约束条件:y_{i}\left(w^{T} x_{i}+b\right) \geq 1, i=1, \ldots, n</script><p>由于求 $\frac{1}{|w|}$ 的最大值相当于求 $\frac{1}{2}|w|^{2}$ 的最小值，所以可以将目标函数转换为：</p><script type="math/tex; mode=display">\min \frac{1}{2}\|w\|^{2} \\约束条件:y_{i}\left(w^{T} x_{i}+b\right) \geq 1, i=1, \ldots, n</script><p> 因为原问题的目标函数是二次的，约束条件是线性的，所以它是一个凸二次规划问题，有全局的最优解。</p><h4 id="对偶问题"><a href="#对偶问题" class="headerlink" title="对偶问题"></a>对偶问题</h4><h5 id="拉格朗日变换"><a href="#拉格朗日变换" class="headerlink" title="拉格朗日变换"></a>拉格朗日变换</h5><p>由于原问题的特殊结构，还可以通过<strong>拉格朗日对偶性</strong>变换为对对偶问题的求解。</p><p>通过给每一个约束条件加上一个拉格朗日乘子$\alpha$，可以将约束条件融合到目标函数里去，从而将约束优化问题转换为无约束优化问题：</p><script type="math/tex; mode=display">\mathcal{L}(w, b, \alpha)=\frac{1}{2}\|w\|^{2}-\sum_{i=1}^{n} \alpha_{i}\left(y_{i}\left(w^{T} x_{i}+b\right)-1\right)</script><p>并令：</p><script type="math/tex; mode=display">\theta(w)=\max _{\alpha_{i} \geq 0} \mathcal{L}(w, b, \alpha)</script><p>而当所有约束条件都满足时，则最优值为$\theta(w)=\frac{1}{2}|w|^{2}$。因此，在要求约束条件得到满足的情况下最小化 $\frac{1}{2}|w|^{2}$，实际上等价于直接最小化 $\theta(w)$。</p><p>用$p^*$​表示问题的最优值，则目标函数变为：</p><script type="math/tex; mode=display">\min _{w, b} \theta(w)=\min _{w, b} \max _{\alpha_{i} \geq 0} \mathcal{L}(w, b, \alpha)=p^{*}</script><p>这个问题的求解较为困难（因为有参数$w、b$，并且$a_i$​​还受到不等式约束）。<strong>所以把最小和最大的位置交换一下，得到原问题的对偶问题：</strong></p><script type="math/tex; mode=display">\max _{\alpha_{i} \geq 0} \min _{w, b} \mathcal{L}(w, b, \alpha)=d^{*}</script><p>$d^{<em>}$是新问题的最优解，并且有$d^{</em>}\leq p^{<em>}$。并且因为Slater 条件成立，所以$d^{</em>}\leq p^{*}$​可以取等号。</p><h5 id="求解对偶问题"><a href="#求解对偶问题" class="headerlink" title="求解对偶问题"></a>求解对偶问题</h5><p>首先固定 $\alpha$ ，要让 $\mathcal{L}$ 关于 $w$ 和 $b$ 最小化 我们分别对 $w, b$ 求偏导数，即令 $\partial \mathcal{L} / \partial w$ 和 $\partial \mathcal{L} / \partial b$ 等于零。 可以得到：</p><script type="math/tex; mode=display">\begin{array}{l}\frac{\partial \mathcal{L}}{\partial w}=0 \Rightarrow w=\sum_{i=1}^{n} \alpha_{i} y_{i} x_{i} \\\frac{\partial \mathcal{L}}{\partial b}=0 \Rightarrow \sum_{i=1}^{n} \alpha_{i} y_{i}=0\end{array}</script><p>将以上结果代入之前的$\mathcal{L}$，化简后得到：</p><script type="math/tex; mode=display">\mathcal{L}(w, b, \alpha)==\sum_{i=1}^{n} \alpha_{i}-\frac{1}{2} \sum_{i, j=1}^{n} \alpha_{i} \alpha_{j} y_{i} y_{j} x_{i}^{T} x_{j}</script><p>此时的拉格朗日函数只包含了一个变量$\alpha_i$。然后就可以根据下式求解出$\alpha_i$：</p><script type="math/tex; mode=display">\begin{array}{l}&\max _{\alpha} \sum_{i=1}^{n} \alpha_{i}-\frac{1}{2} \sum_{i, j=1}^{n} \alpha_{i} \alpha_{j} y_{j} y_{j} x_{i}^{T} x_{j} \\\text {约束条件:}&\alpha_{i} \geq 0, i=1, \ldots, n \\&\sum_{i=1}^{n} \alpha_{i} y=0\end{array}</script><p>然后就可以根据$w=\sum_{i=1}^{m} \alpha_{i} y^{(i)} x^{(i)}$，求解出$\omega$；根据$b^{<em>}=-\frac{\max _{i: y^{(i)}=-1} w^{</em> T} x^{(i)}+\min _{i: y^{(i)}=1} w^{* T} x^{(i)}}{2}$求解出$b$​。最终得出分离超平面和分类决策函数。</p><h3 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h3><h4 id="SVM分类过程"><a href="#SVM分类过程" class="headerlink" title="SVM分类过程"></a>SVM分类过程</h4><p>对于一个数据点 $x$ 进行分类, 实际上是通过把 $x$ 带入到 $f(x)=w^{T} x+b$ 算出结果然后根据其正负号来进行类别划分的。</p><p>而$w=\sum_{i=1}^{m} \alpha_{i} y^{(i)} x^{(i)}$，所以分类函数为：</p><script type="math/tex; mode=display">\begin{aligned}f(x) & =\left(\sum_{i=1}^{n} \alpha_{i} y_{i} x_{i}\right)^{T} x+b \\& =\sum_{i=1}^{n} \alpha_{i} y_{i}\left\langle x_{i}, x\right\rangle+b\end{aligned}</script><p><strong>那么，对于新点$x$​的预测，只需要计算它与训练数据点的内积即可。</strong></p><blockquote><p>事实上，所有非支持向量所对应的系数$\alpha$​都是等于零的，因此对于新点的内积计算实际上只要针对少量的“支持向量”，而不是所有的训练数据。</p></blockquote><h4 id="核函数的作用"><a href="#核函数的作用" class="headerlink" title="核函数的作用"></a>核函数的作用</h4><p>对于非线性的情况，SVM 的处理方法是选择一个核函数 $κ(⋅,⋅)$​ ，通过将数据映射到高维空间，来解决在原始空间中线性不可分的问题。</p><blockquote><p>而在核函数之前，如果用原始的方法，在用线性学习器学习一个非线性关系时，需要选择一个非线性特征集，并且将数据写成新的表达形式，这等价于应用一个固定的非线性映射，将数据映射到特征空间，在特征空间中使用线性学习器。</p></blockquote><p>如果将原来的分类函数</p><script type="math/tex; mode=display">f(x)=\sum_{i=1}^{n} \alpha_{i} y_{i}\left\langle x_{i}, x\right\rangle+b</script><p>直接找一个映射 $\phi(\cdot)$，把原来的数据映射到新空间中, 再做线性SVM。就会有维度爆炸的问题。</p><script type="math/tex; mode=display">f(x)=\sum_{i=1}^{n} \alpha_{i} y_{i}\left\langle\phi\left(x_{i}\right), \phi(x)\right\rangle+b</script><p>所以相比映射到高维空间中，然后再根据内积的公式进行计算。核函数选择另一个方式：<strong>直接在原来的低维空间中进行计算，而不需要显式地写出映射后的结果</strong>。</p><h4 id="核函数的定义"><a href="#核函数的定义" class="headerlink" title="核函数的定义"></a>核函数的定义</h4><p>核函数是一个函数 $\kappa$，对所有 $x, z \in X$，满足 $\kappa(\mathbf{x}, \mathbf{z}) = \langle\phi(\mathbf{x}) \cdot \phi(\mathbf{z})\rangle$，这里 $\phi$ 是从 $X$ 到内积特征空间 $F$ 的映射。</p><p><strong>计算两个向量在隐式映射过后的空间中的内积的函数叫做核函数。</strong>它事先在低维上进行计算，而将实质上的分类效果表现在了高维上，也就避免了直接在高维空间中的复杂计算。</p><h4 id="常见的核函数"><a href="#常见的核函数" class="headerlink" title="常见的核函数"></a>常见的核函数</h4><p>常见的核函数有：</p><ul><li>多项式核：$\kappa(x, y)=\left(\alpha x^{T} y+c\right)^{d}$</li><li>高斯核：$\kappa(x, y)=\exp \left(-\gamma|x-y|^{2}\right)$</li><li>线性核 ：$\kappa\left(x, y\right)=\left\langle x, y\right\rangle$</li></ul><h3 id="松弛变量处理离群点"><a href="#松弛变量处理离群点" class="headerlink" title="松弛变量处理离群点"></a>松弛变量处理离群点</h3><p>虽然通过映射 $\phi(\cdot)$ 将原始数据映射到高维空间之后，能够线性分隔的概率大大增加，但是对于某些情况还是很难处理。</p><p>例如一些离群点（偏离正常位置很远的数据点），会对SVM模型造成很大影响。</p><blockquote><p>因为超平面本身就是只有少数几个支持向量组成的，如果这些支持向量里又存在离群点的话，其影响就很大了</p></blockquote><p>通过向约束条件中加入松弛变量$\xi_{i}$：</p><script type="math/tex; mode=display">y_{i}\left(w^{T} x_{i}+b\right) \geq 1-\xi_{i}, \quad i=1, \ldots, n</script><p>允许数据点离超平面更近。并且向目标函数中加入惩罚项，限制这种松弛：</p><script type="math/tex; mode=display">\min \frac{1}{2}\|w\|^{2}+C \sum_{i=1}^{n} \xi_{i}</script><p>再进行上面的一系列操作（拉格朗日对偶、核函数），就可以得到一个完整的、可以处理线性和非线性、并能容忍噪音和离群点的支持向量机。</p><h2 id="人工神经网络"><a href="#人工神经网络" class="headerlink" title="人工神经网络"></a>人工神经网络</h2><h3 id="发展史"><a href="#发展史" class="headerlink" title="发展史"></a>发展史</h3><h4 id="MP模型"><a href="#MP模型" class="headerlink" title="MP模型"></a>MP模型</h4><p>最初提出的神经网络模型是MP（McCulloch-Pitts ）模型，其的权重是预先设置的：</p><p><img src="/images/人工智能.assets/image-20240427181414661.png" alt="image-20240427181414661"></p><h4 id="感知机"><a href="#感知机" class="headerlink" title="感知机"></a>感知机</h4><p>之后发展出了感知机，也被称为单层神经网络，其的权重是通过训练得到的，训练法则为：</p><script type="math/tex; mode=display">\begin{array}{l}W_{t} \leftarrow W_{t}+\Delta W_{t} \\\Delta W_{t}=\eta(y-\hat{y}) \boldsymbol{a}\end{array}</script><p>其$f$神经元中执行的是线性运算$\mathbf{z}=g(\boldsymbol{W} \times \boldsymbol{a})$，所以只能执行线性分类。</p><p><img src="/images/人工智能.assets/image-20240427181445146.png" alt="image-20240427181445146"></p><p>也是因为神经元执行的是线性运算，所以<strong>感知机只能做简单的线性分类任务</strong>，无法解决XOR（异或）问题。</p><h4 id="多层感知机"><a href="#多层感知机" class="headerlink" title="多层感知机"></a>多层感知机</h4><p>之后就发展出了多层感知机（多层的神经网络）</p><p><img src="/images/人工智能.assets/image-20240427181959937.png" alt="image-20240427181959937"></p><p>并且其不再使用sgn函数做激活函数，而是使用sigmoid函数</p><p><img src="/images/人工智能.assets/image-20240427182037505.png" alt="image-20240427182037505"></p><p>关键在于: 从输入层到隐藏层时，<strong>数据在激活函数作用下发生了空间变换</strong></p><p>其通过前向传播和反向传播来进行训练，前向传播为了计算当前参数下的误差，反向传播是为了根据误差调整参数。反向传播常用的算法是梯度下降。</p><h3 id="神经网络基础"><a href="#神经网络基础" class="headerlink" title="神经网络基础"></a>神经网络基础</h3><p>神经网络的一个神经元的基础操作是对输入$x$执行：</p><ol><li>线性运算：$z=W x+b$​</li><li>通过激活函数：$y=\sigma(z)$</li></ol><p>从功能角度讲，神经网络就是多层的<strong>特征提取</strong>加上<strong>线性分类</strong>。</p><h3 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h3><h4 id="卷积操作"><a href="#卷积操作" class="headerlink" title="卷积操作"></a>卷积操作</h4><p>人观测图片的特点： <strong>① 局部特征影响大 ② 重要位置常变化</strong> <strong>③ 采样压缩也没差</strong></p><p>根据前两个特点特点，设计卷积神经网络，就设计出了可以移动的卷积核。</p><p><img src="/images/人工智能.assets/image-20240511163332296.png" alt="image-20240511163332296"></p><p>卷积过程中的步长（stride）指的是卷积核在输入图像上每次移动的像素数量；卷积操作前的填充（padding）操作，指的是在输入图像的边界周围添加额外的像素。</p><h5 id="卷积维度公式"><a href="#卷积维度公式" class="headerlink" title="卷积维度公式"></a>卷积维度公式</h5><p>假设图片尺寸为 $n_{h} \times n_{w} \times n_{c}$，卷积核为 $f \times f \times n_{c}$，步长 $s$，填充 $p$​。其中：</p><ul><li><p>$n_{h}$ 是高度，$n_{w}$ 是宽度，$n_{c}$ 是深度（通道数）</p></li><li><p>$f$ 是卷积核的尺寸，$n_{c}$​ 是卷积核的深度（与输入图片的深度相同）</p></li></ul><p><img src="/images/人工智能.assets/image-20240511164341249.png" alt="image-20240511164341249"></p><p>那么特征图（卷积层输出）维度公式：</p><script type="math/tex; mode=display">\begin{array}{l}\text { 高度 } h=\left\lfloor\frac{n_{h}-f+2 p}{s}+1\right\rfloor \\\text { 宽度 } w=\left\lfloor\frac{n_{w}-f+2 p}{s}+1\right\rfloor \\\text { 宽度 } k=K\end{array}</script><h4 id="池化"><a href="#池化" class="headerlink" title="池化"></a>池化</h4><p>池化操作将特征图划分为若干个子区域，并对每个子区域进行统计汇总。</p><p>池化操作的方式可以有很多种，比如最大池化、平均池化等。</p><ul><li>最大池化：选取每个子区域内的最大值作为输出</li><li>平均池化：计算每个子区域内的平均值作为输出</li></ul><h3 id="循环神经网络"><a href="#循环神经网络" class="headerlink" title="循环神经网络"></a>循环神经网络</h3><p>循环神经网络要解决的槽填充问题：</p><p>I would like to arrive <u>Guangzhou</u> on <u>May</u>.</p><p>CNN和普通的神经网络都没有记忆功能，而RNN可以记忆。</p><p><img src="/images/人工智能.assets/image-20240511183046525.png" alt="image-20240511183046525"></p><h3 id="长短期记忆网络（LSTM）"><a href="#长短期记忆网络（LSTM）" class="headerlink" title="长短期记忆网络（LSTM）"></a>长短期记忆网络（LSTM）</h3><p>RNN网络没有遗忘的功能，所以以往的所有输入都会影响输出，而LSTM加入了遗忘功能。它用特殊的神经元代替了普通神经网络中的神经元。</p><p><img src="/images/人工智能.assets/image-20240511183946686.png" alt="image-20240511183946686"></p><p>这个特殊的神经网络有三个门：</p><ul><li>输出门：控制是否输出</li><li>遗忘门：选择是否遗忘</li><li>输入门：控制是否输入</li></ul><p>一份输入要充当这三个门的信号和神经元的输入。</p><p>缺点是参数量大了，训练和计算时间也长了。</p><h2 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h2><p>强化学习是通过与环境进行交互、试错，从而学会做出一系列好的决策。</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  %%{init:{&#39;flowchart&#39;:{&#39;curve&#39;:&#39;basis&#39;}}}%%flowchart TDa[Agent]--Action--&gt;e[Environment]e--Reward--&gt;ae--state--&gt;a  </pre></div><p>强化学习的特殊之处在于：</p><ul><li><p>环境刚开始是未知的</p></li><li><p>智能体要与环境互动</p></li></ul><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="随机性的两个来源"><a href="#随机性的两个来源" class="headerlink" title="随机性的两个来源"></a>随机性的两个来源</h4><p>随机性的来源有两个：</p><ul><li><p>给定状态，智能体的行为具有随机性，由策略来决定。</p><script type="math/tex; mode=display">A \sim \pi(\cdot \mid s)</script><p><strong>其中$\pi$是策略</strong>，$\pi(a_1|s)$代表的是在状态$s$下选择行为$a_1$的概率。</p></li><li><p>状态的转移也具有随机性，由状态转移函数来决定。</p><script type="math/tex; mode=display">S^{\prime} \sim p(\cdot \mid s, a)</script><p>其中$S’$是次态，$p(\cdot \mid s, a)$指的是在状态$s$和行为$a$下转移到次态$S’$的概率。</p></li></ul><h4 id="AI玩游戏"><a href="#AI玩游戏" class="headerlink" title="AI玩游戏"></a>AI玩游戏</h4><p>可以将AI玩游戏的过程看成一个由状态（$s$）、行为（$a$）和奖励（$r$）组成的序列。</p><p><img src="/images/人工智能.assets/image-20240523192432446.png" alt="image-20240523192432446"></p><p>一个完整的交互序列（episode），就是从初始状态开始到最终状态结束。一个好的策略能让最后<strong>积累</strong>的奖励最大。</p><h4 id="回报"><a href="#回报" class="headerlink" title="回报"></a>回报</h4><p>回报（Return）即累计未来奖励。假设$R_t$是$t$时刻的奖励，那么回报$U_t$的定义为：</p><script type="math/tex; mode=display">U_{\mathrm{t}}=R_{\mathrm{t}}+\gamma R_{\mathrm{t}+1}+\gamma^{2} R_{\mathrm{t}+2}+\cdots+\gamma^{\mathrm{n}-\mathrm{t}} R_{\mathrm{n}} .</script><p>因为在$t$时刻，未来的奖励具有随机性，所以$U_t$也具有随机性。并且因为奖励的越早，奖励越具有吸引力。所以随着获得奖励所需的时间越久，其的价值也越低，在公式中以衰减因子$\gamma$表示。</p><h4 id="价值函数"><a href="#价值函数" class="headerlink" title="价值函数"></a>价值函数</h4><h5 id="行为价值函数"><a href="#行为价值函数" class="headerlink" title="行为价值函数"></a>行为价值函数</h5><p>行为价值函数$Q_\pi(s,a)$是针对策略$\pi$而言的。其的定义如下：</p><script type="math/tex; mode=display">Q_{\pi}\left(s_{t}, a_{t}\right)=\mathbb{E}\left[U_{t} \mid S_{t}=s_{t}, A_{t}=a_{t}\right]</script><p>$Q_{\pi}\left(s_{t}, a_{t}\right)$代表的是，在$\pi$策略下，在$s_t$的状态下、选择行动$a_t$，获得回报的期望。</p><p>可以定义最优行为价值函数为：</p><script type="math/tex; mode=display">Q^{\star}\left(s_{t}, a_{t}\right)=\max _{\pi} Q_{\pi}\left(s_{t}, a_{t}\right)</script><p>其代表着在$s_t$的状态下、选择行动$a_t$，在所有策略中，能获得的最大的回报的期望。</p><h5 id="状态价值函数"><a href="#状态价值函数" class="headerlink" title="状态价值函数"></a>状态价值函数</h5><p>状态价值函数$V_\pi(s_t)$的定义如下：</p><script type="math/tex; mode=display">V_{\pi}\left(s_{t}\right)=\mathbb{E}_{A}\left[Q_{\pi}\left(s_{t}, A\right)\right]=\sum_{a} \pi\left(a \mid s_{t}\right) \cdot Q_{\pi}\left(s_{t}, a\right)</script><p>$V_\pi(s_t)$代表的是，在$\pi$策略下，在$s_t$的状态下，获得回报的期望。</p><blockquote><p>状态价值函数和行为无关。</p></blockquote><p>可以用$\mathbb{E}_{S}\left[V_{\pi}(S)\right]$来衡量策略$\pi$有多棒。</p><h3 id="进行强化学习"><a href="#进行强化学习" class="headerlink" title="进行强化学习"></a>进行强化学习</h3><p>单智能体强化学习问题可以形式化定义为马尔可夫决策过程（MDP）六元组：</p><script type="math/tex; mode=display">\left(S, A, R, T, P_{0}, \gamma\right)</script><p>其中：</p><ul><li>$S$ 表示状态空间，</li><li>$\boldsymbol{A}$ 表示动作空间，</li><li>$R=R(S, \boldsymbol{a})$ 表示奖励函数，</li><li>$T: S \times \boldsymbol{A} \times S \rightarrow [\mathbf{0}, \mathbf{1}]$ 表示状态转移函数，</li><li>$\boldsymbol{P}_{0}$ 表示初始状态分布，</li><li>$\gamma$ 是折扣因子。</li></ul><p>强化学习的学习目标: <strong>找到能最大化累计奖励的策略$\pi$​</strong>。</p><hr><p>有这几种学习方式：</p><ul><li>基于价值（Value-based learning）：它的目标是学习出一个价值函数，这个价值函数能够评估给定状态下采取某个动作的期望回报。</li><li>基于策略（Policy-based learning）：它直接学习策略函数，这个策略函数能够根据当前状态直接输出一个动作分布或确定性的动作。</li><li>Actor-critic方法：它结合了Value-based learning和Policy-based learning两种方法的优点。</li></ul><h4 id="基于价值学习"><a href="#基于价值学习" class="headerlink" title="基于价值学习"></a>基于价值学习</h4><p>基于价值学习需要近似$Q^{\star}\left(s_{t}, a_{t}\right)$，那么就可以知道每一个行动$a_t$能带来多大的价值。近似所用的方法是DQN（Deep Q-Network），即深度Q网络。</p><p><img src="/images/人工智能.assets/image-20240524094425103.png" alt="image-20240524094425103"></p><p>但在训练DQN的时候，和训练任何一个神经网络一样，需要给出标签值，也就是$a_t$实际的价值是多少，然后与预测出来的$a_t$的价值去求损失。但直接求实际价值又太慢了（需要完整的完成一个迭代），所以就有了TD学习（Temporal Difference (TD) Learning）。</p><p>TD学习将实际价值近似为「当前奖励+下一步预测值」，只关注时间差分，即当前时间步的预测值和下一时间步的预测值之间的差异。数学的表达形式为：</p><script type="math/tex; mode=display">Q\left(s_{t}, a_{t} ; \mathbf{w}\right) \approx r_{t}+\gamma \cdot Q\left(s_{t+1}, a_{t+1} ; \mathbf{w}\right)</script><p>右边就是「当前奖励+下一步预测值」（还乘了损失因子），用其来近似实际价值。然后就可以用这个近似的实际价值当做神经网络的标签，去进行训练。</p><h4 id="基于策略学习"><a href="#基于策略学习" class="headerlink" title="基于策略学习"></a>基于策略学习</h4><p>基于策略学习和基于价值学习的方法类似，它也是用神经网络去近似策略函数$\pi(a|s)$。</p><p><img src="/images/人工智能.assets/image-20240524102021748.png" alt="image-20240524102021748"></p><p>它的目的是优化${\theta}$使得$J({\theta})=\mathbb{E}_{S}[V(S ; {\theta})]$​最大。也就是让所有状态下采取给定策略得到的回报期望最大。这个回报期望可以通过跑完全程得到，也可以通过训练一个神经网络去预测这个回报。</p><p>在优化的过程中，梯度为让$V(s;\theta)$上升最快的方向。神经网络中是减去梯度，来梯度下降，这里是加上梯度来梯度上升。</p><h4 id="Actor-Critic方法"><a href="#Actor-Critic方法" class="headerlink" title="Actor-Critic方法"></a>Actor-Critic方法</h4><p>Actor-Critic方法结合了基于价值学习和基于策略学习两者，它有一个actor作为策略网络，有一个critic作为价值网络：</p><ul><li>actor：用神经网络$\pi(a|s ; \theta)$去近似$\pi(a|s)$。</li><li>critic：用神经网络$q(s,a;\omega)$去近似$Q_\pi(s,a)$</li></ul><p>在训练过程中两者是一起训练的，训练的过程如下：</p><ol><li>观察到状态$s_t$</li><li>actor根据自己的$\pi(a|s ; \theta)$网络给出的概率，（按概率）随机选一个动作执行。</li><li>观察到下一个状态$s_{t+1}$并得到奖励$r_t$</li><li>用TD学习更新critic网络中的参数$\omega$</li><li>用策略梯度（需要critic预测回报），更新critic网络中的$\theta$</li></ol><p>在训练全部完成后，以后做出决策就只需要策略网络（actor），而不需要critic。</p><h3 id="AlphaGo"><a href="#AlphaGo" class="headerlink" title="AlphaGo"></a>AlphaGo</h3><p>AlphaGo的训练有三步：</p><ol><li>通过behavior cloning初始化策略网络</li><li>通过策略梯度训练策略网络。</li><li>训练完策略网络后，用策略网络去训练一个价值网络。</li></ol><p>最后通过蒙特卡洛树搜索的方法使用策略网络和价值网络。</p><h4 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h4><h5 id="behavior-cloning"><a href="#behavior-cloning" class="headerlink" title="behavior cloning"></a>behavior cloning</h5><p>因为如果直接进行强化学习，速度太慢。所以首先根据人类已有的棋局资料，去训练策略网络。</p><p><img src="/images/人工智能.assets/image-20240529171455797.png" alt="image-20240529171455797"></p><h5 id="训练策略网络"><a href="#训练策略网络" class="headerlink" title="训练策略网络"></a>训练策略网络</h5><p>因为仅仅用behavior cloning还会有很多状况考虑不到。所以还需要训练策略网络。在训练策略网络的过程中，通过跑完全程得到回报期望。即如果最终赢了，这局所有的行为的分数都+1；如果平局则这句行为的分数不变；如果最终输了，这局所有行为的分数都-1。</p><h5 id="训练价值网络"><a href="#训练价值网络" class="headerlink" title="训练价值网络"></a>训练价值网络</h5><p>仅用策略网络，有可能出现在某一步走错之后步步错。所以还需要用策略网络训练一个价值网络（与之前不同，这里是拟合状态价值函数）。之后就可以结合策略网络和价值网络进行决策。</p><h4 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h4><p>运行的过程用到了蒙特卡洛树搜索的方法。其有四步：</p><ul><li><p>Selection：</p><ul><li><p>设当前状态为$s_t$</p></li><li><p>对所有有效的行为$a$，计算行为$a$的得分：</p><script type="math/tex; mode=display">\operatorname{score}(a)=Q(a)+\eta * \frac{\pi\left(a | s_{t} ; \theta\right)}{1+N(a)}</script><p>其中$Q(a)$是蒙特卡洛树计算的行为得分，$\pi\left(a | s_{t}\right)$是策略网络给出的行为概率，$N(a)$是到目前为止一共选择了行为$a$​多少次。</p></li><li><p>选择具有最大$\operatorname{score}(a)$的行为$a_t$​。</p><p><img src="/images/人工智能.assets/image-20240529191318821.png" alt="image-20240529191318821"></p></li></ul></li><li><p>Expansion：</p><ul><li><p>选择了$a_t$行为，所以到达了$s_{t+1}$的状态。</p></li><li><p>然后通过策略网络，不断自我博弈，直到走到游戏结束</p><p><img src="/images/人工智能.assets/image-20240529191348057.png" alt="image-20240529191348057"></p></li></ul></li><li><p>Evaluation：</p><ul><li>计算：<script type="math/tex; mode=display">V(s_{t+1})=\frac{1}{2} v\left(s_{t+1} ; w\right)+\frac{1}{2} r_{T}</script>其中$v\left(s_{\mathrm{t}+1} ; {w}\right)$是价值网络的评分；如果赢了，则$r_T=1$，如果输了，则$r_T=-1$。</li></ul></li><li><p>Backup：</p><ul><li><p>重复上面三步，每一个$a_t$都会记录一系列的$V_i$​值</p><p><img src="/images/人工智能.assets/image-20240529191705228.png" alt="image-20240529191705228"></p></li><li><p>更新</p><script type="math/tex; mode=display">\left.Q\left(a_{\mathrm{t}}\right)=\text { mean(the recorded } V^{\prime} s\right)</script></li></ul></li></ul><p>最后，选择被蒙特卡洛树搜索选择最多次的$a_t$作为下一个行为。</p><h1 id="数据降维"><a href="#数据降维" class="headerlink" title="数据降维"></a>数据降维</h1><p>大多数机器学习和数据挖掘技术可能对高维数据无效。并且高维的数据会比较稀疏，有可能导致数据“过于”可分，导致过拟合。而且高维度中用距离来衡量样本相似性的方法会渐渐失效。</p><p>数据降维不仅可以帮助可视化，还可以进行数据压缩和噪声过滤。</p><p>数据降维的方法主要有特征选择与特征降维。它们的区别如下：</p><ol><li>特征选择：减少特征的数量，只使用选中的特征。</li><li>特征降维：所有原始特征都用于计算，但最终模型使用的是这些原始特征的线性或非线性组合，以降低数据的维度</li></ol><p>特征降维的方法有：</p><ul><li>无监督学习：<ul><li>截断奇异值分解（Truncated Singular Value Decomposition, SVD）</li><li>独立成分分析（Independent Component Analysis, ICA）</li><li>主成分分析（Principal Component Analysis, PCA）</li><li>局部线性嵌入（Locally Linear Embedding, LLE）</li><li>拉普拉斯特征映射（Laplacian Eigenmaps, LE）</li></ul></li><li>有监督学习：<ul><li>线性判别分析（Linear Discriminant Analysis, LDA）</li><li>典型相关分析（Canonical Correlation Analysis, CCA）</li></ul></li></ul><h2 id="PCA主成分分析"><a href="#PCA主成分分析" class="headerlink" title="PCA主成分分析"></a>PCA主成分分析</h2><p>主成分分析（PCA）是一种常用于降维的数据分析技术，通过<strong>将原始高维数据投影到新的低维空间来保留数据中的主要信息</strong>。以下是PCA的算法流程：</p><ol><li><p><strong>数据标准化</strong>：将数据标准化为均值为0，方差为1的形式。这一步是为了消除不同特征之间量纲不一致的影响。</p><script type="math/tex; mode=display">\text{Standardized data} = \frac{X - \mu}{\sigma}</script></li><li><p><strong>计算协方差矩阵</strong>：计算标准化数据的协方差矩阵，以了解特征之间的相关性。</p><script type="math/tex; mode=display">\mathbf{C} = \frac{1}{n-1} \mathbf{X}^T \mathbf{X}</script><p>其中，$\mathbf{X}$ 是标准化后的数据矩阵， $n$​是样本数量。</p><blockquote><p>如果两个变量的协方差为正，则表示一个变量的增加通常与另一个变量的增加相联系；如果协方差为负，则表示一个变量的增加通常与另一个变量的减少相联系。</p></blockquote></li><li><p><strong>特征值分解</strong>：对协方差矩阵进行特征值分解，得到特征值和特征向量。</p><script type="math/tex; mode=display">\mathbf{C} \mathbf{v} = \lambda \mathbf{v}</script><p>其中，$\lambda$ 为特征值，$\mathbf{v}$ 为对应的特征向量。</p></li><li><p><strong>选择主成分</strong>：根据特征值的大小选择前k个最大的特征值对应的特征向量，作为主成分。</p></li><li><p><strong>转换数据</strong>：将原始数据投影到选定的特征向量空间，得到降维后的数据。</p><script type="math/tex; mode=display">\mathbf{X}_{\text{new}} = \mathbf{X} \mathbf{W}</script><p>其中， $\mathbf{W}$ 是由选定的特征向量构成的矩阵。</p></li></ol><h3 id="示例：应用PCA进行降维"><a href="#示例：应用PCA进行降维" class="headerlink" title="示例：应用PCA进行降维"></a>示例：应用PCA进行降维</h3><p>假设我们有一个三维数据集如下：</p><div class="table-container"><table><thead><tr><th>特征1</th><th>特征2</th><th>特征3</th></tr></thead><tbody><tr><td>2.5</td><td>2.4</td><td>3.5</td></tr><tr><td>0.5</td><td>0.7</td><td>1.2</td></tr><tr><td>2.2</td><td>2.9</td><td>3.1</td></tr><tr><td>1.9</td><td>2.2</td><td>2.9</td></tr><tr><td>3.1</td><td>3.0</td><td>3.6</td></tr><tr><td>2.3</td><td>2.7</td><td>3.4</td></tr><tr><td>2.0</td><td>1.6</td><td>2.7</td></tr><tr><td>1.0</td><td>1.1</td><td>1.2</td></tr><tr><td>1.5</td><td>1.6</td><td>1.9</td></tr><tr><td>1.1</td><td>0.9</td><td>1.5</td></tr></tbody></table></div><h4 id="1-数据标准化"><a href="#1-数据标准化" class="headerlink" title="1. 数据标准化"></a>1. 数据标准化</h4><p>将每个特征标准化，标准化后的数据：</p><script type="math/tex; mode=display">\begin{bmatrix}0.926 & 0.610 & 1.096 \\-1.759 & -1.507 & -1.425 \\0.524 & 1.233 & 0.658 \\0.121 & 0.361 & 0.439 \\1.732 & 1.357 & 1.206 \\0.658 & 0.984 & 0.987 \\0.255 & -0.386 & 0.219 \\-1.087 & -1.009 & -1.425 \\-0.416 & -0.386 & -0.658 \\-0.953 & -1.258 & -1.096 \\\end{bmatrix}</script><h4 id="2-计算协方差矩阵"><a href="#2-计算协方差矩阵" class="headerlink" title="2. 计算协方差矩阵"></a>2. 计算协方差矩阵</h4><p>计算标准化数据的协方差矩阵：</p><script type="math/tex; mode=display">\begin{bmatrix}1.111 & 1.029 & 1.065 \\1.029 & 1.111 & 1.042 \\1.065 & 1.042 & 1.111 \\\end{bmatrix}</script><h4 id="3-特征值分解"><a href="#3-特征值分解" class="headerlink" title="3. 特征值分解"></a>3. 特征值分解</h4><p>对协方差矩阵进行特征值分解，得到特征值和特征向量。</p><p>特征值：</p><script type="math/tex; mode=display">\begin{bmatrix}3.201, & 0.045, & 0.087\end{bmatrix}</script><p>特征向量：</p><script type="math/tex; mode=display">\begin{bmatrix}-0.578 & -0.619 & 0.531 \\-0.574 & -0.155 & -0.804 \\-0.580 & 0.770 & 0.266 \\\end{bmatrix}</script><h4 id="4-选择主成分"><a href="#4-选择主成分" class="headerlink" title="4. 选择主成分"></a>4. 选择主成分</h4><p>选择前两个最大的特征值对应的特征向量作为主成分，则选择的特征向量：</p><script type="math/tex; mode=display">\begin{bmatrix}-0.578 & 0.531 \\-0.574 & -0.804 \\-0.580 & 0.266 \\\end{bmatrix}</script><h4 id="5-转换数据"><a href="#5-转换数据" class="headerlink" title="5. 转换数据"></a>5. 转换数据</h4><p>将原始数据投影到选定的特征向量空间，转换后的数据：</p><script type="math/tex; mode=display">\begin{bmatrix}-1.522 & 0.293 \\2.708 & -0.102 \\-1.392 & -0.538 \\-0.532 & -0.110 \\-2.479 & 0.149 \\-1.517 & -0.179 \\-0.053 & 0.504 \\2.034 & -0.146 \\0.844 & -0.086 \\1.909 & 0.213 \\\end{bmatrix}</script><p>这样，我们将原始的三维数据降维成了二维数据，同时保留了数据中的主要信息。</p><h2 id="SVD（奇异值分解）"><a href="#SVD（奇异值分解）" class="headerlink" title="SVD（奇异值分解）"></a>SVD（奇异值分解）</h2><p>SVD是另一种数据降维的技术。算法流程如下：</p><ol><li><p><strong>构建矩阵</strong>：构建一个数据矩阵 $A$，其中包含要处理的所有数据。</p></li><li><p><strong>奇异值分解</strong>：对矩阵 $A$ 进行奇异值分解，得到三个矩阵 $U$、$\Sigma$ 和 $V^T$。</p><script type="math/tex; mode=display">A = U \Sigma V^T</script><p>其中，$ U $是$ m \times m $的正交矩阵，$ \Sigma $是$ m \times n $的对角矩阵，$ V^T $是$ n \times n $​ 的正交矩阵。</p></li><li><p><strong>选择主成分</strong>：根据奇异值的大小选择前k个最大的奇异值，构建低秩近似。</p></li><li><p><strong>重构矩阵</strong>：利用选择的奇异值和对应的左右奇异向量重构原始矩阵的低秩近似。</p><script type="math/tex; mode=display">A_k = U_k \Sigma_k V_k^T</script><p>其中，$ U_k $和$ V_k $分别是$ U $和$ V $的前 k 列，$ \Sigma_k $是$ \Sigma $ 的前 k 个奇异值构成的对角矩阵。</p></li></ol><p>给定一个向量$q$，可以通过$qV$得到它属于哪一个类。</p><h3 id="示例：Latent-Semantic-Indexing（潜在语义索引）"><a href="#示例：Latent-Semantic-Indexing（潜在语义索引）" class="headerlink" title="示例：Latent Semantic Indexing（潜在语义索引）"></a>示例：Latent Semantic Indexing（潜在语义索引）</h3><div class="table-container"><table><thead><tr><th>document\term</th><th>data</th><th>information</th><th>retrieval</th><th>brain</th><th>lung</th></tr></thead><tbody><tr><td>CS-TR1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td></tr><tr><td>CS-TR2</td><td>2</td><td>2</td><td>2</td><td>0</td><td>0</td></tr><tr><td>CS-TR3</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td></tr><tr><td>CS-TR4</td><td>5</td><td>5</td><td>5</td><td>0</td><td>0</td></tr><tr><td>MED-TR1</td><td>0</td><td>0</td><td>0</td><td>2</td><td>2</td></tr><tr><td>MED-TR2</td><td>0</td><td>0</td><td>0</td><td>3</td><td>3</td></tr><tr><td>MED-TR3</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td></tr></tbody></table></div><p>假设有这样的一个数据集，其中第一列是文档类型（CS代表计算机，MED代表医学）。可以看到data、information、retrieval这些词只在计算机类的文档中出现；而brain、lung只在医学类的文档中出现。</p><h4 id="1-构建矩阵"><a href="#1-构建矩阵" class="headerlink" title="1. 构建矩阵"></a>1. 构建矩阵</h4><p>构建文档-词项矩阵  $A$ ：</p><script type="math/tex; mode=display">A = \begin{bmatrix}1 & 1 & 1 & 0 & 0 \\2 & 2 & 2 & 0 & 0 \\1 & 1 & 1 & 0 & 0 \\5 & 5 & 5 & 0 & 0 \\0 & 0 & 0 & 2 & 2 \\0 & 0 & 0 & 3 & 3 \\0 & 0 & 0 & 1 & 1 \\\end{bmatrix}</script><h4 id="2-奇异值分解"><a href="#2-奇异值分解" class="headerlink" title="2. 奇异值分解"></a>2. 奇异值分解</h4><p>对矩阵$A$进行奇异值分解，可以得到三个矩阵为：</p><script type="math/tex; mode=display">U \Sigma V^T=\left[\begin{array}{ll}0.18 & 0 \\0.36 & 0 \\0.18 & 0 \\0.90 & 0 \\0 & 0.53 \\0 & 0.80 \\0 & 0.27\end{array}\right]\times\left[\begin{array}{ll}9.64 & 0 \\0 & 5.29\end{array}\right]\times\left[\begin{array}{ll}0.58 & 0.58 & 0.58 & 0 & 0 \\0 & 0 & 0 & 0.71 & 0.71\end{array}\right]</script><p>在这里其实就可以发现矩阵$U$前三行第一列不为0的刚好对应的是CS类的。而第二列不为0的刚好对应的是MED类的。而$V$也同理。</p><h4 id="3-选择主成分"><a href="#3-选择主成分" class="headerlink" title="3. 选择主成分"></a>3. 选择主成分</h4><p>这里可以看到为9.64的奇异值较大，所以就选择其。</p><h4 id="4-重构矩阵"><a href="#4-重构矩阵" class="headerlink" title="4. 重构矩阵"></a>4. 重构矩阵</h4><p>然后将$\Sigma$矩阵中的没有选择的奇异值改为0。也就是：</p><script type="math/tex; mode=display">\left[\begin{array}{ll}9.64 & 0 \\0 & 5.29\end{array}\right]\rightarrow\left[\begin{array}{ll}9.64 & 0 \\0 & 0\end{array}\right]</script><p>然后再重新计算$A_k$。</p><script type="math/tex; mode=display">A_k=\left[\begin{array}{ll}0.18 & 0 \\0.36 & 0 \\0.18 & 0 \\0.90 & 0 \\0 & 0.53 \\0 & 0.80 \\0 & 0.27\end{array}\right]\times\left[\begin{array}{ll}9.64 & 0 \\0 & 0\end{array}\right]\times\left[\begin{array}{ll}0.58 & 0.58 & 0.58 & 0 & 0 \\0 & 0 & 0 & 0.71 & 0.71\end{array}\right]</script><p>得到低秩近似$A_k$：</p><script type="math/tex; mode=display">A_k=\left[\begin{array}{lllll}1 & 1 & 1 & 0 & 0 \\2 & 2 & 2 & 0 & 0 \\1 & 1 & 1 & 0 & 0 \\5 & 5 & 5 & 0 & 0 \\0 & 0 & 0 & 0 & 0 \\0 & 0 & 0 & 0 & 0 \\0 & 0 & 0 & 0 & 0\end{array}\right]</script><h2 id="LDA（线性判别法）"><a href="#LDA（线性判别法）" class="headerlink" title="LDA（线性判别法）"></a>LDA（线性判别法）</h2><p>LDA的原理是，将带上标签的数据（点），通过投影的方法，投影到维度更低的空间中，使得投影后的点，会形成按类别区分，一簇一簇的情况，相同类别的点，将会在投影后的空间中更接近。</p><p><img src="/images/人工智能.assets/image-20240612113559022.png" alt="image-20240612113559022"></p><p>参考文章：<a href="https://www.cnblogs.com/LeftNotEasy/archive/2011/01/08/lda-and-pca-machine-learning.html">https://www.cnblogs.com/LeftNotEasy/archive/2011/01/08/lda-and-pca-machine-learning.html</a></p><h2 id="LLE（局部线性嵌入）"><a href="#LLE（局部线性嵌入）" class="headerlink" title="LLE（局部线性嵌入）"></a>LLE（局部线性嵌入）</h2><p>LLE(Locally Linear Embedding)优势在于降维时保持样本局部的线性特征。它广泛的用于图像图像识别，高维数据可视化等领域。</p><h3 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h3><p>LLE首先假设数据在较小的局部是线性的。即某一个数据可以由它邻域中的几个样本来线性表示。</p><p>比如有一个样本 $x_1$，在它的原始高维邻域里用K-近邻思想找到和它最近的三个样本 $x_2, x_3, x_4$。然后假设 $x_1$ 可以由 $x_2, x_3, x_4$ 线性表示，即：</p><script type="math/tex; mode=display">x_1 = w_{12}x_2 + w_{13}x_3 + w_{14}x_4</script><p>其中，$w_{12}, w_{13}, w_{14}$ 为权重系数。在通过LLE降维后，希望 $x_1$ 在低维空间对应的投影 $x’_1$ 和 $x_2, x_3, x_4$ 对应的投影 $x’_2, x’_3, x’_4$ 也尽量保持同样的线性关系，即</p><script type="math/tex; mode=display">x'_1 \approx w_{12}x'_2 + w_{13}x'_3 + w_{14}x'_4</script><p>也就是说，投影前后线性关系的权重系数 $w_{12}, w_{13}, w_{14}$ 是尽量不变或者最小改变的。</p><p>从上面可以看出，线性关系只在样本的附近起作用，离样本远的样本对局部的线性关系没有影响，因此降维的复杂度降低了很多。</p><p>参考文章：<a href="https://www.cnblogs.com/pinard/p/6266408.html">https://www.cnblogs.com/pinard/p/6266408.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 重生之我是程序员 </category>
          
          <category> 程序员也得上课 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Macports常用指令</title>
      <link href="/post/554039588.html"/>
      <url>/post/554039588.html</url>
      
        <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>如果要安装名为<code>portname</code>的端口，则在命令行中输入以下指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo port install portname</span><br></pre></td></tr></table></figure><p>如果想查看安装时的详细信息，则加上<code>-v</code>参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo port -v install portname</span><br></pre></td></tr></table></figure><p>如果安装失败了想要重装，在重新运行<code>sudo port install portname</code>之前，需要运行以下指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo port clean portname</span><br></pre></td></tr></table></figure><h1 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h1><p>如果想卸载名为<code>portname</code>的端口，则在命令行中输入以下指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo port uninstall portname</span><br></pre></td></tr></table></figure><p>如果想将安装<code>portname</code>时同时安装的那些依赖卸载，则加上<code>--follow-dependencies</code>参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo port uninstall --follow-dependents portname</span><br></pre></td></tr></table></figure><h1 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h1><p>如果要更新Macports或者安装的软件包，可以运行下面两条指令：</p><ol><li><code>sudo port selfupdate</code>：<ul><li>这个命令会更新MacPorts本身，即MacPorts的基础系统。</li><li>同时，它会同步ports树，即更新可用的软件包列表。（只是软件包列表，不是软件包本身）</li><li>如果检测到有新的MacPorts版本，它会自动升级已安装的MacPorts基础系统到最新版本。</li><li>使用<code>--no-sync</code>参数时，它只会检查并安装（如果有）新的MacPorts版本，而不会更新ports树。</li></ul></li><li><code>sudo port upgrade outdated</code>：<ul><li>这个命令会升级所有已安装的、有过时新版本的ports（软件包）及其依赖到MacPorts中可用的最新版本。</li><li>通常，会运行这个命令来更新所有有更新可用的ports（软件包）。</li><li>也可以选择性地升级特定的ports，但这通常不推荐，因为未升级的ports可能会导致软件错误。</li></ul></li></ol><p><code>ports</code>树就像一个图书馆的索引系统，而里面的<code>ports</code>是一本本具体的书</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>Macports指导手册：<a href="https://guide.macports.org">https://guide.macports.org</a></p><p>Macports端口信息：<a href="https://ports.macports.org/">https://ports.macports.org/</a></p>]]></content>
      
      
      <categories>
          
          <category> 重生之我是程序员 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学海泛舟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pycharm配Jupyter NoteBook</title>
      <link href="/post/3576418838.html"/>
      <url>/post/3576418838.html</url>
      
        <content type="html"><![CDATA[<p>配置：</p><ul><li>Mac</li><li>Pycharm 2024.1</li></ul><hr><p>首先，需要有Pycharm Professional（学生免费）。</p><p>然后点击左下角终端：</p><p><img src="/images/Pycharm配Jupyter.assets/image-20240523210445720.png" alt="image-20240523210445720"></p><p>命令行中输入<code>pip install jupyter</code>。</p><p>之后新建一个<code>Jupyter Notebook</code>文件，就可以愉快写代码了。</p><p><img src="/images/Pycharm配Jupyter.assets/image-20240523210534667.png" alt="image-20240523210534667"></p>]]></content>
      
      
      <categories>
          
          <category> 重生之我是程序员 </category>
          
          <category> Python笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学海泛舟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模块和cmake</title>
      <link href="/post/2136934485.html"/>
      <url>/post/2136934485.html</url>
      
        <content type="html"><![CDATA[<p>首先需要指定cmake的最低版本为3.28（3.28才支持扫描模块）</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.28</span>)</span><br><span class="line"><span class="keyword">project</span>(untitle)</span><br></pre></td></tr></table></figure><p>然后需要设置C++的标准为C++20（C++20才有模块），并启用了对C++模块的支持。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">20</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_SCAN_FOR_MODULES <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure><p>创建了一个名为<code>simple_module</code>的库。<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(simple_module</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>将几个<code>.cppm</code>文件作为C++模块添加到<code>simple_module</code>库中。<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_sources</span>(simple_module</span><br><span class="line">        PUBLIC</span><br><span class="line">        FILE_SET CXX_MODULES FILES</span><br><span class="line">        simple.cppm</span><br><span class="line">        simpe_1.cppm</span><br><span class="line">        simple_2.cppm</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>这行代码创建了一个名为<code>untitled1</code>的可执行文件，其主文件为<code>main.cpp</code>。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(untitled1 main.cpp)</span><br></pre></td></tr></table></figure><p>最后，将<code>simple_module</code>库链接到<code>untitled1</code>可执行文件。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(untitled1 simple_module)</span><br></pre></td></tr></table></figure><p>完整代码如下</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.28</span>)</span><br><span class="line"><span class="keyword">project</span>(untitled1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">20</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_SCAN_FOR_MODULES <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(simple_module</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_sources</span>(simple_module</span><br><span class="line">        PUBLIC</span><br><span class="line">        FILE_SET CXX_MODULES FILES</span><br><span class="line">        simple.cppm</span><br><span class="line">        simpe_1.cppm</span><br><span class="line">        simple_2.cppm</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(untitled1 main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(untitled1 simple_module)</span><br></pre></td></tr></table></figure><blockquote><p>注意，编译器需要支持对模块的扫描</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 重生之我是程序员 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>新精神分析视角下浅析《长日将尽》管家史密斯的人格</title>
      <link href="/post/670287620.html"/>
      <url>/post/670287620.html</url>
      
        <content type="html"><![CDATA[<h1 id="新精神分析视角下浅析《长日将尽》管家史密斯的人格"><a href="#新精神分析视角下浅析《长日将尽》管家史密斯的人格" class="headerlink" title="新精神分析视角下浅析《长日将尽》管家史密斯的人格"></a>新精神分析视角下浅析《长日将尽》管家史密斯的人格</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>石黑一雄的《长日将尽》是于1989年出版的一部小说。小说主要围绕英国传统男管家史密斯的一次驾车旅行展开，在为期六天的旅行中，作者借助史密斯的个人回忆，展现了史密斯所处特定时域的文化记忆乃至历史记忆。译后记中提到，石黑一雄写这本书的出发点就是探究一个人为了成就自己的事业如何放弃了自己的一生。</p><p>因此，本文将从新精神分析视角，浅析管家史密斯的人格特征及其形成原因。</p><h2 id="二、矛盾与冲突——管家史密斯的人格底色"><a href="#二、矛盾与冲突——管家史密斯的人格底色" class="headerlink" title="二、矛盾与冲突——管家史密斯的人格底色"></a>二、矛盾与冲突——管家史密斯的人格底色</h2><p>《长日将尽》的故事以史密斯的自由之旅展开，这一趟为期六天的旅行，并没有主人委派的任何任务，也无须考虑管家的工作职责，而仅仅出于欣赏英格兰美好自然风光的目的。然而，管家史密斯却在闲适的旅途中，频频陷入回忆而怅然。因此，这正是石黑一雄借全书的篇章结构揭开管家史密斯矛盾与冲突的人格底色的第一层面纱。</p><p>其次，史密斯作为叙事的主体， 其内心的矛盾与冲突性也伴随叙事内容展开。例如，史密斯在为公爵的“伟大会面”服务时，恰逢父亲去世，却为了尽忠“管家”的职业操守，拒绝在临终前看望父亲；在与女管家肯尼特小姐的共事中，他冷漠回应她的示好，直至将肯尼特小姐推向其他人的怀抱。冷淡地对待父亲的离世、爱人的错过，史密斯先生似乎冷漠无情、毫不在意，却在回忆的视角中难以掩盖隐忍的泪、不知觉的驻足和无边的心碎。</p><p>此外，史密斯的矛盾与冲突性，还体现在他对管家身份的认同上。一方面，他不时对读者赞叹自己服务的伟大公爵，反复重申自己工作的“伟大性”；而另一方面，在遇到他人对其管家身份询问时，他又无法解释自己为何下意识否认。</p><h2 id="三、社会与自我——新精神分析视角下管家史密斯的人格成因"><a href="#三、社会与自我——新精神分析视角下管家史密斯的人格成因" class="headerlink" title="三、社会与自我——新精神分析视角下管家史密斯的人格成因"></a>三、社会与自我——新精神分析视角下管家史密斯的人格成因</h2><p>实际上，史密斯人格底色中的这种矛盾与冲突，与其说是作者叙事时使用的诡计，不若说是个体视角下，社会与自我的冲突，这正与新精神分析的理论观点相符。</p><h3 id="1-社会角色"><a href="#1-社会角色" class="headerlink" title="1.社会角色"></a>1.社会角色</h3><p>在小说的全篇叙述中，史密斯虽然以自由身踏上旅途，却始终不曾摆脱“管家”的社会角色。</p><p>他赖以生存的职业信条——“伟大的管家之所以伟大，是由于他们能够化入他们的职业角色，并且是全身心地化入；他们绝不会为外部事件所动摇，不管这些事件是何等出人意料、令人恐慌或是惹人烦恼”，正点明了社会角色在他人格塑造中所起的重要作用。</p><p>正如新精神分析学派的学者霍妮在《我们时代的病态人格》中所写，“在特定的历史时期, 当个体偏离社会文化的共同模式 (即心理行为模式) 时, 便会产生焦虑。”当史密斯做出行为时，首先考虑管家行当内的社会角色要求。这正说明，当时的业界翘楚、行当标准，无一不以“社会文化的共同模式”的面貌参杂到史密斯的人格形成中。</p><h3 id="2-家庭环境"><a href="#2-家庭环境" class="headerlink" title="2.家庭环境"></a>2.家庭环境</h3><p>在史密斯的成长过程中，同样以管家为社会角色的父亲，对史密斯的人格形成也产生重大的影响。例如，史密斯在回忆过程中，以父亲沉着镇定地面对谩骂、却忠实地维护自己的主人为例，说明自己心中“忠于职守”的管家形象，这也为后续史密斯不去探望临终父亲的心理活动做了铺垫——“如果是父亲遇到这样的情境，一定也会做出和我一样忠义的抉择。”</p><p>更不必说，史密斯在旅程中对“管家尊严”的阐释——“这个问题归结为一点，无非就是不要当众宽衣解带”，这个核心观念的产生也源于父亲的表率，并逐渐内化为史密斯的核心人格特征。</p><h3 id="3-目的论"><a href="#3-目的论" class="headerlink" title="3.目的论"></a>3.目的论</h3><p>有别于古典精神分析学派的本体论，新精神分析学派提出目的论——未来目标对个体的拉力强于先天本能的推动作用，从而更加强调人格形成中个体的主观性。</p><p>对于管家史密斯，称为“伟大管家”的目标，无疑取代先天本能，称为管家人格塑造的强大动力。他说，“有太多的人相信自己有能力在更高等级的岗位上工作，对于这更高的岗位所要求的素质却又没有丝毫的概念。这样的工作肯定不是任何人都干得了的。”因此，他有着严格的自我要求，也渴望通过“效命于那些肩负着当代文明重任的伟大的士绅……服务全人类。”</p><p>他当然借住未来目标的“拉力”做到了这一点，但同时，当发现自己自己效忠的“伟大公爵”犯下错误时，为了掩饰心中的冲突，他依旧不愿背离人格之本的“伟大目标”为自己做辩解——“既如此，如果由于时移世易的缘故，达林顿勋爵当初的那些努力已经被证明是受到了误导、甚至可以说是愚蠢之举，我在任何意义上又有什么该当受到责备的地方呢？”</p><h2 id="四、辩证与思考——浅析对新精神分析视角下的人格分析"><a href="#四、辩证与思考——浅析对新精神分析视角下的人格分析" class="headerlink" title="四、辩证与思考——浅析对新精神分析视角下的人格分析"></a>四、辩证与思考——浅析对新精神分析视角下的人格分析</h2><p>一方面而言，新精神分析提供了一个很好的人格分析视角，较于经典精神分析将人格归于生理因素，其发现了人格塑造中社会、文化的影响。即使在《长日将尽》这样一部虚构文学作品里，也能很好地解释管家的痛苦与彷徨——正是社会文化对人格的塑造与个人发生矛盾的结果。</p><p>但另一方面而言，新精神分析视角也存在一定的局限，它虽然考虑家庭乃至社会、文化的影响，却忽视社会中的物质要素，脱离物质基础、社会发展的基本形态谈文化，则可能使其成为“空中楼阁”。</p><hr><p>第一次写于2023年10月1日。</p>]]></content>
      
      
      <categories>
          
          <category> 泼墨千钧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 石黑一雄 </tag>
            
            <tag> 心理学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《达洛维夫人》伍尔夫</title>
      <link href="/post/3715903088.html"/>
      <url>/post/3715903088.html</url>
      
        <content type="html"><![CDATA[<h1 id="《达洛维夫人》伍尔夫"><a href="#《达洛维夫人》伍尔夫" class="headerlink" title="《达洛维夫人》伍尔夫"></a>《达洛维夫人》伍尔夫</h1><p>没有序言、没有介绍，封面之后的第一页就是小说的正文，出场的第一个人物就是达洛维夫人。当你认为自己是以上帝视角，从外界的角度看达洛维夫人的故事时，你会突然发现自己跳进了达洛维的第一视角、在达洛维对面的彼得的第一视角、与达洛维在公园擦肩而过的路人的第一视角；于是，伴随着第一视角而来的，是大篇幅的、随着意识流动的、直白的心理活动；而当你逐渐适应了第一视角，试图思考达洛维和彼得的爱情故事时，你能发现自己又再次跳出了内在世界，再次关注外界的树、喷泉和花——这就是意识流小说《达洛维夫人》给我的第一印象。</p><h3 id="混乱"><a href="#混乱" class="headerlink" title="混乱"></a>混乱</h3><p>先谈谈“混乱”吧。</p><p>我个人认为，意识流难读的原因，其实在于其不同视角的多次、快速切换，以及随着意识（而非事件发生逻辑）产生的“流动”。比如在《达洛维夫人》中，从达洛维夫人的视角，到昔日恋人彼得的视角的切换，没有任何的过渡，甚至可以说是很突兀地，中止了原来发散的意识，跳入一个完全不同的意识；而随着意识的流动则更容易让人心生疑惑，似乎上一句话还在谈花，下一句就是与之完全不相干的事物、思绪。</p><p>而在所有的“混乱”或者说“意识流”里，给我留下最深的印象的，其实是塞普蒂默斯的意识片段。塞普蒂默斯能把从外界接受到的信号无限放大，甚至无可抑制地联想、歪曲，直至让自己陷入痛苦怀疑的境地。不过，虽然同样是意识的混乱与遐想，塞普蒂默斯的混乱与《罪与罚》中的拉斯柯尔尼科夫的“疯癫”又有着明显的不同——拉斯柯尔尼科夫的想法热烈、迅猛、有清晰的思考，也由此常常出现前后矛盾、自我修正；相比之下，塞普蒂默斯的思考较为单线程，更像是一股脑地往极端上走，把外界的所有信号，套进固有的、错误的、自我的认知体系中，不加思考也无所谓修正。</p><p>当然，这是较为极端的“混乱意识”。普通的“混乱”如何呢？我反倒觉得，比起《使女的故事》中，使女的“混乱”更多是体现其内心的痛苦和绝望，达洛维夫人中的“意识流动”，更像是想法丰富、情绪充沛的高敏感人群的“碎碎念”——是看到日常的事物，根据自己的经历、特定的心境，萌发出的想法——哪怕只是一闪而过。其中，我认为描写“意识”（而不是第三视角“偷听”的心理活动）的明显表征，在于意识的随时中断的特性。比如此刻我正在写下我脑海中的想法时，我会突然感受到一阵风从窗户中吹进来，此刻倘若真切地记录下我脑海中的活动，就是：意识具有一种——哦，好像有一阵冷风吹过——随时可中断，或者说随时受影响，而非独立、完整地生发大篇幅的“独白”。而对这种普通“混乱”的理解程度，我认为更多关系读者自身的性格特质，越是相近，越不存在理解上的障碍。</p><p>然而，无论是上述的哪种“混乱”，无疑都增加了阅读难度，但这意味着“混乱”就不可取吗？我想，不是这样的。</p><p>视角的多次且迅速的切换，虽然让人不容易适应，但你可以从这种切换中获得完全不同的阅读体验。比如说，作为昔日恋人的克拉丽莎和彼得双方，在意识中思考（或者说回忆）两人的结识、恋爱过程时，产生了明显的冲突——明明是同时发生于两方的经历，由于不同的偏好选择、逻辑体系，二者回忆的重点、顺序均有明显区别。同时，在爱恋记忆的唤醒过程中，二者对对方的性格描述都分别与自己的认知有明显冲突，甚至两人都认为自己非常了解对方。再比如说，新婚夫妇卢克雷齐娅和塞普蒂默斯两人，当他们发生真实的交互时，双方对交互信号的处理有着相当显著的差别，甚至可以随着意识的延申，可能向着完全不同的两个方向发展。还有，主人克拉丽莎和女仆基尔曼小姐会同时认为对方是虚伪、傲慢的。</p><p>我认为，这正是意识流小说中，自由、不受逻辑限制的切换才能够展示出来的，与传统小说固定于一方的视角相比，你能够很奇妙地发现差异。当然，我并不否认传统小说中也存在相当多的视角切换，但无可置疑的是，其一定是受到叙事逻辑所限的。即使是我很喜欢的双线描写的写法，也需要先在一方视角进行清晰、充足地展开，才能考虑填埋抑或是开挖另一条线。</p><p>所以，可以在一定程度上来说，混乱带来了更自由的叙事，和更加即时性的冲突，容易产生更微妙、更有趣的化学反应。</p><p>当然，仅仅是混乱，完全发散、没有主题、没有任何外延限制的混乱，只能成为“癫狂病人”的日志，而不能成为小说。所以比起体味“混乱”给我带来的惊喜，“混乱”中的“秩序”让我进一步爱上了这本书。</p><h3 id="秩序"><a href="#秩序" class="headerlink" title="秩序"></a>秩序</h3><p>我开始发现，那些在小说最开头，达洛维的视角里一闪而过的、支离破碎的、令人费解的、没有意义的片段，逐渐得到了详实、丰富、又合乎逻辑的展开。</p><p>在克拉丽莎所见，路中间有一对奇怪的青年夫妇，一位会定定地站在路中间，说些什么“树是活的，没有罪”这样让人摸不着头脑的话，另一位则迅速地把他拉走。在彼得所见，公园长椅坐着一对奇怪的男女，一位不时看着天空，嘴里念叨着什么，一位则苦恼地看着他，或是说着自己的话。在这对奇怪的男女里，塞普蒂默斯患上了精神疾病，而当时的社会的不了解、霍斯大夫信誓旦旦的“没有病”的诊断、另一位“精神”医生的“完全孤立”疗法的提出，只让塞普蒂默斯倍感压力、痛苦，甚至没有希望；而卢克雷齐娅，从最开始和旁人一样困惑、不理解，到逐渐选择接纳、相信和支持自己的丈夫。这一动态的变化，不止在以他们作为主体的描写中，还在看似无逻辑的“意识流动”中悄然发生。这种细节的前后自洽，正是使我体会到“秩序感”的一大来源。</p><p>此外，还有在混乱的、对立的性格描述中，奇妙地发生“综合”，然后无意识地表现在人物上的自洽；以及，虽然多次向外延申，却始终没有脱离小说主体内容的框架、逻辑上的自洽。</p><h3 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h3><p>然而，除了奇妙的“混乱”和“秩序”，我同样折服于《达洛维夫人》出现的大量的、非同寻常的比喻。我曾经形容《长恨歌》中的比喻是绵软的、富有小家碧玉的情态的，《人生清单》中的比喻是清新而别致的，《情人》中的比喻是飘渺而繁复的，那么《达洛维夫人》中的比喻给我的感觉是近乎极致的生动和出乎意料——在拟人中，哈里街上的钟声作为不同人物的连结点，是伸出长长的手来抓人的；抽象的名词，化身为有生动情态、有自己的小私心，有时还颐指气使地做着指挥的人；经过无数年代的小路化身为老妇人，站在风中寻求“救济”；而在拟物中，沉默、冷静但美丽的伊丽莎白，是和风中的白杨……</p><p>但不得不提的是，作为一本译文小说，还是不可避免地受到翻译的限制，比如存在一些语句不太符合汉语的语言习惯，以及在视角变换时，汉语人称代词繁多且混乱导致的指代不明，还有部分直接引语与间接引语之间的转换存在明显问题。而作为外国小说，也难免遇到长长的、拗口的、难记的、常常分离开的姓和名，这使得我不得不翻回前文，判断名和姓指代的是否是同一个人。</p><p>但我认为，这些瑕疵都不能掩盖《达洛维夫人》本身的魅力，我依旧深深喜欢上了这本书，并且认为其中的意识流部分非常出彩，值得一试。</p><p>第一次写于2022年11月04日。</p>]]></content>
      
      
      <categories>
          
          <category> 偷得浮生半日闲 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 伍尔夫 </tag>
            
            <tag> 意识流 </tag>
            
            <tag> 小说 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《到灯塔去》伍尔夫</title>
      <link href="/post/1167721442.html"/>
      <url>/post/1167721442.html</url>
      
        <content type="html"><![CDATA[<h1 id="《到灯塔去》伍尔夫"><a href="#《到灯塔去》伍尔夫" class="headerlink" title="《到灯塔去》伍尔夫"></a>《到灯塔去》伍尔夫</h1><p>同样是伍尔夫的意识流小说，《到灯塔去》和<a href="/post/3715903088.html" title="《达洛维夫人》伍尔夫">《达洛维夫人》</a>有相似又有不同。相似之处在于，伍尔夫一贯地使用了其灵活而细腻的笔触来展现“意识的流动”，毫无提示的视角切换，毫无预警的所指转换，这些都是让人不知觉陷入她的表述中；然而，比起《达洛维夫人》只讲述半天内发生的事情（这点与《到灯塔去》的第一部分类似），《到灯塔去》还增加了第二部分和第三部分。其中，第二部分的写法很特别，以景色描写为无形之线，纺织十年的光阴，连接前的第一部分和后的第三部分；第三部分则有些精神上“朝圣”的意味。</p><h3 id="一、小说人物"><a href="#一、小说人物" class="headerlink" title="一、小说人物"></a>一、小说人物</h3><p>小说有三个关键人物——拉姆齐夫人、拉姆齐和莉丽。</p><h4 id="1-拉姆齐夫人"><a href="#1-拉姆齐夫人" class="headerlink" title="1.拉姆齐夫人"></a>1.拉姆齐夫人</h4><p>在对拉姆齐夫人的态度上，译者认为伍尔夫主要在表达“拉姆齐夫人伟大、无私的爱跨越了时间和空间”。实际上，我认为拉姆齐夫人的形象与达洛维夫人有些相似，不过伍尔夫的确赋予了拉姆齐夫人更多“爱”的付出，并且毋庸置疑的是，拉姆齐夫人展现出的爱足够无私，足够伟大。</p><p>但我并不认为伍尔夫只是一味地赞叹拉姆齐夫人的爱，将其捧上神坛高歌。伍尔夫会借助莉丽之口，对拉姆齐夫人进行质疑——“想到拉姆齐夫人带着毫不动摇的冷静态度，硬要自作主张地把她完全无法理解的命运强加给她，她几乎歇斯底里地大笑起来”；同时，也会借助拉姆齐夫人的心理活动，表现一小部分的自省——“她被某种力量驱使着前进……几乎对她自己来说，似乎这也是一种逃避”。此外，在最后的晚餐一幕，拉姆齐夫人也有出神不愿意扮演“女主人”角色的片刻，且在拉姆齐夫人施展她的关怀时，伍尔夫也借旁观的莉丽之口，表明她的关怀并非真正为他人，相反，更像是为了满足自己，带着“施恩于人”的傲慢。因此，我认为拉姆齐夫人的形象构建也有着自私、扮演“夫人”角色的可能性。</p><h4 id="2-拉姆齐"><a href="#2-拉姆齐" class="headerlink" title="2.拉姆齐"></a>2.拉姆齐</h4><p>对于拉姆齐，伍尔夫的描述似乎是拉姆齐夫人的反面，他足够理性却完全不近人情——对孩子的欺骗他只会残忍地告诉他事实，并且得意地认为孩子就应该学会接受生活的真相；作为有所成就的哲学家，他勇敢地向未踏足之地前进——“如果说伟大工作是从A到Z，那么现在我已经到了Q，下一个呢，下一个是R，我要冲击R”；但他又时常展现出软弱的一面，希翼通过获得他人（尤其是拉姆齐夫人）的同情来获得心理安慰。我起初认为拉姆齐的刻画比较单一稳定，但在第三部中，伍尔夫借詹姆斯和凯姆的想法：“如果他说我们也终将死去，就太扫兴了”来展现拉姆齐的转变——他并没有和往常一样这么说。</p><p>说完拉姆齐夫人和拉姆齐，还可以谈谈他们共同建构起的婚姻形象。在搜索资料时，我看到有学者的观点认为借助拉姆齐夫妻，伍尔夫探讨了理性和感性的一对完美融合，我有比较不同的意见。就我所读，伍尔夫展现了这样的夫妻状态：“那个黄铜的鸟嘴，那把渴望的弯刀…那个自私的男人，扑过去拼命地吮吸、砍伐”（拉姆齐从夫人处获取同情和能量）、“他那样如此公开地在众目睽睽之下求助于她，这使她感到不安（拉姆齐夫人认为自己不应当高过丈夫）、”她不敢告诉他：温室屋顶的修理费用也许会达到五十英镑“（拉姆齐是家里的甩手掌柜）。但比起赞扬它的融洽和完美，我个人认为，伍尔夫也许更多只是展示，或者再带有一点点自省的怀疑——“说不清是什么道理…突然降临到他们身上…使他们成为婚姻的象征：丈夫和妻子”。</p><h4 id="3-莉丽"><a href="#3-莉丽" class="headerlink" title="3.莉丽"></a>3.莉丽</h4><p>最后是莉丽，莉丽的角色很独特，有时作为一个旁观者，观察、评价小说中出现的其他人，也有时陷入自己意识的泥沼。而对于拉姆齐夫人和拉姆齐以及其他任务的态度，她也有时批评，有时突然理解而称赞。而到小说的最后，莉丽对两方都和解了——她理解了拉姆齐夫人的爱，也理解了拉姆齐先生所渴望的同情（虽然她还是无法说出口），也因此最终得以在她画卷完成十年未完成之笔，这也是为什么我认为本书第三部类似精神“朝圣”的一部分原因。</p><p>当然，每个人都因为自己独特的生命体验，会对作品有不同的解读，译者也许与原著有比我更近的距离，学者也比我具有更专业的文学解读视角。但至少在此时此刻，我的感受和我的解读是这样的。</p><h3 id="二、人性之剖析与杂谈"><a href="#二、人性之剖析与杂谈" class="headerlink" title="二、人性之剖析与杂谈"></a>二、人性之剖析与杂谈</h3><p>除此之外，如果说读《达洛维夫人》给我最大的感触是混乱与秩序的合理配置，《到灯塔去》则让我更加深刻地体会到伍尔夫对人性观察之细微、表达之独特。</p><p>古今中外的文学作品从来不乏描写人性，即使不以人性的描写为表达目的，人物作为其基本要素之一，也几乎无可避免地由作家来构建、服务于表达。但人性往往集中于一个面来展现，例如并不泾渭分明的善良与邪恶、克制与欲望。</p><p>而于伍尔夫而言，意识作为她表达的承载体，人性被切割成数不清的碎片，不仅有些“断裂”，并且可能在不同部分折射出不同的特点。例如，拉姆齐夫人回忆起与塔斯莱一起进城，对他的态度就变化得很快，在上一刻还是赞扬——“她几乎都要爱上他了”，下一刻就转变为讨厌——“真是扫兴的家伙”。这是一个我很喜欢的小细节，一方面，评价者是复杂、变化莫测的，会随着外部的信息重新构建印象，而另一方面，被评价的人本身也是复杂与变化的。</p><p>人格心理学认为，人格是在遗传与环境的交互作用下，个体所具有的典型而独特、稳定而有差异的心理品质组合系统。这种“稳定性”是否与我提到的“碎片”相冲突呢，我认为不然。因为二者讨论的时间范围并不相同，前者在客观上占据相当的时间，而“碎片”则更多是占据一定“心理时间”进行讨论。</p><p>关于“物理时间”和“心理时间”，这点译者也有在序中提到，达洛维夫人和到灯塔去的第一部，客观时间上都只有半天；而到灯塔去的第二部篇幅不长，客观时间却又十年。（其实在这里我想起，马原老师在课上提到，康德认为时间与空间不过是受限于人类观测方式的产物，而非真实存在的物质形态。）</p><p>第一次写于2024年03月30日。</p>]]></content>
      
      
      <categories>
          
          <category> 偷得浮生半日闲 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 伍尔夫 </tag>
            
            <tag> 意识流 </tag>
            
            <tag> 小说 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mac用ssh连linux服务器</title>
      <link href="/post/1909324461.html"/>
      <url>/post/1909324461.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>网上的一些ssh免密连接linux服务器的资料都写的过于复杂，因此笔者写了一份简明的教程。</p><p>配置如下：</p><ul><li>客户端（发起SSH连接的一方）：<strong>Mac Sonoma14.4.1</strong> </li><li>服务器（接受SSH请求的一方）：22.04.1-Ubuntu </li></ul><h1 id="简单SSH连接"><a href="#简单SSH连接" class="headerlink" title="简单SSH连接"></a>简单SSH连接</h1><p>基本的<code>ssh</code>命令格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh [用户名]@[主机地址]</span><br></pre></td></tr></table></figure><p>例如，如果用户名是<code>john</code>，想要连接到主机地址为<code>example.com</code>的远程服务器，使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh john@example.com</span><br></pre></td></tr></table></figure><p>这个命令会尝试以用户<code>john</code>的身份建立到<code>example.com</code>的SSH连接。如果连接成功，将需要提供密码（如果有的话），之后就可以开始远程操作该服务器了。</p><p>可以使用远程主机的IP地址来代替域名。例如，如果远程服务器的IP地址是<code>192.168.1.100</code>，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh 用户名@192.168.1.100</span><br></pre></td></tr></table></figure><h1 id="SSH免密连接"><a href="#SSH免密连接" class="headerlink" title="SSH免密连接"></a>SSH免密连接</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>SSH免密连接需要在客户端生成公钥和私钥：</p><ul><li>公钥：公钥将复制到服务器一端。</li><li>私钥：私钥要保存在客户端本地，也就是Mac上。</li></ul><p>在SSH连接的时候，会根据公钥和私钥进行验证，具体的过程如下：</p><blockquote><ul><li>服务器使用存储的公钥对客户端发送的认证请求进行加密，生成一个挑战（challenge）。</li><li>客户端使用自己的私钥对挑战进行解密，然后将解密结果发送回服务器。</li><li>服务器验证收到的解密结果是否与原始挑战匹配。如果匹配，服务器就知道客户端持有对应的私钥，因此认证成功</li></ul></blockquote><h2 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h2><h3 id="省流"><a href="#省流" class="headerlink" title="省流"></a>省流</h3><p>如果不想知道详细的过程，可以直接执行以下的命令：</p><p>首先在Mac终端上执行下面指令生成公钥秘钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;your_email@qq.com&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>这里用任意邮箱替代<code>&quot;your_email@qq.com&quot;</code>即可。</p></blockquote><p>然后在终端中，SSH连接到服务器上并进行一系列权限设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh [用户名]@[主机地址]</span><br><span class="line"><span class="built_in">chmod</span> 700 ~/.ssh</span><br><span class="line"><span class="built_in">chmod</span> 600 ~/.ssh/authorized_keys</span><br><span class="line">sudo <span class="built_in">chown</span> [用户名]:[用户名] ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>在终端中，用<code>exit</code>退出SSH：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>在终端中，拷贝公钥到服务器<code>~/.ssh/authorized_keys</code>中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id [用户名]@[主机地址]</span><br></pre></td></tr></table></figure><p>之后就可以用ssh免密登陆了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh [用户名]@[主机地址]</span><br></pre></td></tr></table></figure><h3 id="生成私钥与公钥"><a href="#生成私钥与公钥" class="headerlink" title="生成私钥与公钥"></a>生成私钥与公钥</h3><p>首先，打开Mac上的终端（Command+空格搜索终端即可）。然后输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;your_email@qq.com&quot;</span></span><br></pre></td></tr></table></figure><ul><li><code>-t rsa</code>：指定要创建的密钥类型。这里使用的是RSA算法，RSA是一种非对称加密算法，广泛用于SSH密钥生成。</li><li><code>-b 4096</code>：指定密钥的长度。这里设置为4096位。密钥长度越长，安全性越高，但同时也会增加计算负担。4096位是一个当前普遍认为安全的长度。</li><li><code>-C &quot;your_email@qq.com&quot;</code>：添加注释。这里的注释是邮箱<code>your_email@qq.com</code>，这个注释会添加到公钥文件中，帮助识别密钥的拥有者。这通常用于当多个密钥存在时，区分不同的密钥。</li></ul><p>这个秘钥会生成在你的Mac的<code>用户名/.ssh</code>文件夹下。</p><h3 id="更改服务器中文件夹权限"><a href="#更改服务器中文件夹权限" class="headerlink" title="更改服务器中文件夹权限"></a>更改服务器中文件夹权限</h3><h4 id="更改-ssh文件夹权限"><a href="#更改-ssh文件夹权限" class="headerlink" title="更改.ssh文件夹权限"></a>更改.ssh文件夹权限</h4><p>先使用密码<a href="#简单SSH连接">手动登录到服务器</a>上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh [用户名]@[主机地址]</span><br></pre></td></tr></table></figure><p>然后检查 <code>.ssh</code> 目录权限（之后要把公钥复制到.ssh/authorized_keys下）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -ld ~/.ssh</span><br></pre></td></tr></table></figure><p>会看到这样的输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drwxrwxr-x 2 node1 node1 4096  4月 20 20:47 /home/node1/.ssh</span><br></pre></td></tr></table></figure><p><code>drwxrwxr-x</code>：这部分表示文件（或目录）的权限。这里<code>d</code>表示这是一个目录。</p><ul><li>接下来的三个字符<code>rwx</code>表示目录所有者（user，这里是node1）的权限，</li><li>再接下来的三个字符<code>rwx</code>表示所属组（group，这里也是node1）的权限。</li><li>最后的三个字符<code>r-x</code>表示其他用户（others）的权限。</li></ul><p>所以这里的意思是所有者和所属组有读写和执行权限，而其他用户有读和执行权限，但没有写权限。</p><p><code>.ssh</code> 目录的权限过于宽松，任何用户都可以进入这个目录。所以更改一下其的权限，将 <code>.ssh</code> 目录的权限修改为只有所有者可以读写执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 700 ~/.ssh</span><br></pre></td></tr></table></figure><blockquote><p><code>chmod</code>（change mode）： <code>chmod</code> 命令用于改变文件或目录的访问权限，权限设置使用符号表示法或八进制表示法。</p></blockquote><h4 id="更改-ssh-authorized-keys的权限"><a href="#更改-ssh-authorized-keys的权限" class="headerlink" title="更改.ssh/authorized_keys的权限"></a>更改.ssh/authorized_keys的权限</h4><p>查看<code>.ssh/authorized_keys</code>的权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>输出应该如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r-- 1 root root 96  3月 11 21:26 /home/node1/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p><code>-rw-r--r--</code>：这部分表示文件（或目录）的权限。</p><ul><li>这里<code>-</code>表示这是一个普通文件。接下来的三个字符<code>rw-</code>表示文件所有者（user，这里是root）有读写权限，没有执行权限；</li><li>再接下来的三个字符<code>r--</code>表示所属组（group，这里也是root）有读权限，没有写和执行权限；</li><li>最后的三个字符<code>r--</code>表示其他用户（others）有读权限，没有写和执行权限。</li></ul><p><code>authorized_keys</code>文件可以被所有用户读取，这通常不是推荐的做法。并且<code>authorized_keys</code> 文件目前属于 <code>root</code> 用户，应该改为目前的登录用户（也就是ssh时输入的用户名部分）。</p><p>首先，修改 <code>authorized_keys</code> 文件权限：，将 <code>authorized_keys</code> 文件的权限修改为只有所有者可以读写。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 600 ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>然后修改 <code>authorized_keys</code> 文件所有者为目前登录的用户（将你的用户名替换掉<code>[用户名]</code>这一部分）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">chown</span> [用户名]:[用户名] ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><blockquote><p><code>chown</code>（change owner）： <code>chown</code> 命令用于改变文件或目录的所有者和/或所属组。</p></blockquote><h3 id="拷贝公钥"><a href="#拷贝公钥" class="headerlink" title="拷贝公钥"></a>拷贝公钥</h3><p>刚才的一系列操作都是为了能将生成的公钥拷贝到<code>~/.ssh.authorized_keys</code>下。然后在客户端（你的Mac）上，使用这个命令进行拷贝：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id [用户名]@[主机地址]</span><br></pre></td></tr></table></figure><h3 id="测试SSH免密登录是否成功"><a href="#测试SSH免密登录是否成功" class="headerlink" title="测试SSH免密登录是否成功"></a>测试SSH免密登录是否成功</h3><p>上面的都设置完之后，用<code>exit</code>指令可以退出目前的ssh登录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>然后再次使用ssh登录，就不需要密码了！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh [用户名]@[主机地址]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 重生之我是程序员 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学海泛舟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu配置C++20环境</title>
      <link href="/post/1240948986.html"/>
      <url>/post/1240948986.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文写于2024.5.19，我的系统为22.04.1-Ubuntu，默认带的是gcc11，它还不支持C++20。为了用上一些C++20的特性，便打算配置一下C++20的环境，期间走了不少弯路，故写一份笔记造福后人。</p><p>这里列出我的一些配置：</p><ul><li>22.04.1-Ubuntu</li><li>CLion 2024.1</li></ul><h1 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h1><h2 id="下载clang18"><a href="#下载clang18" class="headerlink" title="下载clang18"></a>下载clang18</h2><p>首先，需要下载支持C++20的编译器。从<a href="https://zh.cppreference.com/w/cpp/compiler_support/20">cppreference</a>上可以找到支持C++20的编译器有哪些。这里选择下载clang18，因为当下的gcc13尚不支持C++20的模块功能。</p><blockquote><p>如果用cmake，cmake需要3.28以上才支持C++20模块功能</p></blockquote><p>参考一篇<a href="https://zhuanlan.zhihu.com/p/670338052">知乎文章</a>，在命令行下输入以下内容安装LLVM18（其带有clang18）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://apt.llvm.org/llvm.sh</span><br><span class="line">chmod +x llvm.sh</span><br><span class="line">sudo ./llvm.sh 18</span><br></pre></td></tr></table></figure><p>下载完之后用下面的命令查看一下clang18是否成功安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang-18 --v</span><br></pre></td></tr></table></figure><p>输出应该如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Ubuntu clang version 18.1.6 (++20240517093811+3d0752b9492e-1~exp1~20240517213934.128)</span><br><span class="line">Target: x86_64-pc-linux-gnu</span><br><span class="line">Thread model: posix</span><br><span class="line">InstalledDir: /usr/bin</span><br><span class="line">Found candidate GCC installation: /usr/bin/../lib/gcc/x86_64-linux-gnu/11</span><br><span class="line">Found candidate GCC installation: /usr/bin/../lib/gcc/x86_64-linux-gnu/12</span><br><span class="line">Selected GCC installation: /usr/bin/../lib/gcc/x86_64-linux-gnu/12</span><br><span class="line">Candidate multilib: .;@m64</span><br><span class="line">Selected multilib: .;@m64</span><br></pre></td></tr></table></figure><h2 id="下载gcc12"><a href="#下载gcc12" class="headerlink" title="下载gcc12"></a>下载gcc12</h2><p>从刚才<code>clang-18 --v</code>可以看到，clang18需要gcc12，如果没有的话，需要安装一下。</p><blockquote><p>具体而言，是需要gcc12带的C++标准库libstdc++。如果没有的话会报错。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selected GCC installation: /usr/bin/../lib/gcc/x86_64-linux-gnu/12</span><br></pre></td></tr></table></figure><p>用下面的命令安装gcc12和g++12：</p><blockquote><ul><li><code>gcc</code> 是GCC套件中的C语言编译器，用于编译C语言源代码。</li><li><code>g++</code> 是GCC套件中的C++语言编译器，用于编译C++语言源代码。</li></ul></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gcc-12 g++12</span><br></pre></td></tr></table></figure><h2 id="安装libc"><a href="#安装libc" class="headerlink" title="安装libc++"></a>安装libc++</h2><p>gcc12带的C++标准库libstdc++是不含C++20的库的（gcc13带的C++标准库才含有C++20的库），所以还需要下载llvm带的另一个C++标准库libc++（是的，刚才安装llvm-18的时候并没有安装这个C++标准库）。</p><p>用以下命令来安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libc++-18-dev libc++abi-18-dev</span><br></pre></td></tr></table></figure><h2 id="配置工具链"><a href="#配置工具链" class="headerlink" title="配置工具链"></a>配置工具链</h2><p>打开CLion的设置，打开构建、执行、部署中的工具链一项。</p><p><img src="/images/Ubuntu配置C20环境.assets/image-20240519114554944.png" alt="image-20240519114554944"></p><p>应该可以在/usr/bin中找到clang-18（点C Compiler旁边像文件夹的那个按钮）。</p><p><img src="/images/Ubuntu配置C20环境.assets/image-20240519114703299.png" alt="image-20240519114703299"></p><p>同样，设置C++ compiler为clang++-18，到这里编译器就设置好了。</p><h2 id="更改cmakelist"><a href="#更改cmakelist" class="headerlink" title="更改cmakelist"></a>更改cmakelist</h2><p>现在直接编译还成功不了，因为clang-18会去找gcc12的标准库libstdc++，而其还不支持C++20。所以需要设置标准库为我们安装的libc++-18。在cmakelist.txt中添加如下语句：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -stdlib=libc++&quot;</span>)</span><br></pre></td></tr></table></figure><p>在CMake中，<code>CMAKE_CXX_FLAGS</code>是一个变量，它用于存储编译C++源文件时的编译器标志。这行CMake代码是修改这个变量的值的命令，通过将<code>-stdlib=libc++</code>添加到现有的编译器标志中。</p><p>这行代码的作用是告诉C++编译器（比如Clang）使用<code>libc++</code>作为标准的C++库而不是默认的<code>libstdc++</code>。<code>libc++</code>是LLVM项目的一部分，它是C++标准库的一个实现，旨在提供对最新C++标准的良好支持。</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>最后用一个小文件测试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;format&gt;</span> <span class="comment">//format是C++20引入的</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;std::format(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cmakelist.txt如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.28</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">test</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">20</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_SCAN_FOR_MODULES <span class="keyword">OFF</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_compile_options</span>(-std=c++<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -stdlib=libc++&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="keyword">test</span></span><br><span class="line">        main.cpp)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果成功输出了<code>hello world!</code>，那么就配置成功了。</p>]]></content>
      
      
      <categories>
          
          <category> 重生之我是程序员 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学海泛舟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础</title>
      <link href="/post/2575511367.html"/>
      <url>/post/2575511367.html</url>
      
        <content type="html"><![CDATA[<p>参考文章：<a href="https://blog.algorithmpark.xyz/2023/07/23/language/python/index/">算法乐园的Python笔记</a></p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="print函数"><a href="#print函数" class="headerlink" title="print函数"></a>print函数</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>最简单的用法就是直接打印一个字符串：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br></pre></td></tr></table></figure><p>这将在控制台上输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, World!</span><br></pre></td></tr></table></figure><h3 id="打印多个值"><a href="#打印多个值" class="headerlink" title="打印多个值"></a>打印多个值</h3><p>你也可以在一次<code>print</code>调用中打印多个值，只需用逗号隔开它们：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello,&quot;</span>, <span class="string">&quot;World!&quot;</span>)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, World!</span><br></pre></td></tr></table></figure><h3 id="打印变量"><a href="#打印变量" class="headerlink" title="打印变量"></a>打印变量</h3><p>当然，<code>print</code>函数也可以用于打印变量的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line">y = <span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x =&quot;</span>, x, <span class="string">&quot;, y =&quot;</span>, y)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span> , y = <span class="number">20</span></span><br></pre></td></tr></table></figure><h3 id="换行与分隔符"><a href="#换行与分隔符" class="headerlink" title="换行与分隔符"></a>换行与分隔符</h3><p>默认情况下，<code>print</code>函数会在每个值之间添加一个空格，并在最后添加一个换行符。你可以通过<code>sep</code>和<code>end</code>参数来自定义这些行为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>, sep=<span class="string">&quot;-&quot;</span>, end=<span class="string">&quot;!!!\n&quot;</span>)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello-World!!!</span><br></pre></td></tr></table></figure><h3 id="格式化字符串的语法"><a href="#格式化字符串的语法" class="headerlink" title="格式化字符串的语法"></a>格式化字符串的语法</h3><p>格式化字符串使用<code>f</code>或<code>F</code>前缀来标识，后面跟着一个字符串字面量，其中可以包含花括号<code>&#123;&#125;</code>内的表达式。这些花括号内的表达式将在运行时被计算，并用其结果替换花括号。</p><h4 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;Alice&quot;</span>  </span><br><span class="line">age = <span class="number">30</span>  </span><br><span class="line">greeting = <span class="string">f&quot;Hello, my name is <span class="subst">&#123;name&#125;</span> and I am <span class="subst">&#123;age&#125;</span> years old.&quot;</span>  </span><br><span class="line"><span class="built_in">print</span>(greeting)  <span class="comment"># 输出: Hello, my name is Alice and I am 30 years old.</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，变量<code>name</code>和<code>age</code>被插入到了字符串中的相应位置。</p><h2 id="input语句"><a href="#input语句" class="headerlink" title="input语句"></a>input语句</h2><h3 id="基本用法-2"><a href="#基本用法-2" class="headerlink" title="基本用法"></a>基本用法</h3><p><code>input()</code>函数的基本用法非常简单。当调用它时，程序会暂停并等待用户输入。用户可以在命令行或交互式环境中输入文本，然后按Enter键提交输入。</p><p>下面是一个简单的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user_input = <span class="built_in">input</span>(<span class="string">&quot;请输入一些文本：&quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;你输入的是：&quot;</span>, user_input)</span><br></pre></td></tr></table></figure><p>在这个例子中，程序首先打印出提示信息”请输入一些文本：”，然后等待用户输入。用户输入的内容将被赋值给变量<code>user_input</code>，然后程序打印出”你输入的是：”后面跟着用户输入的内容。</p><h3 id="输入类型"><a href="#输入类型" class="headerlink" title="输入类型"></a>输入类型</h3><p>需要注意的是，<code>input()</code>函数返回的总是一个字符串类型。即使你输入的是一个数字，它也会被当作字符串处理。如果你需要将输入转换为其他类型（如整数或浮点数），你需要使用相应的类型转换函数。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h3 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h3><p>Python 中的单行注释以 <code>#</code> 开头。<code>#</code> 符号后面的所有内容都会被视为注释，直到该行的结束。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是一个单行注释  </span></span><br><span class="line">x = <span class="number">5</span>  <span class="comment"># 可以在代码行的末尾添加注释</span></span><br></pre></td></tr></table></figure><h3 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h3><p>Python 本身并没有直接支持多行注释的语法，但我们可以使用三重引号（<code>&quot;&quot;&quot;</code> 或 <code>&#39;&#39;&#39;</code>）来实现类似的效果。三重引号通常用于多行字符串，但如果没有将它们赋值给变量或用作其他目的，它们也可以用作多行注释。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;  </span></span><br><span class="line"><span class="string">这是一个多行注释的  </span></span><br><span class="line"><span class="string">示例。你可以在这里写下  </span></span><br><span class="line"><span class="string">多行文字来描述你的代码。  </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 或者使用三个单引号  </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;  </span></span><br><span class="line"><span class="string">这也是一个多行注释的示例，  </span></span><br><span class="line"><span class="string">和上面的三重双引号具有相同的效果。  </span></span><br><span class="line"><span class="string">选择哪种风格通常取决于个人或团队的偏好。  </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>Python 中一般以新行作为语句的结束标识，可以使用 \ 将一行语句分为多行显示。如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">128</span></span><br><span class="line">b = <span class="number">1024</span></span><br><span class="line">c = <span class="number">512</span></span><br><span class="line">d = a + \</span><br><span class="line">    b - \</span><br><span class="line">    c</span><br></pre></td></tr></table></figure><p>如果包含在 []、{}、() 括号中，则不需要使用 \。如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr = &#123;</span><br><span class="line">    a,</span><br><span class="line">    b,</span><br><span class="line">    c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Python变量及基本数据"><a href="#Python变量及基本数据" class="headerlink" title="Python变量及基本数据"></a>Python变量及基本数据</h1><h2 id="类型介绍"><a href="#类型介绍" class="headerlink" title="类型介绍"></a>类型介绍</h2><p>在Python编程语言中，数据类型是一个重要的概念，它决定了变量可以保存何种类型的数据以及可以对这些变量执行哪些操作。Python有几种基本（或内置）的数据类型，包括整数（int）、浮点数（float）、字符串（str）等，但请注意字符（char）这一概念在Python中并不作为一个独立的基本数据类型存在，字符通常被视为长度为1的字符串。</p><h3 id="1-整数（Integers）"><a href="#1-整数（Integers）" class="headerlink" title="1. 整数（Integers）"></a>1. 整数（Integers）</h3><p>整数是没有小数部分的数字，可以是正数或负数。在Python中，整数的大小只受限于可用内存。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span>   <span class="comment"># 定义一个整数</span></span><br><span class="line">y = -<span class="number">20</span>  <span class="comment"># 定义一个负整数</span></span><br></pre></td></tr></table></figure><p>Python 3中的整数是动态大小的，意味着Python整数可以处理任意大小的整数，只要内存允许。</p><h3 id="2-浮点数（Floating-Point-Numbers）"><a href="#2-浮点数（Floating-Point-Numbers）" class="headerlink" title="2. 浮点数（Floating Point Numbers）"></a>2. 浮点数（Floating Point Numbers）</h3><p>浮点数是有小数点的数字，它们用于表示实数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1.23</span>   <span class="comment"># 定义一个浮点数</span></span><br><span class="line">y = -<span class="number">4.56</span>  <span class="comment"># 定义一个负的浮点数</span></span><br></pre></td></tr></table></figure><p>浮点数在计算机中的表示是近似的，因此在进行浮点数运算时要特别注意精度问题。</p><h3 id="3-字符串（Strings）"><a href="#3-字符串（Strings）" class="headerlink" title="3. 字符串（Strings）"></a>3. 字符串（Strings）</h3><p>字符串是由零个或多个字符组成的有序字符序列。在Python中，字符串是不可变的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">&quot;Hello&quot;</span>  <span class="comment"># 定义一个字符串</span></span><br><span class="line">s2 = <span class="string">&#x27;World&#x27;</span>  <span class="comment"># 字符串也可以用单引号定义</span></span><br></pre></td></tr></table></figure><p>字符串可以通过连接（concatenation）形成新的字符串，也可以用切片（slicing）来访问子字符串。</p><h3 id="4-字符（Characters）"><a href="#4-字符（Characters）" class="headerlink" title="4. 字符（Characters）"></a>4. 字符（Characters）</h3><p>在Python中，并没有专门的“字符”数据类型。相反，字符被视为长度为1的字符串。你可以通过索引字符串来获取单个字符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;Hello&quot;</span></span><br><span class="line">char = s[<span class="number">0</span>]  <span class="comment"># 获取字符串中的第一个字符，结果为 &#x27;H&#x27;</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>char</code> 实际上是一个长度为1的字符串，它包含了字符 ‘H’。在Python中处理单个字符时，你通常会使用长度为1的字符串。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个变量money，并赋值为10</span></span><br><span class="line">money = <span class="number">10</span></span><br><span class="line"><span class="comment"># 对money变量进行减法操作，减去5</span></span><br><span class="line">money = money - <span class="number">5</span></span><br><span class="line"><span class="comment"># 打印money变量的值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;余额为&quot;</span>, money, <span class="string">&quot;元&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="查看数据类型"><a href="#查看数据类型" class="headerlink" title="查看数据类型"></a>查看数据类型</h2><p>可以使用<code>type()</code>函数来查看一个变量的数据类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义几个变量，并分别赋予不同的数据类型</span></span><br><span class="line">string_type = <span class="string">&quot;hello world&quot;</span></span><br><span class="line">int_type = <span class="number">666</span></span><br><span class="line">float_type = <span class="number">114.514</span></span><br><span class="line"><span class="comment"># 使用type()函数查看变量的数据类型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(string_type), <span class="built_in">type</span>(int_type), <span class="built_in">type</span>(float_type))</span><br></pre></td></tr></table></figure><p>运行这段代码，你会得到输出<code>&lt;class &#39;str&#39;&gt; &lt;class &#39;int&#39;&gt; &lt;class &#39;float&#39;&gt;</code>，说明这三个变量的数据类型分别是字符串、整数和浮点数。</p><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><p>在Python中，你可以使用内置的函数来进行数据类型之间的转换。常见的转换函数有<code>int()</code>、<code>float()</code>和<code>str()</code>。</p><ul><li><code>int(x)</code>：将x转换为一个整数。如果x是一个浮点数，会舍去小数部分。如果x是一个字符串，且字符串内容可以转换为整数，则会转换为相应的整数；<strong>否则会报错</strong>。</li><li><code>float(x)</code>：将x转换为一个浮点数。如果x是一个整数，会在其后面添加<code>.0</code>。如果x是一个字符串，且字符串内容可以转换为浮点数，则会转换为相应的浮点数；<strong>否则会报错</strong>。</li><li><code>str(x)</code>：将x转换为一个字符串。无论x是什么数据类型，都会转换为其对应的字符串形式。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将浮点数转换为字符串</span></span><br><span class="line">float_str = <span class="built_in">str</span>(<span class="number">114.514</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(float_str), float_str)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字符串转换为整数</span></span><br><span class="line">num = <span class="built_in">int</span>(<span class="string">&quot;11&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(num), num)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字符串转换为浮点数</span></span><br><span class="line">num2 = <span class="built_in">float</span>(<span class="string">&quot;1919.810&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(num2), num2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将整数转换为浮点数</span></span><br><span class="line">fnum = <span class="built_in">float</span>(<span class="number">11</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(fnum), fnum)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将浮点数转换为整数，注意这里不会四舍五入，而是直接舍去小数部分</span></span><br><span class="line">inum = <span class="built_in">int</span>(<span class="number">114.514</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(inum), inum)</span><br></pre></td></tr></table></figure><p>运行这段代码，你会得到以下输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &#x27;str&#x27;&gt; 114.514</span><br><span class="line">&lt;class &#x27;int&#x27;&gt; 11</span><br><span class="line">&lt;class &#x27;float&#x27;&gt; 1919.81</span><br><span class="line">&lt;class &#x27;float&#x27;&gt; 11.0</span><br><span class="line">&lt;class &#x27;int&#x27;&gt; 114</span><br></pre></td></tr></table></figure><p>注意在进行数据类型转换时，要确保转换是合法的，否则程序会报错。例如，尝试将一个包含非数字字符的字符串转换为整数或浮点数会导致<code>ValueError</code>。</p><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>标识符命名只允许出现:（和C++一样）</p><ul><li>英文字母</li><li>中文(不推荐)</li><li>数字(<strong>不可以开头</strong>)</li><li>下划线_</li></ul><h1 id="处理数据类型"><a href="#处理数据类型" class="headerlink" title="处理数据类型"></a>处理数据类型</h1><h2 id="Python的运算符介绍"><a href="#Python的运算符介绍" class="headerlink" title="Python的运算符介绍"></a>Python的运算符介绍</h2><h3 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="1. 算术运算符"></a>1. 算术运算符</h3><p>算术运算符用于执行基本的数学运算。</p><ul><li><code>+</code>：加法运算符，用于计算两个数的和。</li><li><code>-</code>：减法运算符，用于计算两个数的差。</li><li><code>*</code>：乘法运算符，用于计算两个数的积。</li><li><code>/</code>：除法运算符，用于计算两个数的商。<strong>(python两个整数相除会得到浮点数)</strong></li><li><code>//</code>：整除运算符，用于计算两个数整除后的结果（只保留整数部分）。整除取整方向默认为$−∞$。</li><li><code>%</code>：取模运算符，用于计算两个数相除后的余数。</li><li><code>**</code>：幂运算符，用于计算一个数的幂。</li></ul><h3 id="2-比较运算符"><a href="#2-比较运算符" class="headerlink" title="2. 比较运算符"></a>2. 比较运算符</h3><p>比较运算符用于比较两个值的大小关系，返回一个布尔值（True或False）。</p><ul><li><code>==</code>：等于运算符，用于判断两个值是否相等。</li><li><code>!=</code>：不等于运算符，用于判断两个值是否不相等。</li><li><code>&gt;</code>：大于运算符，用于判断左侧的值是否大于右侧的值。</li><li><code>&lt;</code>：小于运算符，用于判断左侧的值是否小于右侧的值。</li><li><code>&gt;=</code>：大于等于运算符，用于判断左侧的值是否大于或等于右侧的值。</li><li><code>&lt;=</code>：小于等于运算符，用于判断左侧的值是否小于或等于右侧的值。</li></ul><h3 id="3-逻辑运算符"><a href="#3-逻辑运算符" class="headerlink" title="3. 逻辑运算符"></a>3. 逻辑运算符</h3><p>逻辑运算符用于组合多个条件表达式，返回一个布尔值。</p><ul><li><p><code>and</code>：逻辑与运算符，当所有条件都为True时，返回True。</p></li><li><p><code>or</code>：逻辑或运算符，当至少有一个条件为True时，返回True。</p></li><li><p><code>not</code>：逻辑非运算符，用于取反一个布尔值。</p><blockquote><h4 id="Python中的逻辑判断：与、或、非"><a href="#Python中的逻辑判断：与、或、非" class="headerlink" title="Python中的逻辑判断：与、或、非"></a><strong>Python中的逻辑判断：与、或、非</strong></h4><p>在Python中，逻辑运算符用于连接布尔表达式，并根据这些表达式的真假值返回结果。与Java等其他语言相比，Python的逻辑运算符有一些独特之处，特别是在处理非布尔类型的值时。</p><h5 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h5><p>Python中的逻辑运算符包括：</p><ul><li><code>and</code>：逻辑与</li><li><code>or</code>：逻辑或</li><li><code>not</code>：逻辑非</li></ul><h6 id="逻辑运算符的行为"><a href="#逻辑运算符的行为" class="headerlink" title="逻辑运算符的行为"></a>逻辑运算符的行为</h6><h5 id="逻辑与-and"><a href="#逻辑与-and" class="headerlink" title="逻辑与 (and)"></a>逻辑与 (<code>and</code>)</h5><p>当使用<code>and</code>运算符时：</p><ul><li>如果所有表达式的值都为真（非零、非空等），则返回最后一个表达式的值。</li><li>如果有一个或多个表达式的值为假（零、空等），则返回第一个假值。</li></ul><h6 id="逻辑或-or"><a href="#逻辑或-or" class="headerlink" title="逻辑或 (or)"></a>逻辑或 (<code>or</code>)</h6><p>当使用<code>or</code>运算符时：</p><ul><li>如果有一个或多个表达式的值为真，则返回第一个真值。</li><li>如果所有表达式的值都为假，则返回最后一个假值。</li></ul><h5 id="逻辑非-not"><a href="#逻辑非-not" class="headerlink" title="逻辑非 (not)"></a>逻辑非 (<code>not</code>)</h5><p><code>not</code>运算符返回表达式的布尔否定值。如果表达式为真，则返回<code>False</code>；如果表达式为假，则返回<code>True</code>。</p><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p>下面是一些Python逻辑运算符的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 逻辑与 (and)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span> &gt; <span class="number">2</span> <span class="keyword">and</span> <span class="number">3</span> &gt; <span class="number">1</span>)  <span class="comment"># True，因为两个条件都为真</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span> <span class="keyword">and</span> <span class="number">2</span>)          <span class="comment"># 2，因为3为真，返回第二个值2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">0</span> <span class="keyword">and</span> <span class="literal">None</span>)       <span class="comment"># 0，因为0为假，返回第一个假值0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 逻辑或 (or)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span> &gt; <span class="number">2</span> <span class="keyword">or</span> <span class="number">3</span> &gt; <span class="number">1</span>)   <span class="comment"># True，因为至少有一个条件为真</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span> <span class="keyword">or</span> <span class="number">3</span> &gt; <span class="number">2</span>)       <span class="comment"># 2，因为2为真，返回第一个真值2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">0</span> <span class="keyword">or</span> <span class="literal">None</span>)        <span class="comment"># None，因为两者都为假，返回最后一个假值None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 逻辑非 (not)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">not</span> <span class="number">3</span>)            <span class="comment"># False，因为3为真值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">not</span> <span class="number">0</span>)            <span class="comment"># True，因为0为假值</span></span><br></pre></td></tr></table></figure><h4 id="为假的值"><a href="#为假的值" class="headerlink" title="为假的值"></a>为假的值</h4><p>在Python中，以下值在布尔上下文中被视为<code>False</code>：</p><ul><li>数值类型中的<code>0</code>和<code>0.0</code></li><li>空序列类型，如空字符串<code>&#39;&#39;</code>、空列表<code>[]</code>、空元组<code>()</code>、空字典<code>&#123;&#125;</code></li><li><code>None</code>对象</li><li>布尔类型本身的<code>False</code>值</li></ul><p>需要注意的是，当这些“假值”作为逻辑表达式的一部分时，它们本身会被返回作为结果，而不是布尔值<code>False</code>。这是Python逻辑运算符与其他语言（如Java）的一个主要区别。在Java中，逻辑运算符只能用于布尔表达式，并且结果总是布尔值。而在Python中，逻辑运算符可以更加灵活地用于不同类型的值，并返回这些值本身作为结果。这种特性使得Python代码在某些情况下可以更加简洁和高效。但同时也需要注意逻辑运算符的这种行为可能会带来的潜在混淆和错误。因此在使用时需要特别小心并确保理解其行为规则。</p></blockquote></li></ul><h3 id="4-位运算符"><a href="#4-位运算符" class="headerlink" title="4. 位运算符"></a>4. 位运算符</h3><p>位运算符用于对二进制位进行操作。</p><ul><li><code>&amp;</code>：按位与运算符，对两个数的二进制位进行与操作。</li><li><code>|</code>：按位或运算符，对两个数的二进制位进行或操作。</li><li><code>^</code>：按位异或运算符，对两个数的二进制位进行异或操作。</li><li><code>~</code>：按位取反运算符，对一个数的二进制位进行取反操作。</li><li><code>&lt;&lt;</code>：左移运算符，将一个数的二进制位向左移动指定的位数。</li><li><code>&gt;&gt;</code>：右移运算符，将一个数的二进制位向右移动指定的位数。</li></ul><h3 id="5-赋值运算符"><a href="#5-赋值运算符" class="headerlink" title="5. 赋值运算符"></a>5. 赋值运算符</h3><p>赋值运算符用于将表达式的值赋给变量。</p><ul><li><code>=</code>：赋值运算符，将右侧表达式的值赋给左侧的变量。</li><li><code>+=</code>：加法赋值运算符，将右侧的值加到左侧的变量上，并将结果赋给左侧的变量。</li><li><code>-=</code>：减法赋值运算符，将右侧的值从左侧的变量中减去，并将结果赋给左侧的变量。</li><li><code>*=</code>：乘法赋值运算符，将右侧的值与左侧的变量相乘，并将结果赋给左侧的变量。</li><li><code>/=</code>：除法赋值运算符，将左侧的变量除以右侧的值，并将结果赋给左侧的变量。</li><li><code>%=</code>：取模赋值运算符，将左侧变量与右侧值进行取模运算，并将结果赋给左侧的变量。</li><li><code>**=</code>：幂赋值运算符，将左侧变量进行幂运算后的结果赋给左侧的变量。</li><li><code>//=</code>：整除赋值运算符，将左侧变量与右侧值进行整除运算后的结果赋给左侧的变量。</li></ul><h3 id="6-身份运算符"><a href="#6-身份运算符" class="headerlink" title="6. 身份运算符"></a>6. 身份运算符</h3><p>身份运算符用于比较两个对象的身份是否相同。</p><ul><li><code>is</code>：判断两个标识符是否引用同一个对象。</li><li><code>is not</code>：判断两个标识符是否引用不同的对象。</li></ul><h3 id="7-成员运算符"><a href="#7-成员运算符" class="headerlink" title="7. 成员运算符"></a>7. 成员运算符</h3><p>成员运算符用于判断一个值是否存在于序列中（如列表、元组、字符串等）。</p><ul><li><code>in</code>：如果指定的值在序列中找到，则返回True，否则返回False。</li><li><code>not in</code>：如果指定的值没有在序列中找到，则返回True，否则返回False。</li></ul><p>这些运算符在Python编程中非常常用，掌握它们对于编写高效的Python代码至关重要。</p><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p>在Python中，你可以使用加号（<code>+</code>）操作符来拼接（连接）两个或多个字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">&quot;abcd&quot;</span></span><br><span class="line">s2 = <span class="string">&quot;defg&quot;</span></span><br><span class="line">s3 = s1 + s2</span><br><span class="line"><span class="built_in">print</span>(s3)  <span class="comment"># 输出：abcddefg</span></span><br></pre></td></tr></table></figure><h3 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h3><p>Python 提供了多种方式来格式化字符串，其中 <code>%</code> 操作符是一种较旧的方法，但在某些情况下仍然很有用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用%s作为字符串占位符，%d作为整数占位符，%f作为浮点数占位符</span></span><br><span class="line">num = <span class="number">114514</span></span><br><span class="line">s = <span class="string">&quot;abcde&quot;</span></span><br><span class="line">message1 = <span class="string">&quot;%s你好世界&quot;</span> % s</span><br><span class="line"><span class="built_in">print</span>(message1)  <span class="comment"># 输出：abcde你好世界</span></span><br><span class="line"></span><br><span class="line">message2 = <span class="string">&quot;%s你好世界%d&quot;</span> % (s, num)</span><br><span class="line"><span class="built_in">print</span>(message2)  <span class="comment"># 输出：abcde你好世界114514</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 另一个例子，包含浮点数</span></span><br><span class="line">s = <span class="string">&quot;绩点&quot;</span></span><br><span class="line">gpa = <span class="number">0.1</span></span><br><span class="line">num = <span class="number">666</span></span><br><span class="line">message = <span class="string">&quot;%s高达%.1f,老铁%d&quot;</span> % (s, gpa, num)</span><br><span class="line"><span class="built_in">print</span>(message)  <span class="comment"># 输出：绩点高达0.1,老铁666</span></span><br></pre></td></tr></table></figure><p>注意：<code>%.1f</code> 表示浮点数将被格式化为小数点后保留一位。</p><h4 id="字符串格式化的一种快速写法"><a href="#字符串格式化的一种快速写法" class="headerlink" title="字符串格式化的一种快速写法"></a>字符串格式化的一种快速写法</h4><p>格式:<code>f”内容&#123;变量&#125;”</code>(不关心精度控制)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;绩点&quot;</span></span><br><span class="line">gpa = <span class="number">0.1</span></span><br><span class="line">num = <span class="number">666</span></span><br><span class="line">message = <span class="string">f&quot;<span class="subst">&#123;s&#125;</span>高达<span class="subst">&#123;gpa&#125;</span>,大佬<span class="subst">&#123;num&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">print</span>(message)</span><br></pre></td></tr></table></figure><h3 id="字符转ASCII和ASCII转字符串"><a href="#字符转ASCII和ASCII转字符串" class="headerlink" title="字符转ASCII和ASCII转字符串"></a>字符转ASCII和ASCII转字符串</h3><p>在Python中，你可以使用 <code>ord()</code> 函数将一个字符转换成其对应的ASCII数值，使用 <code>chr()</code> 函数将一个ASCII数值转换成对应的字符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>))  <span class="comment"># 输出：97</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="number">97</span>))   <span class="comment"># 输出：a</span></span><br></pre></td></tr></table></figure><h3 id="字符串的大小写转化"><a href="#字符串的大小写转化" class="headerlink" title="字符串的大小写转化"></a>字符串的大小写转化</h3><p>Python 提供了几种方法来改变字符串的大小写。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 title() 方法将字符串中每个单词的首字母变成大写，其余小写</span></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;wHat a beaUTIFul GIrl!!&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.title())  <span class="comment"># 输出：What A Beautiful Girl!!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 upper() 方法将字符串中所有字母变成大写</span></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;Cpp Is The Best Programing Language&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.upper())  <span class="comment"># 输出：CPP IS THE BEST PROGRAMING LANGUAGE</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 lower() 方法将字符串中所有字母变成小写</span></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;I HATE PYTHOn&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.lower())  <span class="comment"># 输出：i hate python</span></span><br></pre></td></tr></table></figure><p>注意：这些方法都不会改变原始字符串，而是返回一个新的字符串。因为Python中的字符串是不可变的。</p><h3 id="浮点数精度控制"><a href="#浮点数精度控制" class="headerlink" title="浮点数精度控制"></a>浮点数精度控制</h3><h4 id="使用-格式化浮点数"><a href="#使用-格式化浮点数" class="headerlink" title="使用%格式化浮点数"></a>使用%格式化浮点数</h4><p>下面是一些使用<code>%</code>运算符和<code>.yf</code>格式来格式化浮点数的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个浮点数  </span></span><br><span class="line">number = <span class="number">3.141592653589793</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 使用%格式化方法，保留两位小数  </span></span><br><span class="line">formatted_number = <span class="string">&quot;%.2f&quot;</span> % number  </span><br><span class="line"><span class="built_in">print</span>(formatted_number)  <span class="comment"># 输出: 3.14  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 如果需要指定总宽度（包括小数点和小数），则使用x.yf格式  </span></span><br><span class="line"><span class="comment"># 但这里的总宽度仅包括小数点前的数字、小数点和小数点后的数字，不包括可能的负号或指数部分  </span></span><br><span class="line">formatted_number_with_width = <span class="string">&quot;%8.2f&quot;</span> % number  </span><br><span class="line"><span class="built_in">print</span>(formatted_number_with_width)  <span class="comment"># 输出: &quot;    3.14&quot;（前面有空格填充以达到总宽度8）  </span></span><br></pre></td></tr></table></figure><h1 id="条件与循环"><a href="#条件与循环" class="headerlink" title="条件与循环"></a>条件与循环</h1><h2 id="1-条件语句"><a href="#1-条件语句" class="headerlink" title="1. 条件语句"></a>1. 条件语句</h2><h3 id="1-1-布尔类型"><a href="#1-1-布尔类型" class="headerlink" title="1.1 布尔类型"></a>1.1 布尔类型</h3><p>布尔类型（bool）用于表示逻辑值，其中 <code>True</code> 表示真（逻辑上的1），<code>False</code> 表示假（逻辑上的0）。</p><h3 id="1-2-条件表达式"><a href="#1-2-条件表达式" class="headerlink" title="1.2 条件表达式"></a>1.2 条件表达式</h3><p>条件表达式的结果是布尔类型。例如，比较运算符（如 <code>&gt;</code>、<code>&lt;</code>、<code>==</code> 等）的结果就是布尔类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num1 = <span class="number">11</span></span><br><span class="line">num2 = <span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;11 &gt; 20 的结果是 <span class="subst">&#123;<span class="number">11</span> &gt; <span class="number">20</span>&#125;</span>, 类型为 <span class="subst">&#123;<span class="built_in">type</span>(<span class="number">11</span> &gt; <span class="number">20</span>)&#125;</span>&quot;</span>)  <span class="comment"># 输出 False 和 &lt;class &#x27;bool&#x27;&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-3-if-elif-else-语句"><a href="#1-3-if-elif-else-语句" class="headerlink" title="1.3 if-elif-else 语句"></a>1.3 if-elif-else 语句</h3><p><code>if-elif-else</code> 语句用于根据条件执行不同的代码块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入一个数字：&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> num &lt; <span class="number">10</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;num&#125;</span> &lt; 10&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> num &lt;= <span class="number">100</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;num&#125;</span> &lt;= 100&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure><p>在这个例子中，根据输入的数字大小，程序会输出不同的结果。<strong>注意要写$:$</strong></p><h3 id="1-4-pass-语句"><a href="#1-4-pass-语句" class="headerlink" title="1.4 pass 语句"></a>1.4 pass 语句</h3><p><code>pass</code> 是一个空语句，它不做任何事情。它通常用作占位符，以保持程序结构的完整性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入一个数字：&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> num &lt;= <span class="number">100</span>:</span><br><span class="line">    <span class="keyword">pass</span>  <span class="comment"># 这里什么也不做</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(num)  <span class="comment"># 只有当 num &gt; 100 时才会执行这条语句</span></span><br></pre></td></tr></table></figure><h2 id="2-循环语句"><a href="#2-循环语句" class="headerlink" title="2. 循环语句"></a>2. 循环语句</h2><h3 id="2-1-while-循环"><a href="#2-1-while-循环" class="headerlink" title="2.1 while 循环"></a>2.1 while 循环</h3><p><code>while</code> 循环会重复执行一段代码，直到条件不再满足为止。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span></span><br><span class="line">add = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> x &lt;= <span class="number">100</span>:</span><br><span class="line">    add += x  <span class="comment"># 累加 x 的值到 add 变量中</span></span><br><span class="line">    x += <span class="number">1</span>    <span class="comment"># x 自增 1</span></span><br><span class="line"><span class="built_in">print</span>(add)  <span class="comment"># 输出累加结果，从 1 加到 100 的和为 5050</span></span><br></pre></td></tr></table></figure><h3 id="2-2-for-循环"><a href="#2-2-for-循环" class="headerlink" title="2.2 for 循环"></a>2.2 for 循环</h3><p><code>for</code> 循环用于遍历序列类型（如字符串、列表、元组等）中的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;abcdef&quot;</span></span><br><span class="line"><span class="keyword">for</span> ch <span class="keyword">in</span> s:  <span class="comment"># 遍历字符串 s 中的每个字符</span></span><br><span class="line">    <span class="keyword">if</span> ch == <span class="string">&quot;a&quot;</span>:</span><br><span class="line">        <span class="keyword">continue</span>  <span class="comment"># 跳过当前循环的剩余部分，进入下一次循环</span></span><br><span class="line">    <span class="keyword">if</span> ch == <span class="string">&quot;e&quot;</span>:</span><br><span class="line">        <span class="keyword">break</span>  <span class="comment"># 跳出整个循环</span></span><br><span class="line">    <span class="built_in">print</span>(ch)  <span class="comment"># 输出字符，但不会输出 &quot;a&quot; 和 &quot;e&quot; 之后的字符</span></span><br></pre></td></tr></table></figure><h3 id="2-3-range-函数"><a href="#2-3-range-函数" class="headerlink" title="2.3 range() 函数"></a>2.3 range() 函数</h3><p><code>range()</code> 函数用于生成一个数字序列。它有三种用法：</p><ul><li><code>range(num)</code>：生成从 0 开始到 num-1 的数字序列。</li><li><code>range(num1, num2)</code>：生成从 num1 开始到 num2-1 的数字序列。</li><li><code>range(num1, num2, step)</code>：生成从 num1 开始到 num2-1 的数字序列，步长为 step。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 range() 函数的例子</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>, <span class="number">11</span>, <span class="number">2</span>):  <span class="comment"># 生成 [5, 7, 9] 这样的序列并遍历它</span></span><br><span class="line">    <span class="built_in">print</span>(x, end=<span class="string">&#x27; &#x27;</span>)  <span class="comment"># 输出每个数字并用空格分隔它们，结果是 5 7 9</span></span><br><span class="line"><span class="built_in">print</span>()  <span class="comment"># 输出一个换行符以美观结束输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 另一个例子：倒序输出 10 到 1 的数字序列</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>, <span class="number">0</span>, -<span class="number">1</span>):  <span class="comment"># 生成 [10, 9, 8, ..., 1] 这样的序列并遍历它（注意不包含0）</span></span><br><span class="line">    <span class="built_in">print</span>(i, end=<span class="string">&#x27; &#x27;</span>)  <span class="comment"># 输出每个数字并用空格分隔它们，结果是 10 9 8 7 6 5 4 3 2 1</span></span><br><span class="line"><span class="built_in">print</span>()  <span class="comment"># 同样输出一个换行符以结束输出</span></span><br></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数定义与调用"><a href="#函数定义与调用" class="headerlink" title="函数定义与调用"></a>函数定义与调用</h2><p>在Python中，函数是通过<code>def</code>关键字定义的，后面跟函数名和括号内的参数列表。函数体由一系列语句组成，并且使用缩进来表示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">function_name</span>(<span class="params">parameters</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Docstring: 函数说明文档&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 函数体：由语句组成，执行特定的任务</span></span><br><span class="line">    <span class="keyword">return</span> result  <span class="comment"># 可选：返回函数执行的结果</span></span><br></pre></td></tr></table></figure><p>调用函数时，需要在函数名后加上括号和必要的参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = function_name(arguments)  <span class="comment"># 调用函数，并将返回值存储在变量中（如果有返回值的话）</span></span><br></pre></td></tr></table></figure><blockquote><p> 注：Python不支持函数重载</p></blockquote><h2 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h2><p>如果函数中有<code>return</code>语句，那么函数会返回<code>return</code>后面的值。如果函数中没有<code>return</code>语句或者<code>return</code>语句后面没有跟任何值，那么函数会默认返回<code>None</code>。</p><h3 id="多返回值"><a href="#多返回值" class="headerlink" title="多返回值"></a>多返回值</h3><p>在Python中，函数不仅可以返回单个值，还可以返回多个值。</p><h4 id="函数多返回值"><a href="#函数多返回值" class="headerlink" title="函数多返回值"></a>函数多返回值</h4><p>当函数需要返回多个值时，可以将这些值<strong>以逗号分隔</strong>放在<code>return</code>语句后。这些值会被打包成一个元组返回。调用函数时，可以使用多个变量来接收这些返回值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test01</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">11</span>, <span class="number">22</span></span><br><span class="line"></span><br><span class="line">x, y = test01()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;x=<span class="subst">&#123;x&#125;</span>, y=<span class="subst">&#123;y&#125;</span>&quot;</span>)  <span class="comment"># 输出：x=11, y=22</span></span><br></pre></td></tr></table></figure><p>函数也可以返回不同类型的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test02</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">11</span>, <span class="number">4.5</span>, <span class="string">&quot;14&quot;</span></span><br><span class="line"></span><br><span class="line">x, y, z = test02()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;x=<span class="subst">&#123;x&#125;</span>, y=<span class="subst">&#123;y&#125;</span>, z=<span class="subst">&#123;z&#125;</span>&quot;</span>)  <span class="comment"># 输出：x=11, y=4.5, z=14</span></span><br></pre></td></tr></table></figure><h2 id="函数的参数传递"><a href="#函数的参数传递" class="headerlink" title="函数的参数传递"></a>函数的参数传递</h2><h3 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h3><p>位置参数是按照函数声明中参数的顺序来传递的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test03</span>(<span class="params">name, age, gender</span>):</span><br><span class="line">    <span class="built_in">print</span>(name, age, gender)</span><br><span class="line"></span><br><span class="line">test03(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">10</span>, <span class="string">&#x27;Male&#x27;</span>)  <span class="comment"># 输出：Tom 10 Male</span></span><br></pre></td></tr></table></figure><h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>关键字参数是通过参数名来指定要传递的参数值。关键字参数可以不按照函数声明中的顺序来传递，但是要注意在函数调用时关键字参数的名称必须与函数声明中的参数名一致。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test04</span>(<span class="params">name, age, gender</span>):</span><br><span class="line">    <span class="built_in">print</span>(name, age, gender)</span><br><span class="line"></span><br><span class="line">test04(name=<span class="string">&#x27;Tom&#x27;</span>, age=<span class="number">10</span>, gender=<span class="string">&#x27;Male&#x27;</span>)  <span class="comment"># 输出：Tom 10 Male</span></span><br></pre></td></tr></table></figure><p>关键字参数和位置参数可以混用，但位置参数必须放在关键字参数前面。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test05</span>(<span class="params">name, age, gender</span>):</span><br><span class="line">    <span class="built_in">print</span>(name, age, gender)</span><br><span class="line"></span><br><span class="line">test05(<span class="string">&#x27;Tom&#x27;</span>, age=<span class="number">10</span>, gender=<span class="string">&#x27;Male&#x27;</span>)  <span class="comment"># 输出：Tom 10 Male</span></span><br></pre></td></tr></table></figure><h3 id="缺省参数"><a href="#缺省参数" class="headerlink" title="缺省参数"></a>缺省参数</h3><p>缺省参数是指在函数声明时为参数指定一个默认值。如果在函数调用时没有为该参数传递值，则使用默认值。<strong>缺省参数必须放在函数声明的最后</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test06</span>(<span class="params">name, age, gender=<span class="string">&quot;Male&quot;</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(name, age, gender)</span><br><span class="line"></span><br><span class="line">test06(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">10</span>)  <span class="comment"># 输出：Tom 10 Male</span></span><br></pre></td></tr></table></figure><h3 id="不定长参数"><a href="#不定长参数" class="headerlink" title="不定长参数"></a>不定长参数</h3><p>不定长参数是指函数可以接受任意数量的参数。在函数声明中，使用<code>*args</code>来表示接受任意数量的位置参数，使用<code>**kwargs</code>来表示接受任意数量的关键字参数。这些参数在函数内部被收集为一个元组或一个字典。</p><h4 id="位置传递（-args）"><a href="#位置传递（-args）" class="headerlink" title="位置传递（*args）"></a>位置传递（*args）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test07</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line"></span><br><span class="line">test07(<span class="string">&#x27;Jerry&#x27;</span>)  <span class="comment"># 输出：(&#x27;Jerry&#x27;,)</span></span><br><span class="line">test07(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">10</span>)  <span class="comment"># 输出：(&#x27;Tom&#x27;, 10)</span></span><br><span class="line">test07(<span class="string">&#x27;Trump&#x27;</span>, <span class="number">77</span>, <span class="string">&#x27;Male&#x27;</span>)  <span class="comment"># 输出：(&#x27;Trump&#x27;, 77, &#x27;Male&#x27;)</span></span><br></pre></td></tr></table></figure><h4 id="关键字传递（-kwargs）"><a href="#关键字传递（-kwargs）" class="headerlink" title="关键字传递（**kwargs）"></a>关键字传递（**kwargs）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test08</span>(<span class="params">**kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(kwargs)</span><br><span class="line"></span><br><span class="line">test08(name=<span class="string">&#x27;TOM&#x27;</span>, age=<span class="number">18</span>, <span class="built_in">id</span>=<span class="number">110</span>)  <span class="comment"># 输出：&#123;&#x27;name&#x27;: &#x27;TOM&#x27;, &#x27;age&#x27;: 18, &#x27;id&#x27;: 110&#125;</span></span><br></pre></td></tr></table></figure><h2 id="局部变量与全局变量"><a href="#局部变量与全局变量" class="headerlink" title="局部变量与全局变量"></a>局部变量与全局变量</h2><p>在函数内部定义的变量是局部变量，只能在该函数内部访问。在函数外部定义的变量是全局变量，可以在任何地方访问，包括函数内部（除非被局部变量覆盖）。</p><p>如果需要在函数内部修改全局变量，需要使用<code>global</code>关键字声明。</p><h2 id="函数说明文档（Docstring）"><a href="#函数说明文档（Docstring）" class="headerlink" title="函数说明文档（Docstring）"></a>函数说明文档（Docstring）</h2><p>函数说明文档是一种特殊的注释，用于解释函数的作用、参数和返回值。它位于函数定义的开始，由三个双引号（可以是三个单引号）包围。</p><p>Docstring可以通过<code>help()</code>函数或者函数的<code>__doc__</code>属性查看。</p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>下面是一个包含函数定义、调用、局部变量、全局变量和Docstring的示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局变量</span></span><br><span class="line">num = <span class="number">200</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">strlen</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计算字符串的长度</span></span><br><span class="line"><span class="string">    :param s: 输入的字符串</span></span><br><span class="line"><span class="string">    :return: 字符串的长度</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    length = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">        length += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> length</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_global</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    演示全局变量的访问和修改</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">global</span> num  <span class="comment"># 声明是全局变量</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Global num before modification: <span class="subst">&#123;num&#125;</span>&quot;</span>)</span><br><span class="line">    num = <span class="number">500</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Global num after modification: <span class="subst">&#123;num&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_local</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    演示局部变量的作用范围</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    local_num = <span class="number">100</span>  <span class="comment"># 局部变量</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Local num: <span class="subst">&#123;local_num&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数并打印结果</span></span><br><span class="line">s1 = <span class="string">&quot;Hello, world!&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Length of &#x27;<span class="subst">&#123;s1&#125;</span>&#x27;: <span class="subst">&#123;strlen(s1)&#125;</span>&quot;</span>)  <span class="comment"># 调用strlen函数计算字符串长度并打印结果</span></span><br><span class="line">test_global()  <span class="comment"># 调用test_global函数修改全局变量并打印结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Global num after test_global function: <span class="subst">&#123;num&#125;</span>&quot;</span>)  <span class="comment"># 打印修改后的全局变量值以确认修改生效</span></span><br><span class="line">test_local()  <span class="comment"># 调用test_local函数演示局部变量的作用范围（不会修改全局变量）</span></span><br></pre></td></tr></table></figure><h1 id="Python中的数据结构"><a href="#Python中的数据结构" class="headerlink" title="Python中的数据结构"></a>Python中的数据结构</h1><h2 id="List——列表"><a href="#List——列表" class="headerlink" title="List——列表"></a>List——列表</h2><h3 id="定义列表"><a href="#定义列表" class="headerlink" title="定义列表"></a>定义列表</h3><p>在Python中，列表（List）是一种可变的数据容器，可以包含任意类型的对象：数字、字符串、其他列表等。列表中的元素通过逗号分隔，并包含在方括号 <code>[]</code> 中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个字符串列表</span></span><br><span class="line">name_list = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(name_list)  <span class="comment"># 输出: [&#x27;abc&#x27;, &#x27;def&#x27;, &#x27;ghi&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(name_list))  <span class="comment"># 输出: &lt;class &#x27;list&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表可以存储多种不同类型的元素</span></span><br><span class="line">my_list = [<span class="string">&quot;abc&quot;</span>, <span class="number">666</span>, <span class="literal">True</span>]</span><br><span class="line"><span class="built_in">print</span>(my_list)  <span class="comment"># 输出: [&#x27;abc&#x27;, 666, True]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(my_list))  <span class="comment"># 输出: &lt;class &#x27;list&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表支持嵌套</span></span><br><span class="line">two_dimension = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]]</span><br><span class="line"><span class="built_in">print</span>(two_dimension)  <span class="comment"># 输出: [[1, 2, 3], [4, 5, 6]]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(two_dimension))  <span class="comment"># 输出: &lt;class &#x27;list&#x27;&gt;</span></span><br></pre></td></tr></table></figure><h3 id="下标索引"><a href="#下标索引" class="headerlink" title="下标索引"></a>下标索引</h3><p>列表中的元素可以通过下标索引来访问。在Python中，下标从0开始。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(my_list[<span class="number">0</span>])  <span class="comment"># 输出: abc</span></span><br><span class="line"><span class="built_in">print</span>(my_list[<span class="number">1</span>])  <span class="comment"># 输出: def</span></span><br><span class="line"><span class="built_in">print</span>(my_list[<span class="number">2</span>])  <span class="comment"># 输出: ghi</span></span><br></pre></td></tr></table></figure><p>尝试访问超出范围的索引会导致<code>IndexError</code>。</p><h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><p>在Python中，你可以使用<code>list.index()</code>函数来查找列表中某个元素的索引。这个函数会返回元素在列表中首次出现的索引，如果元素不在列表中，则会抛出一个<code>ValueError</code>异常。</p><p>下面是一个基本的使用示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个列表  </span></span><br><span class="line">my_list = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;cherry&#x27;</span>, <span class="string">&#x27;date&#x27;</span>]  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 查找&#x27;banana&#x27;的索引  </span></span><br><span class="line">index = my_list.index(<span class="string">&#x27;banana&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 输出索引  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;The index of &#x27;banana&#x27; is <span class="subst">&#123;index&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>这段代码会输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash复制代码</span><br><span class="line">The index of <span class="string">&#x27;banana&#x27;</span> is 1</span><br></pre></td></tr></table></figure><p>因为在这个列表中，’banana’的索引是1（索引是从0开始的）。</p><h3 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h3><p>列表中的元素可以通过下标索引来修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>]</span><br><span class="line">my_list[<span class="number">1</span>] = <span class="string">&quot;bcd&quot;</span></span><br><span class="line"><span class="built_in">print</span>(my_list)  <span class="comment"># 输出: [&#x27;abc&#x27;, &#x27;bcd&#x27;, &#x27;ghi&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><h4 id="insert-方法"><a href="#insert-方法" class="headerlink" title=".insert()方法"></a>.insert()方法</h4><p>使用<code>.insert()</code>方法可以在列表的指定位置插入一个元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>]</span><br><span class="line">my_list.insert(<span class="number">1</span>, <span class="string">&quot;666&quot;</span>)  <span class="comment"># 在下标1处插入&quot;666&quot;</span></span><br><span class="line"><span class="built_in">print</span>(my_list)  <span class="comment"># 输出: [&#x27;abc&#x27;, &#x27;666&#x27;, &#x27;def&#x27;, &#x27;ghi&#x27;]</span></span><br></pre></td></tr></table></figure><h4 id="append-方法"><a href="#append-方法" class="headerlink" title=".append()方法"></a>.append()方法</h4><p>使用<code>.append()</code>方法可以在列表的末尾追加一个元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>]</span><br><span class="line">my_list.append(<span class="string">&quot;jkl&quot;</span>)  <span class="comment"># 在末尾追加&quot;jkl&quot;</span></span><br><span class="line"><span class="built_in">print</span>(my_list)  <span class="comment"># 输出: [&#x27;abc&#x27;, &#x27;def&#x27;, &#x27;ghi&#x27;, &#x27;jkl&#x27;]</span></span><br></pre></td></tr></table></figure><h4 id="extend-方法"><a href="#extend-方法" class="headerlink" title=".extend()方法"></a>.extend()方法</h4><p>使用<code>.extend()</code>方法可以在列表的末尾追加另一个容器（例如列表）的所有元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>]</span><br><span class="line">my_list.extend([<span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqr&quot;</span>])  <span class="comment"># 追加另一个列表的所有元素</span></span><br><span class="line"><span class="built_in">print</span>(my_list)  <span class="comment"># 输出: [&#x27;abc&#x27;, &#x27;def&#x27;, &#x27;ghi&#x27;, &#x27;jkl&#x27;, &#x27;mno&#x27;, &#x27;pqr&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><h4 id="del语句"><a href="#del语句" class="headerlink" title="del语句"></a>del语句</h4><p>使用<code>del</code>语句可以删除列表中指定位置的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>]</span><br><span class="line"><span class="keyword">del</span> my_list[<span class="number">1</span>]  <span class="comment"># 删除下标为1的元素</span></span><br><span class="line"><span class="built_in">print</span>(my_list)  <span class="comment"># 输出: [&#x27;abc&#x27;, &#x27;ghi&#x27;, &#x27;jkl&#x27;]</span></span><br></pre></td></tr></table></figure><h4 id="pop-方法"><a href="#pop-方法" class="headerlink" title=".pop()方法"></a>.pop()方法</h4><p>使用<code>.pop()</code>方法可以删除并返回列表中指定位置的元素。如果不提供索引，则默认删除并返回最后一个元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>]</span><br><span class="line">element = my_list.pop(<span class="number">1</span>)  <span class="comment"># 删除下标为1的元素，并将其值赋给element</span></span><br><span class="line"><span class="built_in">print</span>(element)  <span class="comment"># 输出: def</span></span><br><span class="line"><span class="built_in">print</span>(my_list)  <span class="comment"># 输出: [&#x27;abc&#x27;, &#x27;ghi&#x27;, &#x27;jkl&#x27;]</span></span><br></pre></td></tr></table></figure><h4 id="remove-方法"><a href="#remove-方法" class="headerlink" title=".remove()方法"></a>.remove()方法</h4><p>使用<code>.remove()</code>方法可以删除列表中第一个出现的指定元素。如果元素不存在于列表中，则会导致<code>ValueError</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>]</span><br><span class="line">my_list.remove(<span class="string">&quot;def&quot;</span>)  <span class="comment"># 删除第一个出现的&quot;def&quot;</span></span><br><span class="line"><span class="built_in">print</span>(my_list)  <span class="comment"># 输出: [&#x27;abc&#x27;, &#x27;ghi&#x27;, &#x27;jkl&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="清空列表"><a href="#清空列表" class="headerlink" title="清空列表"></a>清空列表</h3><p>使用<code>.clear()</code>方法可以清空列表中的所有元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>]</span><br><span class="line">my_list.clear()  <span class="comment"># 清空列表</span></span><br><span class="line"><span class="built_in">print</span>(my_list)  <span class="comment"># 输出: []</span></span><br></pre></td></tr></table></figure><h3 id="统计元素数量"><a href="#统计元素数量" class="headerlink" title="统计元素数量"></a>统计元素数量</h3><p>使用<code>.count()</code>方法可以统计列表中某个元素出现的次数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(my_list.count(<span class="number">1</span>))  <span class="comment"># 输出: 2，因为1在列表中出现了2次</span></span><br></pre></td></tr></table></figure><h3 id="列表长度"><a href="#列表长度" class="headerlink" title="列表长度"></a>列表长度</h3><p>使用内置函数<code>len()</code>可以获取列表的长度（即元素的数量）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(my_list))  <span class="comment"># 输出: 5，因为列表中有5个元素</span></span><br></pre></td></tr></table></figure><h3 id="遍历容器"><a href="#遍历容器" class="headerlink" title="遍历容器"></a>遍历容器</h3><p>可以使用<code>for</code>循环来遍历列表中的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> ele <span class="keyword">in</span> my_list:</span><br><span class="line">    <span class="built_in">print</span>(ele, end=<span class="string">&quot; &quot;</span>)  <span class="comment"># 输出: 1 2 3 4 5 </span></span><br></pre></td></tr></table></figure><p>如果需要在遍历过程中同时获取元素的下标和值，可以使用<code>enumerate()</code>函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> index, item <span class="keyword">in</span> <span class="built_in">enumerate</span>(my_list, start=<span class="number">1</span>):  <span class="comment"># 设置下标从1开始</span></span><br><span class="line">    <span class="built_in">print</span>(index, item)  <span class="comment"># 输出元素的下标和值</span></span><br></pre></td></tr></table></figure><p>这将输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 apple</span><br><span class="line">2 banana</span><br><span class="line">3 cherry</span><br></pre></td></tr></table></figure><blockquote><p>如果start=0，将输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;0 apple</span><br><span class="line">1 banana</span><br><span class="line">2 cherry</span><br></pre></td></tr></table></figure></blockquote><h3 id="Python中列表的拷贝方法"><a href="#Python中列表的拷贝方法" class="headerlink" title="Python中列表的拷贝方法"></a>Python中列表的拷贝方法</h3><p>在Python中，拷贝一个列表可以有多种方法，但每种方法都有其特定的用途和后果。本笔记将详细介绍使用赋值运算符（<code>=</code>）、<code>.copy()</code>方法，以及<code>copy</code>模块中的<code>deepcopy()</code>函数进行列表拷贝的区别。</p><h4 id="1-赋值运算符（-）"><a href="#1-赋值运算符（-）" class="headerlink" title="1. 赋值运算符（=）"></a>1. 赋值运算符（<code>=</code>）</h4><p>使用赋值运算符并不是真正的拷贝，而是创建了一个新的引用指向同一个列表对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]</span><br><span class="line">list2 = list1  <span class="comment"># 这不是拷贝，list2只是指向list1的引用</span></span><br></pre></td></tr></table></figure><p>在这种情况下，<code>list1</code>和<code>list2</code>实际上是指向内存中同一个对象的两个不同名字。任何对<code>list2</code>的修改都会反映到<code>list1</code>上，反之亦然。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list2.append(<span class="number">6</span>)  <span class="comment"># 修改list2</span></span><br><span class="line"><span class="built_in">print</span>(list1)  <span class="comment"># 输出: [1, 2, 3, [4, 5], 6] —— list1也被修改了</span></span><br></pre></td></tr></table></figure><h4 id="2-copy-方法（浅拷贝）"><a href="#2-copy-方法（浅拷贝）" class="headerlink" title="2. .copy()方法（浅拷贝）"></a>2. <code>.copy()</code>方法（浅拷贝）</h4><p>Python的列表对象有一个<code>.copy()</code>方法，用于创建列表的浅拷贝。这意味着它创建了列表的一个新副本，但副本中的元素仍然是原始列表中元素的引用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]</span><br><span class="line">list2 = list1.copy()  <span class="comment"># 执行浅拷贝</span></span><br></pre></td></tr></table></figure><p>现在，<code>list1</code>和<code>list2</code>是两个不同的列表对象，<strong>但它们的元素（特别是可变对象，如内部列表）仍然是共享的。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list2[<span class="number">3</span>][<span class="number">0</span>] = <span class="string">&#x27;four&#x27;</span>  <span class="comment"># 修改list2中的内部列表</span></span><br><span class="line"><span class="built_in">print</span>(list1)  <span class="comment"># 输出: [1, 2, 3, [&#x27;four&#x27;, 5]] —— list1也被影响了</span></span><br></pre></td></tr></table></figure><p>尽管<code>list1</code>和<code>list2</code>是不同的列表对象，但由于浅拷贝的性质，它们共享对内部列表的引用。</p><h4 id="3-deepcopy-函数（深拷贝）"><a href="#3-deepcopy-函数（深拷贝）" class="headerlink" title="3. deepcopy()函数（深拷贝）"></a>3. <code>deepcopy()</code>函数（深拷贝）</h4><p><strong>要创建一个完全独立的列表拷贝，包括其所有嵌套对象，应使用<code>copy</code>模块中的<code>deepcopy()</code>函数</strong>。深拷贝会递归地复制对象及其所有子对象，生成一个全新的对象树。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]</span><br><span class="line">list2 = copy.deepcopy(list1)  <span class="comment"># 执行深拷贝</span></span><br></pre></td></tr></table></figure><p>现在，<code>list2</code>是<code>list1</code>的一个完全独立的拷贝，包括所有嵌套对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list2[<span class="number">3</span>][<span class="number">0</span>] = <span class="string">&#x27;four&#x27;</span>  <span class="comment"># 修改list2中的内部列表</span></span><br><span class="line"><span class="built_in">print</span>(list1)  <span class="comment"># 输出: [1, 2, 3, [4, 5]] —— list1未受影响</span></span><br></pre></td></tr></table></figure><p>修改<code>list2</code>不会影响<code>list1</code>，因为<code>deepcopy()</code>创建了所有对象的独立拷贝。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>赋值运算符（<code>=</code>）不创建拷贝，只创建引用。</li><li><code>.copy()</code>方法执行浅拷贝，创建新列表但<strong>共享嵌套对象</strong>。</li><li><code>deepcopy()</code>函数执行深拷贝，递归地复制所有对象，生成完全独立的对象树。</li></ul><h2 id="tuple——元组"><a href="#tuple——元组" class="headerlink" title="tuple——元组"></a>tuple——元组</h2><p><strong>和list的区别是不可修改</strong></p><p>元组（Tuple）是Python中的一种不可变序列类型，用于存储一系列有序的元素。与列表（List）不同，元组一旦定义，就不能再修改其内容。元组通常用于存储不应该被改变的数据集合。</p><h3 id="定义元组"><a href="#定义元组" class="headerlink" title="定义元组"></a>定义元组</h3><p>元组使用圆括号<code>()</code>来定义，元素之间使用逗号<code>,</code>分隔。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个包含多个元素的元组</span></span><br><span class="line">my_tuple = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;hello&#x27;</span>, <span class="number">5.5</span>)</span><br><span class="line"><span class="built_in">print</span>(my_tuple)  <span class="comment"># 输出：(1, 2, 3, &#x27;hello&#x27;, 5.5)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个空元组</span></span><br><span class="line">empty_tuple = ()</span><br><span class="line"><span class="built_in">print</span>(empty_tuple)  <span class="comment"># 输出：()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以使用tuple()函数来创建一个空元组</span></span><br><span class="line">another_empty_tuple = <span class="built_in">tuple</span>()</span><br><span class="line"><span class="built_in">print</span>(another_empty_tuple)  <span class="comment"># 输出：()</span></span><br></pre></td></tr></table></figure><p>注意，如果元组只包含一个元素，那么该元素后面必须跟一个逗号，否则它不会被识别为元组。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个包含单个元素的元组（注意逗号）</span></span><br><span class="line">single_element_tuple = (<span class="number">42</span>,)</span><br><span class="line"><span class="built_in">print</span>(single_element_tuple)  <span class="comment"># 输出：(42,)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(single_element_tuple))  <span class="comment"># 输出：&lt;class &#x27;tuple&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果没有逗号，它会被当作一个普通的表达式，而不是元组</span></span><br><span class="line">not_a_tuple = (<span class="number">42</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(not_a_tuple))  <span class="comment"># 输出：&lt;class &#x27;int&#x27;&gt;，因为它被当作了一个整数</span></span><br></pre></td></tr></table></figure><h3 id="元组的不可变性"><a href="#元组的不可变性" class="headerlink" title="元组的不可变性"></a>元组的不可变性</h3><p>元组是不可变的，这意味着一旦创建了一个元组，你就不能添加、删除或更改其元素。尝试这样做会导致TypeError。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_tuple = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># 尝试修改元组（会导致错误）</span></span><br><span class="line"><span class="comment"># my_tuple[0] = 0  # TypeError: &#x27;tuple&#x27; object does not support item assignment</span></span><br></pre></td></tr></table></figure><p>然而，如果元组中包含可变对象（如列表），那么这些对象的内容是可以被修改的。但请注意，你不能更改这些可变对象在元组中的身份（即不能用一个新的列表替换原有的列表）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 元组中包含一个列表</span></span><br><span class="line">my_tuple_with_list = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="comment"># 修改列表的内容是可以的</span></span><br><span class="line">my_tuple_with_list[<span class="number">2</span>][<span class="number">0</span>] = -<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(my_tuple_with_list)  <span class="comment"># 输出：(1, 2, [-1, 4, 5])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 尝试用一个新的列表替换原有的列表（会导致错误）</span></span><br><span class="line"><span class="comment"># my_tuple_with_list[2] = [6, 7, 8]  # TypeError: &#x27;tuple&#x27; object does not support item assignment</span></span><br></pre></td></tr></table></figure><p>在实际应用中，如果你需要一个不可变的序列来存储数据，并且这些数据在程序的整个生命周期中都不会改变，那么使用元组是一个很好的选择。元组的不可变性也使其在某些情况下比列表更加高效，因为Python可以在内部对其进行优化。</p><h2 id="string——字符串"><a href="#string——字符串" class="headerlink" title="string——字符串"></a>string——字符串</h2><p>字符串（String）是 Python 中常见的数据容器之一，用于存储字符序列。字符串具有一些独特的特点和操作方法。</p><h3 id="字符串的访问"><a href="#字符串的访问" class="headerlink" title="字符串的访问"></a>字符串的访问</h3><p>字符串中的字符可以通过下标进行访问。下标从0开始递增，表示从前往后访问字符；而从-1开始递减，则表示从后往前访问字符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">0</span>])  <span class="comment"># 输出: H</span></span><br><span class="line"><span class="built_in">print</span>(s[-<span class="number">1</span>]) <span class="comment"># 输出: !</span></span><br></pre></td></tr></table></figure><h3 id="字符串的不可变性"><a href="#字符串的不可变性" class="headerlink" title="字符串的不可变性"></a>字符串的不可变性</h3><p>同元组（Tuple）一样，字符串是一个无法修改的数据容器。一旦一个字符串被创建，就不能修改它的内容。任何对字符串的修改操作都会生成一个新的字符串对象。</p><h3 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h3><h4 id="index-方法"><a href="#index-方法" class="headerlink" title="index 方法"></a>index 方法</h4><p><code>index</code> 方法用于查找子字符串在字符串中首次出现的位置，并返回该位置的索引。如果子字符串不存在，<strong>则会抛出异常</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;you are a handsome boy&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.index(<span class="string">&quot;hand&quot;</span>))  <span class="comment"># 输出: 10</span></span><br></pre></td></tr></table></figure><h4 id="replace-方法"><a href="#replace-方法" class="headerlink" title="replace 方法"></a>replace 方法</h4><p><code>replace</code> 方法用于将字符串中的某个子字符串替换为另一个字符串，并返回替换后的新字符串。原始字符串本身不会被修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;cats and dogs are good cats and dogs and cats and dogs do things cats and dogs like do&quot;</span></span><br><span class="line">s1 = s.replace(<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;tiger&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># 输出原始字符串</span></span><br><span class="line"><span class="built_in">print</span>(s1) <span class="comment"># 输出替换后的新字符串</span></span><br></pre></td></tr></table></figure><h4 id="split-方法"><a href="#split-方法" class="headerlink" title="split 方法"></a>split 方法</h4><p><code>split</code> 方法用于根据指定的分隔符将字符串分割成多个子字符串，并将这些子字符串存储在列表中返回。原始字符串本身不会被修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;cats and dogs are good cats and dogs and cats and dogs do things cats and dogs like do&quot;</span></span><br><span class="line">l = s.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># 输出原始字符串</span></span><br><span class="line"><span class="built_in">print</span>(l)  <span class="comment"># 输出分割后的列表</span></span><br></pre></td></tr></table></figure><h4 id="strip-方法"><a href="#strip-方法" class="headerlink" title="strip 方法"></a>strip 方法</h4><p><code>strip</code> 方法用于去除字符串开头和结尾的空白字符（包括空格、制表符、换行符等），并返回处理后的新字符串。原始字符串本身不会被修改。如果指定了参数，则会去除前后指定的字符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;  12abcde1  &quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.strip())      <span class="comment"># 输出: &quot;12abcde1&quot;</span></span><br><span class="line">s = <span class="string">&quot;12abcde1&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.strip(<span class="string">&quot;12&quot;</span>))  <span class="comment">#输出:&quot;abcde&quot;</span></span><br></pre></td></tr></table></figure><h4 id="count-方法"><a href="#count-方法" class="headerlink" title="count 方法"></a>count 方法</h4><p><code>count</code> 方法用于统计某个子字符串在字符串中出现的次数，并返回该次数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;114514514114514514114114&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.count(<span class="string">&quot;114&quot;</span>))  <span class="comment"># 输出: 4</span></span><br></pre></td></tr></table></figure><h4 id="len-函数"><a href="#len-函数" class="headerlink" title="len 函数"></a>len 函数</h4><p><code>len</code> 函数用于获取字符串的长度，即字符的个数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;114514514114514514114114&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(s))  <span class="comment"># 输出: 24</span></span><br></pre></td></tr></table></figure><p>请注意，虽然 <code>len</code> 是一个内置函数而不是字符串的方法，但它经常用于获取字符串的长度，因此在这里也一并提及。</p><h3 id="Python-中常用处理字符串的相关函数"><a href="#Python-中常用处理字符串的相关函数" class="headerlink" title="Python 中常用处理字符串的相关函数"></a>Python 中常用处理字符串的相关函数</h3><p>在Python中，字符串是不可变的，但Python提供了很多方法来操作字符串。这些方法可以帮助我们完成各种任务，如查找子字符串，替换子字符串，分割字符串等。下面列出了一些Python中常用的字符串方法：</p><h4 id="字符串首字母大写"><a href="#字符串首字母大写" class="headerlink" title="字符串首字母大写"></a>字符串首字母大写</h4><p><code>string.capitalize()</code></p><p>该方法返回字符串的一个副本，其中第一个字符为大写，其余为小写。</p><h4 id="计数子字符串"><a href="#计数子字符串" class="headerlink" title="计数子字符串"></a>计数子字符串</h4><p><code>string.count(str, beg=0, end=len(string))</code></p><p>该方法返回子字符串在字符串中出现的次数。可选参数<code>beg</code>和<code>end</code>是字符串中要开始和结束搜索的索引范围。</p><h4 id="检查字符串结束"><a href="#检查字符串结束" class="headerlink" title="检查字符串结束"></a>检查字符串结束</h4><p><code>string.endswith(obj, beg=0, end=len(string))</code></p><p>该方法检查字符串是否以指定的后缀结束，如果是则返回<code>True</code>，否则返回<code>False</code>。可选参数<code>beg</code>和<code>end</code>指定需要检查的字符串的子集。</p><h4 id="查找子字符串"><a href="#查找子字符串" class="headerlink" title="查找子字符串"></a>查找子字符串</h4><p><code>string.find(str, beg=0, end=len(string))</code></p><p>该方法检测字符串中是否包含子字符串<code>str</code>，如果包含则返回开始的索引值，否则返回-1。搜索可以指定开始和结束的索引范围。</p><h4 id="类似find但异常"><a href="#类似find但异常" class="headerlink" title="类似find但异常"></a>类似find但异常</h4><p><code>string.index(str, beg=0, end=len(string))</code></p><p>与<code>find()</code>方法类似，但如果子字符串不在字符串中，则会引发一个异常。</p><h4 id="检查字母和数字"><a href="#检查字母和数字" class="headerlink" title="检查字母和数字"></a>检查字母和数字</h4><ul><li><code>string.isalnum()</code>：如果字符串至少有一个字符并且所有字符都是字母或数字，则返回<code>True</code>。</li><li><code>string.isalpha()</code>：如果字符串至少有一个字符并且所有字符都是字母，则返回<code>True</code>。</li><li><code>string.isdecimal()</code>：如果字符串只包含十进制数字，则返回<code>True</code>。</li><li><code>string.isdigit()</code>：如果字符串只包含数字，则返回<code>True</code>。</li></ul><h4 id="检查大小写"><a href="#检查大小写" class="headerlink" title="检查大小写"></a>检查大小写</h4><ul><li><code>string.islower()</code>：如果字符串中包含至少一个区分大小写的字符，并且所有这些字符都是小写，则返回<code>True</code>。</li><li><code>string.isupper()</code>：如果字符串中包含至少一个区分大小写的字符，并且所有这些字符都是大写，则返回<code>True</code>。</li></ul><h4 id="其他检查"><a href="#其他检查" class="headerlink" title="其他检查"></a>其他检查</h4><ul><li><code>string.isnumeric()</code>：如果字符串中只包含数字字符，则返回<code>True</code>。</li><li><code>string.isspace()</code>：如果字符串中只包含空格，则返回<code>True</code>。</li><li><code>string.istitle()</code>：如果字符串是标题化的（即每个单词的首字母大写），则返回<code>True</code>。</li></ul><h4 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h4><p><strong><code>string.join(seq)</code></strong></p><p>该方法以指定的字符串作为分隔符，将序列中的元素连接成一个新的字符串。</p><p><strong>使用加号 <code>+</code> 运算符</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">&quot;Hello&quot;</span>  </span><br><span class="line">str2 = <span class="string">&quot;World&quot;</span>  </span><br><span class="line">str3 = str1 + <span class="string">&quot; &quot;</span> + str2  </span><br><span class="line"><span class="built_in">print</span>(str3)  <span class="comment"># 输出: Hello World</span></span><br></pre></td></tr></table></figure><p>在这个例子中，我们使用了 <code>+</code> 运算符和空格字符串来连接 <code>str1</code> 和 <code>str2</code>。</p><h4 id="转换大小写"><a href="#转换大小写" class="headerlink" title="转换大小写"></a>转换大小写</h4><ul><li><code>string.lower()</code>：将字符串中的所有大写字符转换为小写。</li><li><code>string.upper()</code>：将字符串中的所有小写字符转换为大写。</li></ul><h4 id="去除空格"><a href="#去除空格" class="headerlink" title="去除空格"></a>去除空格</h4><ul><li><code>string.lstrip()</code>：删除字符串左边的空格。</li><li><code>string.rstrip()</code>：删除字符串右边的空格（注：该方法未在上文列出，但经常与<code>lstrip()</code>一起使用）。</li><li><code>string.strip([obj])</code>：在字符串上同时执行<code>lstrip()</code>和<code>rstrip()</code>，删除两端的空格或指定字符。</li></ul><h4 id="替换子字符串"><a href="#替换子字符串" class="headerlink" title="替换子字符串"></a>替换子字符串</h4><p><code>string.replace(str1, str2, num=string.count(str1))</code></p><p>该方法把字符串中的<code>str1</code>替换成<code>str2</code>，如果指定了<code>num</code>，则替换不超过<code>num</code>次。</p><h4 id="分割字符串"><a href="#分割字符串" class="headerlink" title="分割字符串"></a>分割字符串</h4><p><code>string.split(str=&quot;&quot;, num=string.count(str))</code></p><p>该方法以指定的分隔符切片字符串，如果指定了<code>num</code>，则仅分隔出<code>num+1</code>个子字符串。</p><h4 id="检查字符串开始"><a href="#检查字符串开始" class="headerlink" title="检查字符串开始"></a>检查字符串开始</h4><p><code>string.startswith(obj, beg=0, end=len(string))</code></p><p>该方法检查字符串是否以指定的前缀开始，如果是则返回<code>True</code>，否则返回<code>False</code>。</p><h4 id="交换大小写"><a href="#交换大小写" class="headerlink" title="交换大小写"></a>交换大小写</h4><p><code>string.swapcase()</code></p><p>该方法翻转字符串中的大小写，即大写变小写，小写变大写。</p><h4 id="标题化字符串"><a href="#标题化字符串" class="headerlink" title="标题化字符串"></a>标题化字符串</h4><p><code>string.title()</code></p><p>该方法返回“标题化”的字符串，即所有单词的首字母大写，其余小写。</p><p>需要注意的是，字符串的方法很多，而且功能强大，但这里只列出了一些常用的方法。在实际编程中，可以根据需要选择合适的方法来操作字符串。</p><h2 id="序列的切片"><a href="#序列的切片" class="headerlink" title="序列的切片"></a>序列的切片</h2><p>序列是内容连续、有序，且可以使用下标索引的一类数据容器。在Python中，列表、元组、字符串均可以视为序列。</p><p>对序列进行切片操作可以得到序列的一个子序列。切片操作使用冒号(<code>:</code>)分隔的下标索引来实现，基本语法为<code>sequence[start:end:step]</code>，其中：</p><ul><li><code>sequence</code>表示要进行切片操作的序列。</li><li><code>start</code>表示切片操作的起始位置（包含该位置），如果省略则表示从头开始。</li><li><code>end</code>表示切片操作的结束位置（不包含该位置），如果省略则表示直到序列末尾。</li><li><code>step</code>表示切片操作的步长，即每隔多少个元素取一个，如果省略则表示步长为1。</li></ul><p>注意，<strong>切片操作不会影响序列本身</strong>，而是会得到一个新的序列。</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><h4 id="列表切片"><a href="#列表切片" class="headerlink" title="列表切片"></a>列表切片</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mylist = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从索引1开始到索引4之前（不包含索引4）的子序列</span></span><br><span class="line">result1 = mylist[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(result1)  <span class="comment"># 输出: [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从索引2开始到索引9之前，每隔2个元素取一个的子序列</span></span><br><span class="line">result2 = mylist[<span class="number">2</span>:<span class="number">9</span>:<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(result2)  <span class="comment"># 输出: [2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure><h4 id="元组切片"><a href="#元组切片" class="headerlink" title="元组切片"></a>元组切片</h4><p>元组的切片操作与列表类似。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mytuple = (<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从头到尾的子序列（复制整个元组）</span></span><br><span class="line">r1 = mytuple[:]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;r1=<span class="subst">&#123;r1&#125;</span>&quot;</span>)  <span class="comment"># 输出: r1=(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从尾到头的子序列（反转整个元组）</span></span><br><span class="line">r2 = mytuple[::-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;r2=<span class="subst">&#123;r2&#125;</span>&quot;</span>)  <span class="comment"># 输出: r2=(10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)</span></span><br></pre></td></tr></table></figure><h4 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h4><p>字符串也可以进行切片操作，得到一个新的字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mystring = <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从索引7开始到末尾的子字符串</span></span><br><span class="line">result3 = mystring[<span class="number">7</span>:]</span><br><span class="line"><span class="built_in">print</span>(result3)  <span class="comment"># 输出: World!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从头开始到索引5之前（不包含索引5）的子字符串，每隔2个字符取一个</span></span><br><span class="line">result4 = mystring[:<span class="number">5</span>:<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(result4)  <span class="comment"># 输出: Hlo</span></span><br></pre></td></tr></table></figure><h2 id="Set——集合"><a href="#Set——集合" class="headerlink" title="Set——集合"></a>Set——集合</h2><p>集合是一个无序的、不重复的数据集合。在Python中，集合用花括号<code>&#123;&#125;</code>或者<code>set()</code>函数创建，但由于花括号<code>&#123;&#125;</code>同时用于表示字典，所以空集合必须用<code>set()</code>表示，而不是<code>&#123;&#125;</code>。</p><h3 id="集合的创建与特性"><a href="#集合的创建与特性" class="headerlink" title="集合的创建与特性"></a>集合的创建与特性</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用花括号创建集合（非空集合）</span></span><br><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">11</span>&#125;</span><br><span class="line"><span class="comment"># 使用set()创建空集合</span></span><br><span class="line">c = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印集合a和c</span></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 输出: &#123;1, 2, 3, 4, 5, 6, 11&#125;，注意重复元素被自动去除了</span></span><br><span class="line"><span class="built_in">print</span>(c)  <span class="comment"># 输出: set()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：空的大括号表示字典，不是集合</span></span><br><span class="line">b = &#123;&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(b))  <span class="comment"># 输出: &lt;class &#x27;dict&#x27;&gt;</span></span><br></pre></td></tr></table></figure><h3 id="集合的修改"><a href="#集合的修改" class="headerlink" title="集合的修改"></a>集合的修改</h3><p>集合是可变的，可以添加或删除元素。</p><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><p>使用<code>.add()</code>方法向集合添加元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">11</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line">a.add(<span class="number">1</span>)  <span class="comment"># 添加元素1到集合a中</span></span><br><span class="line">a.add(<span class="number">5</span>)  <span class="comment"># 添加元素5（已存在，不会重复添加）</span></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 输出: &#123;1, 2, 3, 4, 5, 6, 7, 11&#125;</span></span><br></pre></td></tr></table></figure><h4 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h4><p>使用<code>.remove()</code>方法从集合中移除指定元素；使用<code>.pop()</code>方法随机移除并返回集合中的一个元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">11</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line">a.remove(<span class="number">3</span>)  <span class="comment"># 移除元素3</span></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 输出: &#123;2, 4, 5, 6, 7, 11&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用pop()方法从集合中随机移除元素并打印</span></span><br><span class="line">a = &#123;<span class="number">11</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(a) &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(a.pop())</span><br><span class="line"><span class="comment"># 输出可能是集合a中的任意元素，因为移除是随机的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：pop()取出的过程对于字符串是随机的,即每次运行结果都不同</span></span><br></pre></td></tr></table></figure><h3 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h3><h4 id="差集"><a href="#差集" class="headerlink" title="差集"></a>差集</h4><p>使用<code>.difference()</code>方法可以得到两个集合的差集，即存在于第一个集合但不存在于第二个集合的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;</span><br><span class="line">diff = set1.difference(set2)</span><br><span class="line"><span class="built_in">print</span>(diff)  <span class="comment"># 输出: &#123;1, 2, 3&#125;，这些元素只存在于set1中</span></span><br></pre></td></tr></table></figure><h4 id="差集并更新左集合"><a href="#差集并更新左集合" class="headerlink" title="差集并更新左集合"></a>差集并更新左集合</h4><p>使用<code>.difference_update()</code>方法可以直接更新左集合为差集结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;</span><br><span class="line">set1.difference_update(set2)  <span class="comment"># set1现在更新为差集结果</span></span><br><span class="line"><span class="built_in">print</span>(set1)  <span class="comment"># 输出: &#123;1, 2, 3&#125;</span></span><br></pre></td></tr></table></figure><h4 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h4><p>使用<code>.union()</code>方法可以得到两个集合的并集，即两个集合中所有不重复的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">union_set = set1.union(set2)</span><br><span class="line"><span class="built_in">print</span>(union_set)  <span class="comment"># 输出: &#123;1, 2, 3, 4, 5&#125;</span></span><br></pre></td></tr></table></figure><h3 id="集合的长度"><a href="#集合的长度" class="headerlink" title="集合的长度"></a>集合的长度</h3><p>使用<code>len()</code>函数可以得到集合中元素的数量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(a))  <span class="comment"># 输出: 9，因为集合自动去除了重复元素</span></span><br></pre></td></tr></table></figure><h3 id="集合的遍历"><a href="#集合的遍历" class="headerlink" title="集合的遍历"></a>集合的遍历</h3><p>由于集合不支持下标索引，所以不能使用<code>while</code>循环通过下标来遍历集合。但可以使用<code>for</code>循环直接遍历集合中的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">for</span> ele <span class="keyword">in</span> set1:</span><br><span class="line">    <span class="built_in">print</span>(ele, end=<span class="string">&quot; &quot;</span>)  <span class="comment"># 输出: 1 2 3 4 5（顺序可能不同，因为集合是无序的）</span></span><br></pre></td></tr></table></figure><h2 id="字典——dict"><a href="#字典——dict" class="headerlink" title="字典——dict"></a>字典——dict</h2><p>字典（dict）是Python中的一种基本数据结构，用于存储键值对（key-value pairs）。字典是无序的，即元素的插入顺序和迭代顺序可能不一致。<strong>字典的键（key）必须是不可变的类型</strong>，如整数、浮点数、字符串、元组等，而值（value）可以是任意Python对象。</p><h3 id="创建字典"><a href="#创建字典" class="headerlink" title="创建字典"></a>创建字典</h3><p>字典可以通过大括号 <code>&#123;&#125;</code> 或 <code>dict()</code> 函数来创建。大括号中，键值对之间用冒号分隔，每对键值对之间用逗号分隔。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d1 = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">97</span>, <span class="string">&quot;b&quot;</span>: <span class="number">98</span>, <span class="string">&quot;c&quot;</span>: <span class="number">99</span>, <span class="string">&quot;d&quot;</span>: <span class="number">100</span>&#125;</span><br><span class="line">d2 = &#123;&#125;  <span class="comment"># 空字典</span></span><br><span class="line">d3 = <span class="built_in">dict</span>()  <span class="comment"># 通过dict()函数创建空字典</span></span><br></pre></td></tr></table></figure><h3 id="访问字典元素"><a href="#访问字典元素" class="headerlink" title="访问字典元素"></a>访问字典元素</h3><p>字典中的元素可以通过键来访问。使用方括号 <code>[]</code> 和键名来获取对应的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d1 = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">97</span>, <span class="string">&quot;b&quot;</span>: <span class="number">98</span>, <span class="string">&quot;c&quot;</span>: <span class="number">99</span>, <span class="string">&quot;d&quot;</span>: <span class="number">100</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(d1[<span class="string">&quot;b&quot;</span>])  <span class="comment"># 输出 98</span></span><br></pre></td></tr></table></figure><h3 id="新增和更新字典元素"><a href="#新增和更新字典元素" class="headerlink" title="新增和更新字典元素"></a>新增和更新字典元素</h3><p>可以通过方括号 <code>[]</code> 来新增或更新字典中的元素。如果键已经存在，则对应的值会被更新；如果键不存在，则会在字典中新增一个键值对。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d1 = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">97</span>, <span class="string">&quot;b&quot;</span>: <span class="number">98</span>&#125;</span><br><span class="line">d1[<span class="string">&quot;c&quot;</span>] = <span class="number">99</span>  <span class="comment"># 新增键值对</span></span><br><span class="line">d1[<span class="string">&quot;a&quot;</span>] = <span class="number">100</span>  <span class="comment"># 更新键&quot;a&quot;对应的值</span></span><br></pre></td></tr></table></figure><p>需要注意的是，<strong>字典不支持访问不存在的键，否则会抛出<code>KeyError</code>异常</strong>。如果尝试访问不存在的键，可以使用<code>get()</code>方法，该方法允许指定一个默认值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d1 = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">97</span>, <span class="string">&quot;b&quot;</span>: <span class="number">98</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(d1.get(<span class="string">&quot;c&quot;</span>, <span class="string">&quot;Not Found&quot;</span>))  <span class="comment"># 输出 &quot;Not Found&quot;</span></span><br></pre></td></tr></table></figure><h3 id="删除字典元素"><a href="#删除字典元素" class="headerlink" title="删除字典元素"></a>删除字典元素</h3><p>可以使用<code>pop()</code>方法来删除字典中的元素，并返回被删除元素的值。<strong>如果尝试删除不存在的键，<code>pop()</code>方法会抛出<code>KeyError</code>异常，但可以通过提供第二个参数来指定一个默认值</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d1 = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">97</span>, <span class="string">&quot;b&quot;</span>: <span class="number">98</span>, <span class="string">&quot;c&quot;</span>: <span class="number">99</span>&#125;</span><br><span class="line">value = d1.pop(<span class="string">&quot;b&quot;</span>)  <span class="comment"># 删除键&quot;b&quot;并返回其值</span></span><br><span class="line"><span class="built_in">print</span>(value)  <span class="comment"># 输出 98</span></span><br></pre></td></tr></table></figure><p>另外，<code>clear()</code>方法可以清空字典中的所有元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d1.clear()  <span class="comment"># 清空字典</span></span><br><span class="line"><span class="built_in">print</span>(d1)  <span class="comment"># 输出 &#123;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="获取字典的键和值"><a href="#获取字典的键和值" class="headerlink" title="获取字典的键和值"></a>获取字典的键和值</h3><p>可以使用<code>keys()</code>方法获取字典中所有的键，<code>values()</code>方法获取所有的值。<strong>这两个方法返回的都是视图对象，它们会反映字典的任何更改。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d1 = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">97</span>, <span class="string">&quot;b&quot;</span>: <span class="number">98</span>, <span class="string">&quot;c&quot;</span>: <span class="number">99</span>&#125;</span><br><span class="line">keys = d1.keys()</span><br><span class="line">values = d1.values()</span><br><span class="line"><span class="built_in">print</span>(keys)  <span class="comment"># 输出 dict_keys([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;])</span></span><br><span class="line"><span class="built_in">print</span>(values)  <span class="comment"># 输出 dict_values([97, 98, 99])</span></span><br></pre></td></tr></table></figure><h3 id="遍历字典"><a href="#遍历字典" class="headerlink" title="遍历字典"></a>遍历字典</h3><p>字典可以通过多种方式进行遍历。最常见的是遍历所有的键，然后使用键来访问对应的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d1 = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">97</span>, <span class="string">&quot;b&quot;</span>: <span class="number">98</span>, <span class="string">&quot;c&quot;</span>: <span class="number">99</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> d1:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;key=<span class="subst">&#123;key&#125;</span>, value=<span class="subst">&#123;d1[key]&#125;</span>&quot;</span>, end=<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure><p>还可以直接遍历字典的项（键值对），这可以通过<code>items()</code>方法来实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> d1.items():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;key=<span class="subst">&#123;key&#125;</span>, value=<span class="subst">&#123;value&#125;</span>&quot;</span>, end=<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="统计字典元素数量"><a href="#统计字典元素数量" class="headerlink" title="统计字典元素数量"></a>统计字典元素数量</h3><p>使用<code>len()</code>函数可以获取字典中元素的数量（键值对的数量）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d1 = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">97</span>, <span class="string">&quot;b&quot;</span>: <span class="number">98</span>, <span class="string">&quot;c&quot;</span>: <span class="number">99</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(d1))  <span class="comment"># 输出 3</span></span><br></pre></td></tr></table></figure><h3 id="判断元素是否在字典内"><a href="#判断元素是否在字典内" class="headerlink" title="判断元素是否在字典内"></a>判断元素是否在字典内</h3><p>可以使用<code>in</code>关键字来判断一个键是否存在于字典中。同样地，<code>not in</code>可以用来判断一个键是否不存在于字典中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d1 = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">97</span>, <span class="string">&quot;b&quot;</span>: <span class="number">98</span>, <span class="string">&quot;c&quot;</span>: <span class="number">99</span>&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;c&quot;</span> <span class="keyword">in</span> d1:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;in&quot;</span>)  <span class="comment"># 输出 in</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;p&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> d1:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;not in&quot;</span>)  <span class="comment"># 输出 not in</span></span><br></pre></td></tr></table></figure><h2 id="容器常用功能"><a href="#容器常用功能" class="headerlink" title="容器常用功能"></a>容器常用功能</h2><h3 id="容器之间的转换"><a href="#容器之间的转换" class="headerlink" title="容器之间的转换"></a>容器之间的转换</h3><h4 id="转换为列表-list"><a href="#转换为列表-list" class="headerlink" title="转换为列表(list)"></a>转换为列表(list)</h4><p>在Python中，列表（list）是一种非常常用的数据结构，它可以容纳不同类型的元素，包括数字、字符串、元组、集合甚至字典等。Python提供了便捷的方式将这些容器类型转换为列表。</p><h5 id="从元组-tuple-转换"><a href="#从元组-tuple-转换" class="headerlink" title="从元组(tuple)转换"></a>从元组(tuple)转换</h5><p>元组与列表非常相似，但元组是不可变的。我们可以使用<code>list()</code>函数将元组转换为列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a1 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(a1))  <span class="comment"># 输出: [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><h5 id="从字符串-string-转换"><a href="#从字符串-string-转换" class="headerlink" title="从字符串(string)转换"></a>从字符串(string)转换</h5><p>字符串可以被看作字符的序列，因此也可以被转换为列表，每个字符成为列表的一个元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b1 = <span class="string">&quot;abcdefg&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(b1))  <span class="comment"># 输出: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;]</span></span><br></pre></td></tr></table></figure><h5 id="从集合-set-转换"><a href="#从集合-set-转换" class="headerlink" title="从集合(set)转换"></a>从集合(set)转换</h5><p>集合是一个无序的不重复元素集，转换为列表后会得到一个包含集合中所有元素的列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(c1))  <span class="comment"># 输出可能是: [1, 2, 3, 4, 5] （因为集合是无序的，所以实际输出可能不同）</span></span><br></pre></td></tr></table></figure><h5 id="从字典-dictionary-转换"><a href="#从字典-dictionary-转换" class="headerlink" title="从字典(dictionary)转换"></a>从字典(dictionary)转换</h5><p>字典转换为列表时，默认只包含字典的键(key)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d1 = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">97</span>, <span class="string">&quot;b&quot;</span>: <span class="number">98</span>, <span class="string">&quot;c&quot;</span>: <span class="number">99</span>, <span class="string">&quot;d&quot;</span>: <span class="number">100</span>, <span class="string">&quot;e&quot;</span>: <span class="number">101</span>, <span class="string">&quot;f&quot;</span>: <span class="number">102</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(d1))  <span class="comment"># 输出: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;]（字典的键转换为列表）</span></span><br></pre></td></tr></table></figure><p><strong>如果想要同时获取键和值，可以使用<code>items()</code>方法</strong>，它会返回一个包含键值对的元组列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(d1.items()))  <span class="comment"># 输出: [(&#x27;a&#x27;, 97), (&#x27;b&#x27;, 98), (&#x27;c&#x27;, 99), (&#x27;d&#x27;, 100), (&#x27;e&#x27;, 101), (&#x27;f&#x27;, 102)]</span></span><br></pre></td></tr></table></figure><h3 id="转换为其他类型"><a href="#转换为其他类型" class="headerlink" title="转换为其他类型"></a>转换为其他类型</h3><p>当然，Python也允许我们将列表转换为其他类型，如元组、字符串、集合等。</p><h4 id="转换为元组-tuple"><a href="#转换为元组-tuple" class="headerlink" title="转换为元组(tuple)"></a>转换为元组(tuple)</h4><p>使用<code>tuple()</code>函数可以将列表转换为元组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>(lst))  <span class="comment"># 输出: (1, 2, 3, 4, 5)</span></span><br></pre></td></tr></table></figure><h4 id="转换为字符串-string"><a href="#转换为字符串-string" class="headerlink" title="转换为字符串(string)"></a>转换为字符串(string)</h4><p>在Python中，将列表转化为字符串可以通过多种方式实现。最常见的方法是使用 <code>join()</code> 方法，它可以将列表中的元素连接起来形成一个字符串。以下是一个简单的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>, <span class="string">&#x27;this&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;list&#x27;</span>]  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 使用空格作为分隔符将列表元素连接成字符串  </span></span><br><span class="line">my_string = <span class="string">&#x27; &#x27;</span>.join(my_list)  </span><br><span class="line"><span class="built_in">print</span>(my_string)  <span class="comment"># 输出：Hello world this is a list  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 如果列表中包含数字或其他非字符串类型，需要先将它们转换为字符串  </span></span><br><span class="line">my_mixed_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>]  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 使用map函数和str将列表中的每个元素转换为字符串，然后再连接  </span></span><br><span class="line">my_string_from_mixed_list = <span class="string">&#x27; &#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, my_mixed_list))  </span><br><span class="line"><span class="built_in">print</span>(my_string_from_mixed_list)  <span class="comment"># 输出：1 2 3 apple banana</span></span><br></pre></td></tr></table></figure><h4 id="转换为集合-set"><a href="#转换为集合-set" class="headerlink" title="转换为集合(set)"></a>转换为集合(set)</h4><p>使用<code>set()</code>函数可以将列表转换为集合，从而去除重复元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">set</span>(lst))  <span class="comment"># 输出: &#123;1, 2, 3, 4, 5&#125;</span></span><br></pre></td></tr></table></figure><h3 id="排序功能-sorted"><a href="#排序功能-sorted" class="headerlink" title="排序功能(sorted)"></a>排序功能(sorted)</h3><p>Python的<code>sorted()</code>函数可以对任何可迭代对象进行排序，并返回一个列表。默认情况下，排序是升序的，但<strong>可以通过<code>reverse=True</code>参数进行降序排序</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a1 = (<span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(a1))  <span class="comment"># 输出: [0, 2, 4, 5, 6] （升序）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(a1, reverse=<span class="literal">True</span>))  <span class="comment"># 输出: [6, 5, 4, 2, 0] （降序）</span></span><br></pre></td></tr></table></figure><p>对于字符串和字典的排序，<code>sorted()</code>函数会根据元素的字符顺序或键的顺序进行排序。如果想要根据其他标准进行排序，可以使用<code>key</code>参数指定一个函数来提取用于排序的值。</p><h1 id="头等函数"><a href="#头等函数" class="headerlink" title="头等函数"></a>头等函数</h1><h2 id="函数作为参数传递"><a href="#函数作为参数传递" class="headerlink" title="函数作为参数传递"></a>函数作为参数传递</h2><p>在Python中，函数是对象，可以像其他对象一样被传递作为参数。这种能力使得函数变得更加灵活和强大。你可以将函数作为参数传递给其他函数，或者从其他函数中返回函数。</p><h3 id="函数作为参数的示例"><a href="#函数作为参数的示例" class="headerlink" title="函数作为参数的示例"></a>函数作为参数的示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_func</span>(<span class="params">compute</span>):</span><br><span class="line">    result = compute(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">type</span>(compute))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将add函数作为参数传递给test_func</span></span><br><span class="line">test_func(add)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">&lt;class &#x27;function&#x27;&gt;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>test_func</code>接收一个名为<code>compute</code>的函数作为参数，并使用它来计算1和2的和。然后打印结果和<code>compute</code>的类型，显示为<code>&lt;class &#39;function&#39;&gt;</code>，表明<code>compute</code>确实是一个函数对象。</p><h2 id="使用lambda匿名函数作为参数"><a href="#使用lambda匿名函数作为参数" class="headerlink" title="使用lambda匿名函数作为参数"></a>使用lambda匿名函数作为参数</h2><p>lambda函数是一种简洁的写函数的方式，它可以在一行内定义简单的函数。lambda函数是匿名的，因为它们没有正式的函数名，但可以将它们赋值给变量，或者以其他方式使用，例如作为函数的参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_func</span>(<span class="params">compute</span>):</span><br><span class="line">    result = compute(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">type</span>(compute))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将lambda函数作为参数传递给test_func</span></span><br><span class="line">test_func(<span class="keyword">lambda</span> x, y: x + y)<span class="comment">#可以不写出return</span></span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">&lt;class &#x27;function&#x27;&gt;</span><br></pre></td></tr></table></figure><p>这里，我们创建了一个lambda函数<code>lambda x, y: x + y</code>，它接收两个参数<code>x</code>和<code>y</code>，并返回它们的和。然后我们将这个lambda函数作为参数传递给<code>test_func</code>。输出与前面的例子相同，因为lambda函数的行为与<code>add</code>函数相同。</p><p>请注意，在lambda函数中，虽然我们没有明确写出<code>return</code>关键字，但表达式<code>x + y</code>的结果会被自动返回。这是lambda函数的一个特点：它们总是返回表达式的结果。</p><p>在Python中，<strong><code>lambda</code>函数是设计为单行表达式函数的，它们只能包含一个表达式，该表达式的值会被返回。</strong>因此，<code>lambda</code>函数不支持多行语句或多条指令。如果你想定义一个多行的函数，你应该使用<code>def</code>关键字来定义一个常规函数。</p><h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><h2 id="模块的概念"><a href="#模块的概念" class="headerlink" title="模块的概念"></a>模块的概念</h2><p>在Python中，模块（Module）是一个包含Python定义和语句的文件。文件名就是模块名加上<code>.py</code>后缀。模块可以被其他程序引入，以使用该模块中的函数、类等功能。模块可以包含可执行的语句和定义函数、类和变量。模块让你能够有逻辑地组织你的Python代码段，实现代码重用。</p><h3 id="模块的导入"><a href="#模块的导入" class="headerlink" title="模块的导入"></a>模块的导入</h3><h4 id="1-使用import语句导入整个模块"><a href="#1-使用import语句导入整个模块" class="headerlink" title="1. 使用import语句导入整个模块"></a>1. 使用<code>import</code>语句导入整个模块</h4><p>你可以使用<code>import</code>语句导入整个模块，并通过模块名来访问其中的函数、类、变量等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time  <span class="comment"># 导入整个time模块</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)  <span class="comment"># 使用time模块中的sleep函数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h4 id="2-使用from-import-语句导入模块中的特定部分"><a href="#2-使用from-import-语句导入模块中的特定部分" class="headerlink" title="2. 使用from ... import ...语句导入模块中的特定部分"></a>2. 使用<code>from ... import ...</code>语句导入模块中的特定部分</h4><p>如果你只需要模块中的某个函数或类，可以使用<code>from ... import ...</code>语句将其导入到当前命名空间中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep  <span class="comment"># 只导入time模块中的sleep函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">sleep(<span class="number">1</span>)  <span class="comment"># 直接使用sleep函数，不需要加模块名前缀</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h4 id="3-使用from-import-语句导入模块中的所有内容"><a href="#3-使用from-import-语句导入模块中的所有内容" class="headerlink" title="3. 使用from ... import *语句导入模块中的所有内容"></a>3. 使用<code>from ... import *</code>语句导入模块中的所有内容</h4><p>虽然这种方式可以导入模块中的所有内容，<strong>但通常不推荐使用，因为它可能导致命名冲突和不可预见的行为。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> *  <span class="comment"># 导入time模块中的所有内容（不推荐）</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">sleep(<span class="number">1</span>)  <span class="comment"># 直接使用sleep函数，不需要加模块名前缀</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="给模块起别名"><a href="#给模块起别名" class="headerlink" title="给模块起别名"></a>给模块起别名</h3><p>如果模块名太长或与其他模块名冲突，你可以使用<code>as</code>关键字给模块起一个别名。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time <span class="keyword">as</span> t  <span class="comment"># 给time模块起别名为t</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">t.sleep(<span class="number">1</span>)  <span class="comment"># 使用别名t来访问time模块中的sleep函数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="给函数起别名"><a href="#给函数起别名" class="headerlink" title="给函数起别名"></a>给函数起别名</h3><p>同样地，你也可以使用<code>as</code>关键字给导入的函数起别名。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep <span class="keyword">as</span> sl  <span class="comment"># 给sleep函数起别名为sl</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">sl(<span class="number">1</span>)  <span class="comment"># 使用别名sl来调用sleep函数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h2 id="定义自己的模块"><a href="#定义自己的模块" class="headerlink" title="定义自己的模块"></a>定义自己的模块</h2><h3 id="自定义模块"><a href="#自定义模块" class="headerlink" title="自定义模块"></a>自定义模块</h3><p>在Python中，模块是一个包含Python定义和语句的文件。文件名是模块名加上<code>.py</code>后缀。模块可以被其他程序引入，以使用该模块中的函数、类等。在本例中，我们将创建一个简单的模块，并展示如何在其他文件中导入和使用它。</p><h3 id="创建模块"><a href="#创建模块" class="headerlink" title="创建模块"></a>创建模块</h3><p>首先，我们创建一个名为<code>greetings.py</code>的模块，它包含一个名为<code>print_hi</code>的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># greetings.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_hi</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Hi, <span class="subst">&#123;name&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    print_hi(<span class="string">&#x27;PyCharm&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在这个模块中：</p><ul><li>我们定义了一个名为<code>print_hi</code>的函数，它接受一个参数<code>name</code>，并打印出问候语。</li><li>我们使用了一个特殊的条件语句<code>if __name__ == &#39;__main__&#39;:</code>。当<strong>这个模块作为主程序运行时（即直接运行<code>greetings.py</code>文件），这个条件语句下的代码会被执行</strong>。因此，它会打印出“Hi, PyCharm”。但是，当这个模块被其他文件导入时，这个条件语句下的代码不会被执行。</li></ul><h2 id="导入和使用模块"><a href="#导入和使用模块" class="headerlink" title="导入和使用模块"></a>导入和使用模块</h2><p>现在，我们可以在另一个Python文件中导入这个模块，并使用它提供的函数。例如，创建一个名为<code>main.py</code>的文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> greetings</span><br><span class="line"></span><br><span class="line">greetings.print_hi(<span class="string">&#x27;Alice&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在这个文件中，我们使用<code>import</code>语句导入了<code>greetings</code>模块，并<strong>使用点符号（<code>.</code>）访问模块中的<code>print_hi</code>函数</strong>。当我们运行<code>main.py</code>文件时，它会输出“Hi, Alice”。</p><p>注意，由于我们在<code>greetings.py</code>文件中使用了<code>if __name__ == &#39;__main__&#39;:</code>语句，所以当我们导入这个模块时，它不会自动执行<code>print_hi(&#39;PyCharm&#39;)</code>语句。因此，输出仅为“Hi, Alice”，而不包括“Hi, PyCharm”。</p><h1 id="自定义Python包"><a href="#自定义Python包" class="headerlink" title="自定义Python包"></a>自定义Python包</h1><h2 id="什么是Python包"><a href="#什么是Python包" class="headerlink" title="什么是Python包"></a>什么是Python包</h2><p>从物理结构上看，<strong>Python包就是一个文件夹</strong>，它包含一个<code>__init__.py</code>文件，并且该文件夹内可以包含多个模块文件（即.py文件）。这个文件夹的层级结构可以表示包的层级关系。</p><p>从逻辑层面来看，包可以看作是一个更大规模的模块，它允许我们将相关的模块组织在一起，形成一个有层次的命名空间。</p><h2 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h2><p>在Python中，导入包有几种不同的方式：</p><h3 id="方式一：使用import语句"><a href="#方式一：使用import语句" class="headerlink" title="方式一：使用import语句"></a>方式一：使用import语句</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> 包名.模块名</span><br></pre></td></tr></table></figure><p>使用方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">包名.模块名.目标函数()</span><br></pre></td></tr></table></figure><h3 id="方式二：使用from…import语句"><a href="#方式二：使用from…import语句" class="headerlink" title="方式二：使用from…import语句"></a>方式二：使用from…import语句</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> 包名 <span class="keyword">import</span> 模块名</span><br></pre></td></tr></table></figure><p>使用方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模块名.目标函数()</span><br></pre></td></tr></table></figure><h3 id="方式三：直接导入目标函数"><a href="#方式三：直接导入目标函数" class="headerlink" title="方式三：直接导入目标函数"></a>方式三：直接导入目标函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> 包名.模块名 <span class="keyword">import</span> 目标函数</span><br></pre></td></tr></table></figure><p>使用方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">目标函数()</span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>在使用包中的模块或函数之前，需要确保包已经被正确安装或位于Python的搜索路径中。</li><li><code>__init__.py</code>文件是包的初始化文件，它可以是空的，也可以包含一些初始化代码或定义<code>__all__</code>变量来指定当使用<code>from 包名 import *</code>时应该导入哪些模块。</li></ul><h2 id="安装第三方包"><a href="#安装第三方包" class="headerlink" title="安装第三方包"></a>安装第三方包</h2><h3 id="什么是第三方包"><a href="#什么是第三方包" class="headerlink" title="什么是第三方包"></a>什么是第三方包</h3><p>第三方包指的是非Python官方提供的包，它们由Python社区中的开发者创建和维护。这些包通常用于解决特定的问题或提供特定的功能，例如数据处理、机器学习、网络编程等。</p><h3 id="安装第三方包-pip"><a href="#安装第三方包-pip" class="headerlink" title="安装第三方包 - pip"></a>安装第三方包 - pip</h3><p>pip是Python的包管理工具，它允许你轻松地安装、升级和卸载Python包。你可以使用pip来安装第三方包。</p><h3 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h3><p>在命令行中，使用以下命令来安装第三方包：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install 包名称</span><br></pre></td></tr></table></figure><p>这将会从Python Package Index（PyPI）下载并安装包。</p><h3 id="pip的网络优化"><a href="#pip的网络优化" class="headerlink" title="pip的网络优化"></a>pip的网络优化</h3><p>由于pip默认连接的是国外的PyPI源，有时下载速度可能会很慢。你<strong>可以通过指定国内的镜像源来加速包的下载</strong>。例如，使用清华大学提供的PyPI镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple 包名称</span><br></pre></td></tr></table></figure><p>或者，你可以永久地修改pip的配置文件，将默认的源替换为国内的镜像源。这样，每次使用pip安装包时都会自动从国内的镜像源下载。</p><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><ul><li>在安装第三方包之前，确保你的Python环境已经正确设置，并且pip工具已经安装。</li><li>有些第三方包可能依赖于其他包或特定版本的Python，因此在安装之前最好查看包的文档以了解其依赖关系和要求。</li><li><strong>如果你使用的是虚拟环境（virtualenv或conda等），则应在激活虚拟环境后安装第三方包，以确保它们仅在当前虚拟环境中可用。</strong></li></ul><h1 id="定义自己的数据类型——类和对象"><a href="#定义自己的数据类型——类和对象" class="headerlink" title="定义自己的数据类型——类和对象"></a>定义自己的数据类型——类和对象</h1><p>在Python中，类（Class）是一种抽象数据类型，它定义了包含数据（属性）和方法（函数）的对象的行为和状态。对象是类的实例，它具体地表示了类的属性和行为。</p><h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><p>类可以通过<code>class</code>关键字来定义，类的名称通常以大写字母开头。类中可以定义属性和方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cla</span>:</span><br><span class="line">    a = <span class="literal">None</span></span><br><span class="line">    b = <span class="literal">None</span></span><br><span class="line">    c = <span class="literal">None</span></span><br><span class="line">    d = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>Cla</code>是一个类，它定义了四个类属性<code>a</code>、<code>b</code>、<code>c</code>和<code>d</code>，它们都被初始化为<code>None</code>。</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>类中提供了私有成员的形式来支持。</p><ul><li>私有成员变量</li><li>私有成员方法</li></ul><p>定义私有成员的方式非常简单,只需要:</p><ul><li>私有成员变量:变量名以<code>__</code>开头(2个下划线)</li><li>私有成员方法:方法名以<code>__</code>开头（2个下划线）</li></ul><p>即可完成私有成员的设置</p><h2 id="对象的创建和属性赋值"><a href="#对象的创建和属性赋值" class="headerlink" title="对象的创建和属性赋值"></a>对象的创建和属性赋值</h2><p>要创建一个类的实例（对象），可以使用类名加上括号。然后可以通过点操作符<code>.</code>来访问对象的属性或方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c = Cla()  <span class="comment"># 创建一个Cla类的实例对象c</span></span><br><span class="line">c.a = <span class="string">&quot;abc&quot;</span>  <span class="comment"># 给对象c的a属性赋值</span></span><br><span class="line">c.b = <span class="number">1</span>      <span class="comment"># 给对象c的b属性赋值</span></span><br><span class="line">c.c = <span class="number">114.514</span>  <span class="comment"># 给对象c的c属性赋值</span></span><br><span class="line">c.d = <span class="literal">True</span>     <span class="comment"># 给对象c的d属性赋值</span></span><br></pre></td></tr></table></figure><p><strong>打印对象<code>c</code>会显示其内存地址</strong>，打印<code>type(c)</code>会显示其类型，而打印<code>c.a</code>则会显示其<code>a</code>属性的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(c)       <span class="comment"># 输出对象c的内存地址</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(c)) <span class="comment"># 输出对象c的类型</span></span><br><span class="line"><span class="built_in">print</span>(c.a)     <span class="comment"># 输出对象c的a属性的值</span></span><br></pre></td></tr></table></figure><h2 id="类的方法"><a href="#类的方法" class="headerlink" title="类的方法"></a>类的方法</h2><p>类还可以定义方法，方法是类的函数，它可以在类的对象上执行操作。<strong>方法的第一个参数总是<code>self</code>，它表示对象本身。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Man</span>:</span><br><span class="line">    name = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say_hi</span>(<span class="params">self</span>):<span class="comment">#self是必须填写的，调用类的方法的时候会自动传入该对象</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;我是<span class="subst">&#123;self.name&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say_hi_with_msg</span>(<span class="params">self, msg</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;我是<span class="subst">&#123;self.name&#125;</span>,<span class="subst">&#123;msg&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>Man</code>类定义了两个方法：<code>say_hi</code>和<code>say_hi_with_msg</code>。这两个方法都接受<code>self</code>作为第一个参数，表示对象本身。<code>say_hi</code>方法打印出对象的<code>name</code>属性，而<code>say_hi_with_msg</code>方法则打印出对象的<code>name</code>属性和一个额外的消息。</p><h3 id="对象的方法调用"><a href="#对象的方法调用" class="headerlink" title="对象的方法调用"></a>对象的方法调用</h3><p>要调用对象的方法，<strong>可以使用点操作符<code>.</code>和方法名</strong>。如果方法需要参数，可以在方法名后面的括号中提供。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">he = Man()         <span class="comment"># 创建一个Man类的实例对象he</span></span><br><span class="line">he.name = <span class="string">&quot;某人&quot;</span>   <span class="comment"># 给对象he的name属性赋值</span></span><br><span class="line">he.say_hi()        <span class="comment"># 调用对象he的say_hi方法</span></span><br><span class="line">he.say_hi_with_msg(<span class="string">&quot;hhhhhhh&quot;</span>)  <span class="comment"># 调用对象he的say_hi_with_msg方法并传递一个参数</span></span><br></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p><strong>在Python中，类的构造方法是<code>__init__()</code>。当创建类的新实例时，这个方法会自动被调用。构造方法通常用于初始化新创建对象的属性。</strong></p><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><p>下面是一个简单的<code>Student</code>类，它使用构造方法来初始化学生的姓名、年龄和电话号码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, tel</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.tel = tel</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个Student对象</span></span><br><span class="line">stu = Student(<span class="string">&quot;张三&quot;</span>, <span class="number">31</span>, <span class="string">&quot;1145141919810&quot;</span>)</span><br></pre></td></tr></table></figure><p>在这个例子中，当我们创建<code>stu</code>对象时，<code>__init__</code>方法被调用，并且我们传递的参数（”张三”, 31, “1145141919810”）被用来初始化对象的属性。</p><h3 id="魔术方法（Magic-Methods）"><a href="#魔术方法（Magic-Methods）" class="headerlink" title="魔术方法（Magic Methods）"></a>魔术方法（Magic Methods）</h3><p>Python中的魔术方法，也称为特殊方法或双下划线方法，是以双下划线开头和结尾的方法。这些方法有特殊的意义，并且通常在某种特定的操作发生时由Python自动调用。</p><h4 id="常见的魔术方法"><a href="#常见的魔术方法" class="headerlink" title="常见的魔术方法"></a>常见的魔术方法</h4><ul><li><code>__init__</code>: 构造方法，用于初始化新创建对象的状态。</li><li><code>__str__</code>: 返回对象的字符串表示形式，当我们尝试打印对象或使用<code>str()</code>转换对象时调用。</li><li><code>__lt__</code>: 定义小于（&lt;）操作符的行为。</li><li><code>__le__</code>: 定义小于等于（&lt;=）操作符的行为。</li><li><code>__eq__</code>: 定义等于（==）操作符的行为。</li></ul><h5 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h5><p>下面是一个扩展的<code>Student</code>类，包含了<code>__str__</code>，<code>__lt__</code>，<code>__le__</code>和<code>__eq__</code>魔术方法的实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, tel</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.tel = tel</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Student(name=<span class="subst">&#123;self.name&#125;</span>, age=<span class="subst">&#123;self.age&#125;</span>, tel=<span class="subst">&#123;self.tel&#125;</span>)&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__lt__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(other, Student):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&quot;Comparison is only implemented for instances of &#x27;Student&#x27;&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.age &lt; other.age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__le__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(other, Student):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&quot;Comparison is only implemented for instances of &#x27;Student&#x27;&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.age &lt;= other.age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(other, Student):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.name == other.name <span class="keyword">and</span> self.age == other.age <span class="keyword">and</span> self.tel == other.tel</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Student对象</span></span><br><span class="line">stu1 = Student(<span class="string">&quot;张三&quot;</span>, <span class="number">31</span>, <span class="string">&quot;1145141919810&quot;</span>)</span><br><span class="line">stu2 = Student(<span class="string">&quot;李四&quot;</span>, <span class="number">30</span>, <span class="string">&quot;1234567890&quot;</span>)</span><br><span class="line">stu3 = Student(<span class="string">&quot;张三&quot;</span>, <span class="number">31</span>, <span class="string">&quot;1145141919810&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用魔术方法</span></span><br><span class="line"><span class="built_in">print</span>(stu1)  <span class="comment"># 调用 __str__</span></span><br><span class="line"><span class="built_in">print</span>(stu1 &lt; stu2)  <span class="comment"># 调用 __lt__</span></span><br><span class="line"><span class="built_in">print</span>(stu1 &lt;= stu2)  <span class="comment"># 调用 __le__</span></span><br><span class="line"><span class="built_in">print</span>(stu1 == stu3)  <span class="comment"># 调用 __eq__</span></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student(name=张三, age=31, tel=1145141919810)</span><br><span class="line">False</span><br><span class="line">False</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>注意，在实现比较魔术方法时，我们通常首先检查比较的对象是否也是相同类的实例。如果不是，我们可能会抛出一个<code>TypeError</code>异常或者简单地返回<code>False</code>（对于<code>__eq__</code>方法）。在实现<code>__lt__</code>和<code>__le__</code>方法时，我们只比较了学生的年龄属性，但根据实际需要，可以比较更多的属性或应用更复杂的逻辑。</p><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>在Python中，继承是面向对象编程的一个重要概念，允许我们创建一个类（称为子类或派生类）来继承另一个类（称为父类或基类）的属性和方法。这样，子类可以重用父类的代码，同时还可以添加或覆盖父类的功能。</p><h2 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h2><p>单继承是指一个子类只继承一个父类的属性和方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, tel</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.tel = tel</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Student类对象, name = <span class="subst">&#123;self.name&#125;</span>, age = <span class="subst">&#123;self.age&#125;</span>, tel = <span class="subst">&#123;self.tel&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__le__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(other, Student):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&quot;Comparison is only implemented for instances of &#x27;Student&#x27;&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.age &lt;= other.age</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dalao</span>(<span class="title class_ inherited__">Student</span>):  <span class="comment"># Dalao类继承自Student类</span></span><br><span class="line">    GPA = <span class="number">5.0</span>  <span class="comment"># Dalao类新增了一个类属性GPA</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个Dalao类的实例</span></span><br><span class="line">d1 = Dalao(<span class="string">&quot;王五&quot;</span>, <span class="number">30</span>, <span class="string">&quot;114514&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(d1.GPA)  <span class="comment"># 输出Dalao类的GPA属性值</span></span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5.0</span><br></pre></td></tr></table></figure></p><h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><p>多继承是指一个子类可以继承多个父类的属性和方法。在Python中，可以通过在类定义时，在括号内列出多个父类来实现多继承。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">method1</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;A method1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">method2</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;B method2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(A, B):  <span class="comment"># C类继承自A类和B类</span></span><br><span class="line">    <span class="keyword">pass</span>  <span class="comment"># C类没有新增属性和方法，直接继承A和B的属性和方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个C类的实例</span></span><br><span class="line">c1 = C()</span><br><span class="line">c1.method1()  <span class="comment"># 调用继承自A类的方法</span></span><br><span class="line">c1.method2()  <span class="comment"># 调用继承自B类的方法</span></span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A method1</span><br><span class="line">B method2</span><br></pre></td></tr></table></figure></p><p>需要注意的是，多继承可能会引起方法解析顺序（MRO）的问题，Python中使用C3线性化算法来确定方法解析顺序。可以使用<code>类名.mro()</code>或<code>类名.__mro__</code>来查看类的MRO列表。</p><h2 id="复写和调用父类成员"><a href="#复写和调用父类成员" class="headerlink" title="复写和调用父类成员"></a>复写和调用父类成员</h2><p>子类可以复写父类的成员属性和成员方法，即重新定义同名的属性或方法。<strong>当子类对象调用成员时，会调用复写后的新成员。</strong>如果需要使用被复写的父类成员，可以使用特殊的调用方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">introduce</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;我是<span class="subst">&#123;self.name&#125;</span>，今年<span class="subst">&#123;self.age&#125;</span>岁。&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraduateStudent</span>(<span class="title class_ inherited__">Student</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, major</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name, age)  <span class="comment"># 调用父类的构造函数初始化name和age属性</span></span><br><span class="line">        self.major = major  <span class="comment"># 新增major属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">introduce</span>(<span class="params">self</span>):  <span class="comment"># 复写父类的introduce方法</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;我是研究生<span class="subst">&#123;self.name&#125;</span>，今年<span class="subst">&#123;self.age&#125;</span>岁，我的专业是<span class="subst">&#123;self.major&#125;</span>。&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个GraduateStudent类的实例并调用introduce方法</span></span><br><span class="line">gs = GraduateStudent(<span class="string">&quot;张三&quot;</span>, <span class="number">25</span>, <span class="string">&quot;计算机科学&quot;</span>)</span><br><span class="line">gs.introduce()  <span class="comment"># 调用复写后的新方法输出信息包含专业</span></span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我是研究生张三，今年25岁，我的专业是计算机科学。</span><br></pre></td></tr></table></figure></p><p>在上面的例子中，<code>GraduateStudent</code>类复写了<code>Student</code>类的<code>introduce</code>方法，并在其中添加了专业信息。同时，在<code>GraduateStudent</code>类的构造函数中，我们使用<code>super().__init__(name, age)</code>来调用父类的构造函数初始化继承的属性。这样，我们就可以在子类中添加新的属性或方法，同时保留父类的功能。</p><h3 id="访问父类成员"><a href="#访问父类成员" class="headerlink" title="访问父类成员"></a>访问父类成员</h3><h4 id="直接通过父类名调用"><a href="#直接通过父类名调用" class="headerlink" title="直接通过父类名调用"></a>直接通过父类名调用</h4><p>如果要直接通过父类名来调用其成员方法或访问成员变量，可以使用以下语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父类名.成员方法(self, 其他参数)</span><br><span class="line">父类名.成员变量</span><br></pre></td></tr></table></figure><p>这里需要注意的是，当直接调用父类的成员方法时，需要显式地将当前对象作为第一个参数传递（通常是<code>self</code>）。</p><blockquote><p>可以对实例化后的对象是用</p></blockquote><h4 id="使用super-调用"><a href="#使用super-调用" class="headerlink" title="使用super()调用"></a>使用<code>super()</code>调用</h4><p><code>super()</code>函数提供了一种动态的方式来访问父类的方法或属性，而不需要显式地引用父类的名字。这在多重继承的场景中特别有用，因为它可以确保正确地调用方法解析顺序（MRO）中的下一个类。</p><p>使用<code>super()</code>调用父类成员的语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">super</span>().成员方法(其他参数)</span><br><span class="line"><span class="built_in">super</span>().成员变量</span><br></pre></td></tr></table></figure><p>注意，在使用<code>super()</code>时，不需要显式地传递<code>self</code>参数，因为<code>super()</code>会自动处理。</p><blockquote><p>在类定义的时候才可以使用</p></blockquote><h1 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h1><p>多态是面向对象编程的三大特性之一，它允许我们使用父类引用来指向子类对象，并且可以调用在子类中重写的方法。<strong>在Python中，多态的实现主要依赖于鸭子类型（duck typing）的概念，即不关注对象的实际类型</strong>，而是关注对象是否具有所需的方法。</p><p>下面我们通过一段代码来演示多态的概念：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:  <span class="comment"># 定义一个Animal类作为父类</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span>  <span class="comment"># 父类中的speak方法为空实现</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):  <span class="comment"># Dog类继承自Animal类</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;汪汪汪&quot;</span>)  <span class="comment"># Dog类中重写speak方法，输出“汪汪汪”</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):  <span class="comment"># Cat类继承自Animal类</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;喵喵喵&quot;</span>)  <span class="comment"># Cat类中重写speak方法，输出“喵喵喵”</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Robot</span>:  <span class="comment"># 定义一个Robot类，它没有继承自Animal类</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;滋滋滋&quot;</span>)  <span class="comment"># Robot类中有一个speak方法，输出“滋滋滋”</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_noise</span>(<span class="params">obj</span>):  <span class="comment"># 定义一个函数，接受一个对象作为参数</span></span><br><span class="line">    obj.speak()  <span class="comment"># 调用对象的speak方法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建对象并调用make_noise函数</span></span><br><span class="line">a = Animal()  <span class="comment"># 创建Animal对象，但注意Animal类的speak方法为空实现，调用时不会有输出</span></span><br><span class="line">b = Dog()  <span class="comment"># 创建Dog对象</span></span><br><span class="line">c = Cat()  <span class="comment"># 创建Cat对象</span></span><br><span class="line">d = Robot()  <span class="comment"># 创建Robot对象，虽然它没有继承自Animal类，但它有一个speak方法，所以可以在make_noise函数中使用</span></span><br><span class="line"></span><br><span class="line">make_noise(b)  <span class="comment"># 输出“汪汪汪”</span></span><br><span class="line">make_noise(c)  <span class="comment"># 输出“喵喵喵”</span></span><br><span class="line"><span class="comment"># make_noise(a)  # 这行代码如果取消注释会运行但没有输出，因为Animal类的speak方法为空实现</span></span><br><span class="line">make_noise(d)  <span class="comment"># 输出“滋滋滋”，虽然Robot类没有继承自Animal类，但由于它有一个speak方法，所以可以在make_noise函数中使用，这体现了鸭子类型的思想</span></span><br></pre></td></tr></table></figure><p>注意：在上述代码中，我们实际上并没有使用到<code>a = Animal()</code>这个对象，因为<code>Animal</code>类的<code>speak</code>方法是一个空实现。如果我们尝试调用<code>make_noise(a)</code>，它不会产生任何输出。在实际的多态示例中，我们通常会避免创建这样的空实现的父类对象。此外，虽然<code>Robot</code>类没有继承自<code>Animal</code>类，但由于它有一个与<code>Animal</code>类中同名的<code>speak</code>方法，我们仍然可以将其对象传递给<code>make_noise</code>函数并调用其<code>speak</code>方法。<strong>这就是鸭子类型的核心思想：不关注对象的实际类型，只关注对象是否具有所需的方法。</strong>然而，在严格的面向对象设计中，为了让代码更加清晰和可维护，我们通常会建议将具有相同行为（即具有相同方法）的类组织到一个继承体系中，并通过父类引用来操作子类对象。这样可以确保我们的代码更加符合面向对象的设计原则。在上述示例中，我们可以将<code>Robot</code>类也设计为继承自<code>Animal</code>类（如果逻辑上合理的话），这样就可以更加清晰地展示多态的特性。但是需要注意的是，并不是所有的具有相同方法的类都应该被组织到一个继承体系中。在实际开发中，我们需要根据具体的业务逻辑和设计需求来决定如何组织我们的类和对象。另外需要注意的是，Python中的多态与一些其他语言（如Java）中的多态略有不同。在Python中，由于动态类型和鸭子类型的特性，我们可以在不显式地声明接口或继承体系的情况下实现多态。这使得Python的代码更加灵活和简洁。但是在享受这种灵活性的同时，我们也需要注意保持代码的清晰性和可维护性。</p><h1 id="变量的类型注解"><a href="#变量的类型注解" class="headerlink" title="变量的类型注解"></a>变量的类型注解</h1><p>在Python 3.5及以后的版本中，引入了类型注解（Type Annotations）的功能。类型注解允许开发者在代码中显式地标注变量、函数参数以及返回值的数据类型。这些注解主要用于帮助开发者编写更加清晰、易于理解的代码，并且为静态类型检查工具、集成开发环境（IDE）等第三方工具提供更好的支持。</p><h2 id="类型注解的作用"><a href="#类型注解的作用" class="headerlink" title="类型注解的作用"></a>类型注解的作用</h2><ol><li><strong>代码提示</strong>：类型注解可以帮助IDE等开发工具提供更为准确的代码提示和自动补全功能。</li><li><strong>静态类型检查</strong>：配合静态类型检查工具，可以在代码运行前发现潜在的类型错误。</li><li><strong>文档化</strong>：类型注解也可以作为一种文档形式，帮助其他开发者理解代码中的数据类型。</li></ol><h2 id="变量的类型注解-1"><a href="#变量的类型注解-1" class="headerlink" title="变量的类型注解"></a>变量的类型注解</h2><p>变量的类型注解是在变量名后面加上冒号（<code>:</code>）和类型名。需<strong>要注意的是，类型注解仅仅是注释，它不会改变Python的动态类型特性。</strong>也就是说，即使你标注了一个变量为整数类型，Python仍然允许你为这个变量赋值为其他类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 变量类型注解示例</span></span><br><span class="line">my_var: <span class="built_in">int</span> = <span class="number">42</span>  <span class="comment"># 标注my_var为整数类型</span></span><br></pre></td></tr></table></figure><p>然而，以下代码虽然类型注解为<code>int</code>，但实际上赋值为字符串类型，Python不会报错，但在静态类型检查时会警告类型不匹配：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var: <span class="built_in">int</span> = <span class="string">&quot;itheima&quot;</span>  <span class="comment"># 类型注解为int，但实际赋值为str，这不会引发运行时错误</span></span><br><span class="line"><span class="built_in">print</span>(var)  <span class="comment"># 输出：itheima</span></span><br></pre></td></tr></table></figure><h2 id="函数的类型注解"><a href="#函数的类型注解" class="headerlink" title="函数的类型注解"></a>函数的类型注解</h2><p>函数的类型注解包括函数参数的类型注解和返回值类型的注解。参数的类型注解写在参数名后面，返回值类型的注解写在函数声明后面的箭头（<code>-&gt;</code>）后面。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 函数类型注解示例</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">name: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;Hello, <span class="subst">&#123;name&#125;</span>!&quot;</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>greet</code>函数的参数<code>name</code>被注解为字符串类型，返回值也被注解为字符串类型。</p><h2 id="Union用法"><a href="#Union用法" class="headerlink" title="Union用法"></a>Union用法</h2><p>当变量或函数参数可以是多种类型之一时，可以使用<code>Union</code>来指定这些类型。<code>Union</code>是从<code>typing</code>模块中导入的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Union</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Union用法示例：变量可以是str或int类型  </span></span><br><span class="line">my_var: <span class="type">Union</span>[<span class="built_in">str</span>, <span class="built_in">int</span>] = <span class="string">&quot;Hello&quot;</span>  <span class="comment"># my_var可以是str类型  </span></span><br><span class="line">my_var = <span class="number">42</span>  <span class="comment"># my_var也可以是int类型，这不会引发运行时错误  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># Union用法示例：列表中的元素可以是str或int类型  </span></span><br><span class="line">my_list: <span class="built_in">list</span>[<span class="type">Union</span>[<span class="built_in">str</span>, <span class="built_in">int</span>]] = [<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;itheima&quot;</span>, <span class="string">&quot;itcast&quot;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>my_var</code>被注解为可以是字符串或整数类型，而<code>my_list</code>被注解为一个列表，其中的元素可以是字符串或整数类型。这样，在静态类型检查时，如果这些变量被赋予了不符合注解类型的值，工具就会发出警告。然而，在运行时，Python本身不会因为这些类型注解而引发错误。</p>]]></content>
      
      
      <categories>
          
          <category> 重生之我是程序员 </category>
          
          <category> Python笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Pytorch笔记</title>
      <link href="/post/969045566.html"/>
      <url>/post/969045566.html</url>
      
        <content type="html"><![CDATA[<h1 id="调用帮助文档"><a href="#调用帮助文档" class="headerlink" title="调用帮助文档"></a>调用帮助文档</h1><p>在Python中，<code>help()</code>和<code>dir()</code>是两个内置函数，它们提供了对Python对象（如模块、类、方法、函数、变量等）的有用信息。</p><ul><li><p><code>help()</code>函数用于获取有关Python对象的信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span>(<span class="built_in">print</span>) <span class="comment">#这将显示有关print()函数的详细信息，包括它的用途、参数、返回值等。</span></span><br></pre></td></tr></table></figure></li><li><p><code>dir()</code>函数用于列出Python对象的所有属性和方法。</p><p>获取内置<code>math</code>模块的所有属性和方法：</p></li></ul>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(math))</span><br></pre></td></tr></table></figure><p>  这将显示<code>math</code>模块中定义的所有函数、变量和常量的名称。</p><p>  也可以在不传递任何参数的情况下调用<code>dir()</code>函数，这将返回一个包含当前作用域中所有名称的列表。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>())</span><br></pre></td></tr></table></figure><h1 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h1><h2 id="必要的库"><a href="#必要的库" class="headerlink" title="必要的库"></a>必要的库</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> os</span><br></pre></td></tr></table></figure><h2 id="读取和显示图像"><a href="#读取和显示图像" class="headerlink" title="读取和显示图像"></a>读取和显示图像</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img = Image.<span class="built_in">open</span>(img_path)  <span class="comment"># 打开图像文件</span></span><br><span class="line">img.show()  <span class="comment"># 显示图像文件（注意：这可能会打开多个图像查看器窗口）</span></span><br></pre></td></tr></table></figure><p>用<code>PIL</code>中的<code>Image</code>可以通过图像路径来打开某个图像并显示图像文件。</p><h2 id="处理图像"><a href="#处理图像" class="headerlink" title="处理图像"></a>处理图像</h2><h3 id="将PIL图像转换为numpy数组"><a href="#将PIL图像转换为numpy数组" class="headerlink" title="将PIL图像转换为numpy数组"></a>将PIL图像转换为numpy数组</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image_path = <span class="string">&quot;data/train/ants_image/0013035.jpg&quot;</span>  </span><br><span class="line">img_PIL = Image.<span class="built_in">open</span>(image_path)  </span><br><span class="line">img_array = np.array(img_PIL)</span><br></pre></td></tr></table></figure><h1 id="TensorBoard可视化"><a href="#TensorBoard可视化" class="headerlink" title="TensorBoard可视化"></a>TensorBoard可视化</h1><p>使用PyTorch进行深度学习实验时，我们经常需要跟踪和可视化训练过程中的各种指标，如损失、准确率等。TensorBoard是一个强大的可视化工具，可以帮助我们实现这一目标。在PyTorch中，我们可以通过<code>SummaryWriter</code>类轻松地将数据写入TensorBoard可以读取的日志文件。</p><blockquote><p>其就相当于一个日志</p></blockquote><h2 id="创建并启动TensorBoard"><a href="#创建并启动TensorBoard" class="headerlink" title="创建并启动TensorBoard"></a>创建并启动TensorBoard</h2><ol><li><p>从<code>torch.utils.tensorboard</code>导入<code>SummaryWriter</code>。</p></li><li><p>创建一个<code>SummaryWriter</code>对象，并指定一个日志目录，例如”logs”。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>启动TensorBoard：</p><p>要在命令行中启动TensorBoard并加载我们的日志，请使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensorboard --logdir=logs</span><br></pre></td></tr></table></figure><p>这将在本地启动一个TensorBoard服务器，并在默认浏览器中打开TensorBoard的Web界面。</p></li></ol><h2 id="写入日志文件"><a href="#写入日志文件" class="headerlink" title="写入日志文件"></a>写入日志文件</h2><h3 id="添加标量数据"><a href="#添加标量数据" class="headerlink" title="添加标量数据"></a>添加标量数据</h3><p>可以使用<code>add_scalar</code>方法将标量数据写入日志文件。这个方法接受三个参数：标签（用于在TensorBoard中标识数据），标量值，以及全局步骤值（通常用于表示训练的迭代次数或时间步）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    writer.add_scalar(<span class="string">&quot;y=x&quot;</span>, i, i)  </span><br><span class="line"></span><br><span class="line">writer.close()  <span class="comment"># 记得关闭</span></span><br></pre></td></tr></table></figure><h3 id="添加图像"><a href="#添加图像" class="headerlink" title="添加图像"></a>添加图像</h3><p>使用<code>SummaryWriter</code>的<code>add_image</code>方法将图像添加到TensorBoard中。需要注意的是，<code>add_image</code>方法要求图像数据的格式与指定的<code>dataformats</code>参数相匹配。在这里，我们指定为<code>&#39;HWC&#39;</code>，即高度、宽度和通道数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)  </span><br><span class="line">writer.add_image(<span class="string">&quot;test&quot;</span>, img_array, global_step=<span class="number">0</span>, dataformats=<span class="string">&#x27;HWC&#x27;</span>)<span class="comment">#默认是&#x27;CHW&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="Pytorch基础"><a href="#Pytorch基础" class="headerlink" title="Pytorch基础"></a>Pytorch基础</h1><h2 id="张量-Tensors"><a href="#张量-Tensors" class="headerlink" title="张量(Tensors)"></a>张量(Tensors)</h2><h3 id="创建Tensors变量"><a href="#创建Tensors变量" class="headerlink" title="创建Tensors变量"></a>创建Tensors变量</h3><p>有多种创建Tensors变量的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建未初始化的矩阵</span></span><br><span class="line">x = torch.empty(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">#随机初始化一个矩阵</span></span><br><span class="line">rand_x = torch.rand(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">#创建数值皆为 0 的矩阵（类型为 long 的矩阵）</span></span><br><span class="line">zero_x = torch.zeros(<span class="number">5</span>, <span class="number">3</span>, dtype=torch.long)</span><br><span class="line"><span class="comment">#创建数值都是 1 的矩阵</span></span><br><span class="line">one_x = torch.ones(<span class="number">5</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment">#直接传递 tensor 数值来创建</span></span><br><span class="line">tensor = torch.tensor([<span class="number">5.5</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure><p>还可以用<code>tensor.new_ones()</code>和<code>torch.randn_like()</code>从一个<code>tensor</code>变量创建另一个<code>tensor</code>变量。</p><h3 id="处理Tensors变量"><a href="#处理Tensors变量" class="headerlink" title="处理Tensors变量"></a>处理Tensors变量</h3><h4 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h4><p>加法有几种实现方式：</p><ul><li><code>+</code> 运算符</li><li><code>torch.add(tensor1, tensor2, [out=tensor3])</code></li><li><code>tensor1.add_(tensor2)</code>：直接修改 tensor 变量</li></ul><blockquote><p>可以改变 tensor 变量的操作都带有一个后缀 <code>_</code>, 例如 <code>x.copy_(y), x.t_()</code> 都可以改变 x 变量</p></blockquote><h4 id="访问tensor数据"><a href="#访问tensor数据" class="headerlink" title="访问tensor数据"></a>访问tensor数据</h4><p>可以使用索引来访问某一维的数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 访问 tensor 第一列数据</span></span><br><span class="line"><span class="built_in">print</span>(tensor[:, <span class="number">0</span>])</span><br></pre></td></tr></table></figure><h4 id="修改维度"><a href="#修改维度" class="headerlink" title="修改维度"></a>修改维度</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#对 Tensor 的尺寸修改，可以采用 torch.view()</span></span><br><span class="line">x = torch.randn(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line">y = x.view(<span class="number">16</span>)</span><br><span class="line"><span class="comment"># -1 表示除给定维度外的其余维度的乘积</span></span><br><span class="line">z = x.view(-<span class="number">1</span>, <span class="number">8</span>)</span><br><span class="line"><span class="built_in">print</span>(x.size(), y.size(), z.size())</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.Size([<span class="number">4</span>, <span class="number">4</span>]) torch.Size([<span class="number">16</span>]) torch.Size([<span class="number">2</span>, <span class="number">8</span>])</span><br></pre></td></tr></table></figure><h3 id="转换为其他数据类型"><a href="#转换为其他数据类型" class="headerlink" title="转换为其他数据类型"></a>转换为其他数据类型</h3><h4 id="转换为Numpy数组"><a href="#转换为Numpy数组" class="headerlink" title="转换为Numpy数组"></a>转换为Numpy数组</h4><p>调用 <code>tensor.numpy()</code> 可以实现这个转换操作。<strong>两者是共享同个内存空间的</strong>,修改 <code>tensor</code> 变量 <code>a</code>，Numpy 数组变量 <code>b</code>也会发生变化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = torch.ones(<span class="number">5</span>)</span><br><span class="line">b = a.numpy()</span><br></pre></td></tr></table></figure><h4 id="Numpy-数组转换为-Tensor"><a href="#Numpy-数组转换为-Tensor" class="headerlink" title="Numpy 数组转换为 Tensor"></a>Numpy 数组转换为 Tensor</h4><p>转换的操作是调用 <code>torch.from_numpy(numpy_array)</code> 方法.\</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.ones(<span class="number">5</span>)</span><br><span class="line">b = torch.from_numpy(a)</span><br></pre></td></tr></table></figure><h2 id="定义自定义数据集类"><a href="#定义自定义数据集类" class="headerlink" title="定义自定义数据集类"></a>定义自定义数据集类</h2><h3 id="创建自定义数据集类"><a href="#创建自定义数据集类" class="headerlink" title="创建自定义数据集类"></a>创建自定义数据集类</h3><p>要创建一个自定义的数据集类，我们首先需要导入必要的库，并继承<code>Dataset</code>类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyData</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, root_dir, label_dir</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        初始化函数，接收根目录和标签目录作为参数。</span></span><br><span class="line"><span class="string">        :param root_dir: 根目录路径，包含所有标签的文件夹。</span></span><br><span class="line"><span class="string">        :param label_dir: 标签目录名称，即根目录下的子文件夹名，代表某一类别。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.root_dir = root_dir</span><br><span class="line">        self.label_dir = label_dir</span><br><span class="line">        <span class="comment"># 拼接得到完整的目录路径</span></span><br><span class="line">        self.path = os.path.join(self.root_dir, self.label_dir)</span><br><span class="line">        <span class="comment"># 列出目录中的所有文件，注意这里没有进行文件类型过滤</span></span><br><span class="line">        self.img_path_list = os.listdir(self.path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        根据索引获取单个样本（图像和标签）。</span></span><br><span class="line"><span class="string">        :param idx: 样本索引。</span></span><br><span class="line"><span class="string">        :return: 返回图像和标签。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 获取图像文件名</span></span><br><span class="line">        img_name = self.img_path_list[idx]</span><br><span class="line">        <span class="comment"># 拼接得到完整的图像文件路径</span></span><br><span class="line">        img_item_path = os.path.join(self.root_dir, self.label_dir, img_name)</span><br><span class="line">        <span class="comment"># 使用PIL库打开图像文件</span></span><br><span class="line">        img = Image.<span class="built_in">open</span>(img_item_path)</span><br><span class="line">        <span class="comment"># 这里简单地将标签设置为标签目录的名称</span></span><br><span class="line">        <span class="comment"># 在实际应用中，标签可能需要更复杂的处理，比如转换为数字、one-hot编码等</span></span><br><span class="line">        label = self.label_dir</span><br><span class="line">        <span class="keyword">return</span> img, label</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        返回数据集中的样本数量（图像数量）。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.img_path_list)</span><br></pre></td></tr></table></figure><h3 id="使用自定义数据集类"><a href="#使用自定义数据集类" class="headerlink" title="使用自定义数据集类"></a>使用自定义数据集类</h3><p>创建了自定义的数据集类之后，就可以将其传递给PyTorch的数据加载器（<code>DataLoader</code>）来使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实例化自定义数据集类</span></span><br><span class="line">dataset = MyData(root_dir=<span class="string">&quot;path/to/root&quot;</span>, label_dir=<span class="string">&quot;label_a&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用DataLoader加载数据集（这里仅为示例，实际使用时需要设置batch_size等参数）</span></span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"></span><br><span class="line">dataloader = DataLoader(dataset, batch_size=<span class="number">4</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在训练循环中迭代dataloader获取数据和标签</span></span><br><span class="line"><span class="keyword">for</span> images, labels <span class="keyword">in</span> dataloader:</span><br><span class="line">    <span class="comment"># 训练代码...</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h2 id="DataLoader的使用"><a href="#DataLoader的使用" class="headerlink" title="DataLoader的使用"></a>DataLoader的使用</h2><p>需要导入必要的库。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br></pre></td></tr></table></figure><p>加载数据集：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test_loader = DataLoader(dataset=test_data, batch_size=<span class="number">64</span>, shuffle=<span class="literal">True</span>, num_workers=<span class="number">0</span>, drop_last=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><ol><li><p>dataset：</p><ul><li><strong>参数类型</strong>: <code>Dataset</code></li><li><strong>作用</strong>: 指定<code>DataLoader</code>需要加载的数据集。数据集必须实现<code>Dataset</code>接口，这样才能被<code>DataLoader</code>识别和加载。</li></ul></li><li><p>batch_size</p><ul><li><p><strong>参数类型</strong>: <code>int</code></p></li><li><p><strong>默认值</strong>: <code>1</code></p></li><li><p><strong>作用</strong>: 指定每个批次的样本数量。批次大小会影响到模型的收敛速度和更新频率。</p></li></ul></li><li><p>shuffle</p><ul><li><p><strong>参数类型</strong>: <code>bool</code></p></li><li><p><strong>默认值</strong>: <code>False</code></p></li><li><p><strong>作用</strong>: 如果设置为<code>True</code>，则每个epoch开始时，<code>DataLoader</code>会随机打乱数据集中的样本顺序。</p></li></ul></li><li><p>num_workers</p><ul><li><p><strong>参数类型</strong>: <code>int</code></p></li><li><p><strong>默认值</strong>: <code>0</code></p></li><li><p><strong>作用</strong>: 指定有多少个子进程用于加载数据。<code>0</code>表示数据将在主进程中加载（不使用子进程）。增加<code>num_workers</code>可以提高数据加载的效率，特别是在数据预处理较为复杂或者数据存储在慢速存储介质上时。</p></li></ul></li><li><p>drop_last</p><ul><li><strong>参数类型</strong>: <code>bool</code></li><li><strong>默认值</strong>: <code>False</code></li><li><strong>作用</strong>: 当样本数量不能被批次大小整除时，如果<code>drop_last</code>设置为<code>True</code>，则<code>DataLoader</code>会丢弃最后一个不完整的批次。</li></ul></li></ol><h2 id="Torchvision-Transforms"><a href="#Torchvision-Transforms" class="headerlink" title="Torchvision Transforms"></a>Torchvision Transforms</h2><h3 id="导入必要的库"><a href="#导入必要的库" class="headerlink" title="导入必要的库"></a>导入必要的库</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br></pre></td></tr></table></figure><h3 id="常用的Transforms操作"><a href="#常用的Transforms操作" class="headerlink" title="常用的Transforms操作"></a>常用的Transforms操作</h3><h4 id="PIL图像转换为Tensor"><a href="#PIL图像转换为Tensor" class="headerlink" title="PIL图像转换为Tensor"></a>PIL图像转换为Tensor</h4><p><code>torchvision.transforms</code>库中的<code>ToTensor()</code>函数可以将PIL图像或NumPy ndarray转换为FloatTensor，并且<strong>会将图像的像素值范围从0-255缩放到0-1</strong>。这对于神经网络来说是一个常见的预处理步骤。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tensor_trans = transforms.ToTensor()</span><br><span class="line">tensor_img = tensor_trans(img)</span><br></pre></td></tr></table></figure><p>使用<code>SummaryWriter</code>的<code>add_image()</code>方法将Tensor图像添加到TensorBoard中。这样，我们就可以在TensorBoard中查看和处理这个图像了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">writer.add_image(<span class="string">&quot;Tensor_img&quot;</span>, tensor_img)</span><br></pre></td></tr></table></figure><h4 id="归一化操作"><a href="#归一化操作" class="headerlink" title="归一化操作"></a>归一化操作</h4><p>下面是一个示例代码，展示了如何使用PyTorch的transforms模块进行图像归一化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Totensor</span></span><br><span class="line">trans_totensor = transforms.ToTensor()</span><br><span class="line">img_tensor = trans_totensor(img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Normalize - 注意这里的参数可能不适用于所有图像，应根据实际情况进行调整</span></span><br><span class="line">trans_norm = transforms.Normalize([<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>], [<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>])  <span class="comment"># 假设图像范围为[0, 1]，则均值和标准差都设为0.5进行归一化</span></span><br><span class="line">img_norm = trans_norm(img_tensor)</span><br></pre></td></tr></table></figure><h4 id="图像调整大小"><a href="#图像调整大小" class="headerlink" title="图像调整大小"></a>图像调整大小</h4><p>在调整大小之前，可以通过 <code>img.size</code> 属性获取原始图像的大小。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(img.size)  <span class="comment"># 输出原始图像的宽度和高度，例如：(width, height)</span></span><br></pre></td></tr></table></figure><p>创建一个 <code>transforms.Resize</code> 对象，指定新的图像大小。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trans_resize = transforms.Resize((<span class="number">512</span>, <span class="number">512</span>))  <span class="comment"># 调整图像到 512x512 像素大小</span></span><br></pre></td></tr></table></figure><p>使用创建的 <code>trans_resize</code> 转换器来调整图像大小。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img_resize = trans_resize(img)  <span class="comment"># img_resize 是调整大小后的 PIL 图像</span></span><br></pre></td></tr></table></figure><h3 id="使用Compose组合多个操作"><a href="#使用Compose组合多个操作" class="headerlink" title="使用Compose组合多个操作"></a>使用Compose组合多个操作</h3><p>在实际应用中，我们通常需要按顺序执行多个图像预处理操作。这时，可以使用<code>transforms.Compose</code>来组合这些操作，从而创建一个可重复使用的预处理流程。以下是一个示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;test04&quot;</span>)</span><br><span class="line">img = Image.<span class="built_in">open</span>(<span class="string">&quot;image.jpg&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义预处理流程：先调整大小，然后转换为张量，并进行归一化（这里省略了归一化步骤以简化示例）</span></span><br><span class="line">preprocessing = transforms.Compose([</span><br><span class="line">    transforms.Resize([<span class="number">300</span>, <span class="number">500</span>]),  <span class="comment"># 调整图像大小（注意保持纵横比或适当填充以避免失真）</span></span><br><span class="line">    transforms.ToTensor(),  <span class="comment"># 将PIL图像转换为PyTorch张量（值范围在[0, 255]内）</span></span><br><span class="line">    <span class="comment"># 添加归一化等其他操作（如果需要的话）...</span></span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用预处理流程并保存结果到TensorBoard日志中（实际应用中可能需要进一步处理或添加标签等）</span></span><br><span class="line">img_preprocessed = preprocessing(img)</span><br><span class="line">writer.add_image(<span class="string">&quot;Preprocessed Image&quot;</span>, img_preprocessed, <span class="number">0</span>)  <span class="comment"># 使用全局步数0，实际应用中应根据需要动态设置（例如训练迭代次数等）</span></span><br></pre></td></tr></table></figure><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>Pytorch中也提供了许多的损失函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># L1损失函数</span></span><br><span class="line">loss = L1Loss(reduction=<span class="string">&#x27;sum&#x27;</span>)  </span><br><span class="line">result = loss(inputs, targets)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># MSE损失函数</span></span><br><span class="line">loss_mse = nn.MSELoss()  </span><br><span class="line">result_mse = loss_mse(inputs, targets)  </span><br></pre></td></tr></table></figure><h2 id="计算正确率"><a href="#计算正确率" class="headerlink" title="计算正确率"></a>计算正确率</h2><p><code>output=model(input)</code>得到的是浮点数矩阵，如果想要知道类别，则可以用<code>.argmax()</code>函数得到输出的类别，然后用<code>predict==targets</code>得到布尔矩阵。最后对矩阵<code>torch.sum()</code>得到正确个数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch  </span><br><span class="line">outputs = torch.tensor([[<span class="number">0.1</span>, <span class="number">0.2</span>], [<span class="number">0.3</span>, <span class="number">0.4</span>]])  </span><br><span class="line"><span class="comment">#.argmax(1)是对每一行求最大值的位置，.argmax(0)是对每一列</span></span><br><span class="line"><span class="built_in">print</span>(outputs.argmax(<span class="number">1</span>))  </span><br><span class="line">preds = outputs.argmax(<span class="number">1</span>)  </span><br><span class="line">targets = torch.tensor([<span class="number">0</span>, <span class="number">1</span>])  </span><br><span class="line"><span class="built_in">print</span>(preds == targets)  </span><br></pre></td></tr></table></figure><h1 id="PyTorch卷积"><a href="#PyTorch卷积" class="headerlink" title="PyTorch卷积"></a>PyTorch卷积</h1><h2 id="PyTorch中torch-nn模块的使用"><a href="#PyTorch中torch-nn模块的使用" class="headerlink" title="PyTorch中torch.nn模块的使用"></a>PyTorch中torch.nn模块的使用</h2><p>在PyTorch中，<code>torch.nn</code>模块提供了构建神经网络所需的所有构建块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br></pre></td></tr></table></figure><p>接下来，我们定义一个模型类<code>Model</code>，它继承自<code>nn.Module</code>。在构造函数<code>__init__</code>中，我们初始化两个卷积层<code>conv1</code>和<code>conv2</code>。<code>nn.Conv2d</code>是二维卷积层，它接收的参数包括输入和输出通道数、卷积核大小等。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Model, self).__init__() <span class="comment"># 记得初始化父类</span></span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">1</span>, <span class="number">20</span>, <span class="number">5</span>)  <span class="comment"># 输入通道1，输出通道20，卷积核大小5</span></span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">20</span>, <span class="number">20</span>, <span class="number">5</span>) <span class="comment"># 输入通道20，输出通道20，卷积核大小5</span></span><br></pre></td></tr></table></figure><br>在<code>forward</code>方法中，我们定义了数据通过网络的方式。这里使用了<code>F.relu</code>作为激活函数，对每个卷积层的输出应用ReLU激活。 </p><blockquote><p>其它的一些层可以在<a href="https://pytorch.org/docs/stable/nn.functional.html">官方文档</a>中找到</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">    x = F.relu(self.conv1(x))  <span class="comment"># 第一个卷积层后接ReLU激活</span></span><br><span class="line">    <span class="keyword">return</span> F.relu(self.conv2(x))  <span class="comment"># 第二个卷积层后接ReLU激活</span></span><br></pre></td></tr></table></figure><p>这样，我们就定义了一个简单的卷积神经网络模型。在实际使用时，我们会创建这个模型类的实例，然后传入数据来进行训练和测试。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建模型实例</span></span><br><span class="line">model = Model()</span><br><span class="line"><span class="comment"># 假设我们有一些输入数据x（例如，图像数据），形状为(N, 1, 28, 28)</span></span><br><span class="line"><span class="comment"># N是批量大小，1是通道数，28x28是图像尺寸</span></span><br><span class="line">x = torch.randn(<span class="number">64</span>, <span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>)  <span class="comment"># 随机生成一些输入数据</span></span><br><span class="line"><span class="comment"># 通过模型前向传播数据</span></span><br><span class="line">output = model(x)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="built_in">print</span>(output)</span><br></pre></td></tr></table></figure><br>以上就是使用<code>torch.nn</code>模块构建和运行一个简单卷积神经网络的基本步骤。在实际应用中，模型通常会包含更多的层和更复杂的结构，但基本原理是相同的。</p><h3 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h3><h4 id="定义优化器"><a href="#定义优化器" class="headerlink" title="定义优化器"></a>定义优化器</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">optimizer = optim.SGD(model.parameters(), lr=<span class="number">0.01</span>, momentum=<span class="number">0.9</span>)  </span><br><span class="line">optimizer = optim.Adam([var1, var2], lr=<span class="number">0.0001</span>)</span><br></pre></td></tr></table></figure><p>主要要定义的有两个：</p><ol><li>模型参数：给定模型参数优化器才知道更新哪些内容</li><li>学习速率<code>lr</code></li></ol><h4 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h4><p>训练过程写法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">input</span>, target <span class="keyword">in</span> dataset:  </span><br><span class="line">    optimizer.zero_grad()  <span class="comment"># 梯度清零</span></span><br><span class="line">    output = model(<span class="built_in">input</span>)  <span class="comment"># 前向传播</span></span><br><span class="line">    loss = loss_fn(output, target)  <span class="comment">#损失</span></span><br><span class="line">    loss.backward()  <span class="comment"># 反向传播</span></span><br><span class="line">    optimizer.step()</span><br></pre></td></tr></table></figure><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><p>与自己的模型综合起来，效果大概是这样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">loss = nn.CrossEntropyLoss()  </span><br><span class="line">model = Model()  </span><br><span class="line">optim = torch.optim.SGD(tudui.parameters(), lr=<span class="number">0.01</span>)  </span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> dataloader:  </span><br><span class="line">    imgs, targets = data  </span><br><span class="line">    outputs = model (imgs)  </span><br><span class="line">    result_loss = loss(outputs, targets)  </span><br><span class="line">    optim.zero_grad()  </span><br><span class="line">    result_loss.backward()  </span><br><span class="line">    optim.step()</span><br></pre></td></tr></table></figure><h3 id="利用Sequential简化模块"><a href="#利用Sequential简化模块" class="headerlink" title="利用Sequential简化模块"></a>利用<code>Sequential</code>简化模块</h3><p><code>Sequential</code>也在<code>torch.nn</code>模块中，利用其，可以避免在前向传播的过程中手写每层的输入输出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Model, self).__init__()</span><br><span class="line">        self.model1 = Sequential(</span><br><span class="line">            Conv2d(<span class="number">3</span>, <span class="number">32</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            Conv2d(<span class="number">32</span>, <span class="number">32</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            Conv2d(<span class="number">32</span>, <span class="number">64</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            Flatten(),</span><br><span class="line">            Linear(<span class="number">1024</span>, <span class="number">64</span>),</span><br><span class="line">            Linear(<span class="number">64</span>, <span class="number">10</span>)</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.model1(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h3 id="可视化模块"><a href="#可视化模块" class="headerlink" title="可视化模块"></a>可视化模块</h3><ol><li>可以用<code>print(Model)</code>将模型显示在控制台</li><li>用<code>SummaryWriter</code>的<code>add_graph(Model,input)</code>在TensorBorad中显示</li></ol><h3 id="保存模型"><a href="#保存模型" class="headerlink" title="保存模型"></a>保存模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"></span><br><span class="line"><span class="comment">#保存</span></span><br><span class="line"><span class="comment">#方式一，保存整个模型</span></span><br><span class="line">torch.save(vgg16, <span class="string">&quot;vgg16_method1.pth&quot;</span>)</span><br><span class="line"><span class="comment">#方式二，只保存参数</span></span><br><span class="line">torch.save(vgg16.state_dict(), <span class="string">&quot;vgg16_method2.pth&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#加载</span></span><br><span class="line"><span class="comment">#方式一对应的加载模式</span></span><br><span class="line">model = torch.load(<span class="string">&quot;vgg16_method1.pth&quot;</span>)</span><br><span class="line"><span class="comment">#方式二对应的加载模式</span></span><br><span class="line">vgg16 = torchvision.models.vgg16(pretrained=<span class="literal">False</span>)</span><br><span class="line">vgg16.load_state_dict(torch.load(<span class="string">&quot;vgg16_method2.pth&quot;</span>))</span><br></pre></td></tr></table></figure><p>加载自身的模型的时候需要给出类的定义。</p><h2 id="PyTorch-2D卷积"><a href="#PyTorch-2D卷积" class="headerlink" title="PyTorch 2D卷积"></a>PyTorch 2D卷积</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br></pre></td></tr></table></figure><h3 id="1-创建输入张量和卷积核"><a href="#1-创建输入张量和卷积核" class="headerlink" title="1. 创建输入张量和卷积核"></a>1. 创建输入张量和卷积核</h3><p>输入张量（<code>input</code>）和卷积核（<code>kernel</code>）被定义为多维张量。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">input</span> = torch.tensor([</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">    [<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">])</span><br><span class="line">kernel = torch.tensor([</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">])</span><br></pre></td></tr></table></figure></p><h3 id="2-调整张量的形状"><a href="#2-调整张量的形状" class="headerlink" title="2. 调整张量的形状"></a>2. 调整张量的形状</h3><p>为了进行二维卷积操作，我们需要将输入张量和卷积核的形状调整为四维张量。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">input</span> = torch.reshape(<span class="built_in">input</span>, (<span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">kernel = torch.reshape(kernel, (<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure><br>在PyTorch中，使用<code>torch.nn.functional.conv2d</code>函数进行卷积操作时，输入和卷积核需要是四维张量。这四个维度分别是：</p><ol><li><strong>批量大小（Batch size）</strong>：表示输入数据的数量。</li><li><strong>通道数（Channels）</strong>：对于彩色图像，通常是3（红、绿、蓝）。</li><li><strong>高度（Height）</strong>：图像的高度。</li><li><strong>宽度（Width）</strong>：图像的宽度。</li></ol><p><code>input = torch.reshape(input, (1, 1, 5, 5))</code>和<code>kernel = torch.reshape(kernel, (1, 1, 3, 3))</code>这两行代码的作用是将输入和卷积核的形状从二维扩展到四维，以满足<code>conv2d</code>函数的要求。</p><h3 id="3-进行卷积操作"><a href="#3-进行卷积操作" class="headerlink" title="3.进行卷积操作"></a>3.进行卷积操作</h3><p>使用<code>F.conv2d</code>函数进行卷积操作，并设置步长（<code>stride</code>）为1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">output = F.conv2d(<span class="built_in">input</span>, kernel, stride=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>在卷积操作中，<code>stride</code>（步幅）是一个非常重要的参数，它定义了卷积核在输入张量上移动时的步长。</p><p>还可以设置<code>padding</code>参数：<code>padding</code>参数定义了在卷积操作之前，输入数据周围是否要添加额外的边界（通常为0）。</p><h2 id="最大池化层"><a href="#最大池化层" class="headerlink" title="最大池化层"></a>最大池化层</h2><p>最大池化与卷积的区别是，卷积是对窗口中的数对应相乘后求和，最大池化是求窗口中的最大值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个最大池化层，池化窗口大小为2x2，步长为2</span></span><br><span class="line">max_pool = nn.MaxPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>其的主要参数为：</p><ol><li><code>kernel_size</code>：表示池化窗口的大小。对于二维最大池化，它可以是单个整数或两个整数的元组（height, width）。如果是一个整数，则池化窗口将是一个正方形。</li><li><code>stride</code>：这是一个元组或整数，表示池化窗口在输入张量上移动的步长。<strong>默认情况下，<code>stride</code>与<code>kernel_size</code>相同。</strong></li><li><code>padding</code>：这是一个元组或整数，表示在输入张量的每个边上添加的填充数量。默认情况下，没有填充（<code>padding=0</code>）。</li></ol><h1 id="完整的训练过程"><a href="#完整的训练过程" class="headerlink" title="完整的训练过程"></a>完整的训练过程</h1><ol><li><p>准备数据集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">train_data = datasets.CIFAR10(root=<span class="string">&quot;/data&quot;</span>, train=<span class="literal">True</span>, transform=transforms.ToTensor(), download=<span class="literal">True</span>)</span><br><span class="line">test_data = datasets.CIFAR10(root=<span class="string">&quot;/data&quot;</span>, train=<span class="literal">False</span>, transform=transforms.ToTensor(), download=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></li><li><p>加载数据集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">train_dataloader = DataLoader(train_data, batch_size=<span class="number">64</span>)</span><br><span class="line">test_dataloader = DataLoader(test_data, batch_size=<span class="number">64</span>)</span><br></pre></td></tr></table></figure></li><li><p>搭建神经网络</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 搭建神经网络   </span></span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span>(nn.Module):     </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_init_</span>(<span class="params">self</span>):      </span><br><span class="line">        <span class="built_in">super</span>(Model, self)._init_()       </span><br><span class="line">        self.model = nn.Sequential(                  </span><br><span class="line">            nn.Conv2d(<span class="number">3</span>, <span class="number">32</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>),           </span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>),               </span><br><span class="line">            nn.Conv2d(<span class="number">32</span>, <span class="number">32</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>),          </span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>),                </span><br><span class="line">            nn.Conv2d(<span class="number">32</span>, <span class="number">64</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>),           </span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>),                </span><br><span class="line">            nn.Flatten(),                </span><br><span class="line">            nn.Linear(<span class="number">64</span>*<span class="number">4</span>*<span class="number">4</span>, <span class="number">64</span>),              </span><br><span class="line">            nn.Linear(<span class="number">64</span>, <span class="number">10</span>))             </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):                  </span><br><span class="line">        x = self.model(x)                  </span><br><span class="line">        <span class="keyword">return</span> x  </span><br></pre></td></tr></table></figure></li><li><p>创建网络模型，定义损失函数及优化器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建网络模型  </span></span><br><span class="line">model = Model()  </span><br><span class="line"><span class="comment">#损失函数  </span></span><br><span class="line">loss_fn = nn.CrossEntropyLoss()  </span><br><span class="line"><span class="comment">#优化器  </span></span><br><span class="line">learning_rate = <span class="number">0.01</span>  </span><br><span class="line">optimizer = torch.optim.SGD(model.parameters(), lr=learning_rate)</span><br></pre></td></tr></table></figure></li><li><p>设置训练网络中的参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置训练网络的一些参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 记录训练的次数</span></span><br><span class="line">total_train_step = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 记录测试的次数</span></span><br><span class="line">total_test_step = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练的轮数</span></span><br><span class="line">epoch = <span class="number">10</span></span><br></pre></td></tr></table></figure></li><li><p>开始训练</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(epoch):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;--------第&#123;&#125;轮训练开始-------&quot;</span>.<span class="built_in">format</span>(i+<span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 训练步骤开始</span></span><br><span class="line">    model.train() <span class="comment"># 如果有Dropout层，调用这个会激活其</span></span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> train_dataloader:</span><br><span class="line">        imgs, targets = data</span><br><span class="line">        outputs = model(imgs)</span><br><span class="line">        loss = loss_fn(outputs, targets)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 优化器优化模型</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        total_train_step = total_train_step + <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;训练次数:&#123;&#125;, Loss:&#123;&quot;</span>.<span class="built_in">format</span>(total_train_step,loss.item()))</span><br></pre></td></tr></table></figure></li><li><p>在测试集上测试模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#测试步骤开始</span></span><br><span class="line">model.<span class="built_in">eval</span>() <span class="comment"># 如果有Dropout层，调用这个会将其失效</span></span><br><span class="line">total_test_loss =<span class="number">0</span>  </span><br><span class="line"><span class="keyword">with</span> torch.no_grad():    </span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> test_dataloader:     </span><br><span class="line">        imgs, targets = data      </span><br><span class="line">        outputs = model(imgs)       </span><br><span class="line">        loss = loss_fn(outputs, targets)           </span><br><span class="line">        total_test_loss = total_test_loss + loss</span><br></pre></td></tr></table></figure></li></ol><h2 id="在GPU上训练"><a href="#在GPU上训练" class="headerlink" title="在GPU上训练"></a>在GPU上训练</h2><p>可以用Python命令<code>!nvidia-smi</code>查看GPU配置。</p><h3 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h3><p>对模型<code>model</code>、训练和测试时的数据<code>imgs,targets</code>、损失函数<code>loss</code>，调用<code>.cuda()</code>，让它们转移到GPU上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> torch.cuda.is_available():  </span><br><span class="line">    model = model.cuda()</span><br></pre></td></tr></table></figure><h3 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h3><p>可以用以下内容代替<code>.cuda()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">device = torch.device(<span class="string">&quot;gpu&quot;</span>)</span><br><span class="line">model = model.to(device)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 重生之我是程序员 </category>
          
          <category> Python笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python与操作系统交互</title>
      <link href="/post/772417664.html"/>
      <url>/post/772417664.html</url>
      
        <content type="html"><![CDATA[<h1 id="Python执行命令行指令"><a href="#Python执行命令行指令" class="headerlink" title="Python执行命令行指令"></a>Python执行命令行指令</h1><h2 id="执行命令行指令"><a href="#执行命令行指令" class="headerlink" title="执行命令行指令"></a>执行命令行指令</h2><p>首先导入<code>subprocess</code>模块，然后通过<code>subprocess.run</code>来执行命令行指令。</p><blockquote><p>指令是在当前运行的脚本的工作目录下执行的</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = subprocess.run(<span class="string">f&#x27;ls&#x27;</span>, shell=<span class="literal">True</span>, stdout=subprocess.PIPE, stderr=subprocess.PIPE,text=<span class="literal">True</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br></pre></td></tr></table></figure><p>函数的参数说明如下：</p><ul><li><code>args</code>：这个参数可以是一个字符串，也可以是一个程序参数列表。如果是字符串，需要加上<code>shell=True</code>参数，以便通过shell来解释这个命令。在这个例子中，<code>args</code>是<code>f&#39;ls&#39;</code>，表示执行<code>ls</code>命令。</li><li><code>shell=True</code>：这个参数指示<code>subprocess.run()</code>使用shell来执行这个命令。</li><li><code>stdout=subprocess.PIPE</code>和<code>stderr=subprocess.PIPE</code>：这两个参数表示子进程的标准输出和标准错误输出将被捕获，并通过<code>CompletedProcess</code>对象的<code>stdout</code>和<code>stderr</code>属性提供。如果这两个参数没有被设置，子进程的标准输出和标准错误输出将直接显示在屏幕（Python控制台）上。</li><li><code>text=True</code>：这个参数表示在<code>stdout</code>和<code>stderr</code>中的输出将以文本形式返回，而不是字节形式。这个参数需要Python 3.7或更高版本支持。</li><li><code>encoding=&#39;utf-8&#39;</code>：这个参数指定了编码方式，用于将字节转换为文本。在这个例子中，使用的是UTF-8编码。</li></ul><p>可以打印出标准输出和标准错误：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(result.stdout)</span><br><span class="line"><span class="built_in">print</span>(result.stderr)</span><br></pre></td></tr></table></figure><h2 id="更改工作目录"><a href="#更改工作目录" class="headerlink" title="更改工作目录"></a>更改工作目录</h2><p>因为<code>subprogress.run</code>是在当前工作目录下执行，所以需要切换工作目录，才能在指定的地方执行命令行指令。</p><p>在Python中，<code>os.chdir()</code> 函数用于改变当前工作目录到指定的路径。这个函数是<code>os</code>模块的一部分。另外可以用<code>os.getcwd()</code>来获取当前的工作目录。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前工作目录</span></span><br><span class="line">current_directory = os.getcwd()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;当前工作目录：&quot;</span>, current_directory)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改变工作目录到 &#x27;/path/to/another/directory&#x27;</span></span><br><span class="line">os.chdir(<span class="string">&#x27;/path/to/another/directory&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次获取当前工作目录</span></span><br><span class="line">current_directory = os.getcwd()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;改变后的工作目录：&quot;</span>, current_directory)</span><br></pre></td></tr></table></figure><h1 id="Python与文件管理"><a href="#Python与文件管理" class="headerlink" title="Python与文件管理"></a>Python与文件管理</h1><h2 id="构建完整路径"><a href="#构建完整路径" class="headerlink" title="构建完整路径"></a>构建完整路径</h2><p><code>os.path.join(root, file)</code>，这个函数用于将两个或多个路径组件合并为一个完整的路径。它智能地处理目录分隔符（如UNIX系统中的<code>/</code>或Windows系统中的<code>\</code>），并确保路径的正确性。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">root = <span class="string">&#x27;/path/to/directory&#x27;</span></span><br><span class="line">file = <span class="string">&#x27;example.txt&#x27;</span></span><br><span class="line">full_path = os.path.join(root, file)</span><br></pre></td></tr></table></figure><h2 id="列出目录下的文件和子目录"><a href="#列出目录下的文件和子目录" class="headerlink" title="列出目录下的文件和子目录"></a>列出目录下的文件和子目录</h2><p><code>os.listdir(path)</code>，这个函数用于列出指定路径下的所有文件和目录（子目录）的名称。它返回一个列表，包含<code>path</code>指定的目录中的所有文件和子目录的名称。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">new_articles_dir = <span class="string">&#x27;/path/to/directory&#x27;</span></span><br><span class="line">files_and_dirs = os.listdir(new_articles_dir)</span><br></pre></td></tr></table></figure><h2 id="检查给定路径是否是文件"><a href="#检查给定路径是否是文件" class="headerlink" title="检查给定路径是否是文件"></a>检查给定路径是否是文件</h2><p><code>os.path.isfile(path)</code>，这个函数用于检查给定的路径是否是一个文件。如果<code>path</code>是一个存在的文件，它返回<code>True</code>；如果<code>path</code>不存在或者是一个目录，它返回<code>False</code>。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">path = <span class="string">&#x27;/path/to/file.txt&#x27;</span></span><br><span class="line"><span class="keyword">if</span> os.path.isfile(path):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;path&#125;</span> 是一个文件&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;path&#125;</span> 不是一个文件&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="删除指定文件"><a href="#删除指定文件" class="headerlink" title="删除指定文件"></a>删除指定文件</h2><p><code>os.remove(file_path)</code>，这个函数用于删除指定的文件。如果<code>file_path</code>是一个文件并且删除成功，函数不会有任何返回值。如果文件不存在或者由于某些原因（如权限问题）无法删除，会抛出一个<code>OSError</code>异常。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">file_path = <span class="string">&#x27;/path/to/file.txt&#x27;</span></span><br><span class="line">os.remove(file_path)</span><br></pre></td></tr></table></figure><h2 id="删除给定文件夹"><a href="#删除给定文件夹" class="headerlink" title="删除给定文件夹"></a>删除给定文件夹</h2><p><code>shutil.rmtree()</code> 函数用于<strong>递归删除目录及其所有子目录和文件</strong>。<code>shutil</code> 是 Python 的一个模块，提供了许多文件操作的高级函数。</p><p><code>shutil.rmtree(path, ignore_errors=False, onerror=None)</code> 函数的参数说明如下：</p><ul><li><code>path</code>：这是一个字符串，表示要删除的目录的路径。</li><li><code>ignore_errors</code>：这是一个布尔值，默认为<code>False</code>。如果设置为<code>True</code>，则在删除过程中忽略发生的错误。</li><li><code>onerror</code>：这是一个函数，用于处理在删除过程中发生的错误。如果指定了这个参数，它应该是一个接受三个参数的函数：(errno, strerror, filename)。在这个函数中，你可以定义错误处理逻辑。</li></ul><p>这是一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要删除的目录路径</span></span><br><span class="line">dir_path = <span class="string">&#x27;/path/to/directory&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归删除目录及其所有子目录和文件</span></span><br><span class="line">shutil.rmtree(dir_path)</span><br></pre></td></tr></table></figure><h2 id="复制给定文件夹"><a href="#复制给定文件夹" class="headerlink" title="复制给定文件夹"></a>复制给定文件夹</h2><p><code>shutil.copytree()</code> 函数用于递归地复制一个目录树从一个位置到另一个位置。</p><p><code>shutil.copytree(src, dst)</code> 中参数说明如下：</p><ul><li><code>src</code>：这是一个字符串，表示源目录的路径，即要复制的目录。</li><li><code>dst</code>：这是一个字符串，表示目标目录的路径，即复制的目录将被放置的地方。<strong>如果目标目录已经存在，<code>shutil.copytree()</code> 将会抛出一个 <code>FileExistsError</code> 异常</strong>。如果目标目录不存在，它将会被创建。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="comment"># 源目录和目标目录的路径</span></span><br><span class="line">source_item = <span class="string">&#x27;/path/to/source_directory&#x27;</span></span><br><span class="line">destination_item = <span class="string">&#x27;/path/to/destination_directory&#x27;</span></span><br><span class="line"><span class="comment"># 递归复制目录树</span></span><br><span class="line">shutil.copytree(source_item, destination_item)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 重生之我是程序员 </category>
          
          <category> Python笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从零开始搭建一个简易神经网络</title>
      <link href="/post/2484359005.html"/>
      <url>/post/2484359005.html</url>
      
        <content type="html"><![CDATA[<h1 id="神经网络简述"><a href="#神经网络简述" class="headerlink" title="神经网络简述"></a>神经网络简述</h1><h2 id="神经元"><a href="#神经元" class="headerlink" title="神经元"></a>神经元</h2><p>神经网络通过模拟人神经元的活动，通过输入预测输出。</p><p><img src="/images/从零开始搭建一个简易神经网络.assets/image-20240424091712887.png" alt="image-20240424091712887"></p><p>神经网络中的一个神经元的树突接触到输入，然后经过计算之后从轴突上传出信号。</p><p>经过抽象之后，一个神经元就长这样：</p><p><img src="/images/从零开始搭建一个简易神经网络.assets/image-20240430201657690.png" alt="image-20240430201657690"></p><p>其接受3个输入，$x_1,x_2,x_3$，经过线性运算$w^Tx+b$，和激活函数$\sigma(z)$后，输出$a$​​。</p><blockquote><p>$w$是一个$3\times1$的列向量，$x$是一个$3\times1$的列向量，$b$是一个实数</p></blockquote><h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><p>多个神经元（cell）一起就组成了神经网络，一个神经网络可以表示为如下这样：</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  %%{ init : { &#39;flowchart&#39; : { &#39;curve&#39; : &#39;basis&#39; }}}%%flowchart LRage((年龄))salary((薪水))age-.-&gt;x1((cell)) &amp; x2((cell)) &amp; x3((cell))salary-.-&gt;x1 &amp; x2 &amp; x3x1 &amp; x2 &amp; x3-.-&gt;x4((cell)) &amp; x5((cell)) &amp; x6((cell)) -.-&gt;output((sigmoid))--&gt;y((结果))  </pre></div><p>其中从左到右第一层称为输入层，第二、三层称为隐藏层，第四层成为输出层。</p><h2 id="神经网络的工作方式"><a href="#神经网络的工作方式" class="headerlink" title="神经网络的工作方式"></a>神经网络的工作方式</h2><p>神经网络的每一层都是由多个神经元组成的，这里取这样的一层神经元：</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  %%{ init : { &#39;flowchart&#39; : { &#39;curve&#39; : &#39;basis&#39; }}}%%flowchart LRage((x1))salary((x2))age-.-&gt;x1((cell)) &amp; x2((cell)) &amp; x3((cell))salary-.-&gt;x1 &amp; x2 &amp; x3x1--&gt;y1((y1))x2--&gt;y2((y2))x3--&gt;y3((y3))  </pre></div><p>那么：</p><ul><li>第一个神经元计算$a_1=w_1^Tx+b_1$与$y_1=\sigma(a_1)$。</li><li>第二个神经元计算$a_2=w_2^Tx+b_2$与$y_2=\sigma(a_2)$</li><li>第三个神经元计算$a_3=w_3^Tx+b_1$与$y_3=\sigma(a_3)$</li></ul><blockquote><p>这里，$w_i$是一个$2\times1$的列向量，$x$是一个$2\times1$的列向量，$b$​是一个实数</p></blockquote><p>因为每个神经元执行的操作类似，所以可以将$w_i$和$b$堆叠起来，以表示输入通过这一层神经元得到的输出。</p><p>我们将所有的 $w^T_i$ 按行堆叠成一个矩阵$W$，其中每一行对应一个神经元的权重向量的转置 $w^T_i$。</p><script type="math/tex; mode=display">W = \left[ \begin{array}{cc}w_1^T \\w_2^T \\w_3^T\end{array} \right]</script><p>将所有的偏置 $b_i$ 按行堆叠成一个列向量，其中每个元素对应一个神经元的偏置 $b_i$。因此，堆叠后的 $b$ 将是一个 $3 \times 1$ 的列向量：</p><script type="math/tex; mode=display">b = \left[ \begin{array}{c}b_1 \\b_2 \\b_3\end{array} \right]</script><p>这里，每个 $b_i$ 是一个实数。</p><p>现在，我们可以用堆叠后的 $W$ 和 $b$ 来表示所有神经元的输出：</p><script type="math/tex; mode=display">Y =\sigma( WX + b)</script><p>其中，$Y$ 是一个 $3 \times 1$ 的列向量，包含了所有神经元的输出；$X$ 是一个 $2 \times 1$ 的列向量，表示输入特征。</p><h2 id="多样本"><a href="#多样本" class="headerlink" title="多样本"></a>多样本</h2><p>到目前为止，神经网络的输入还是单样本，但在实际的问题中，遇到的都是多样本，如果一个个样本输入则太慢了。</p><p>又考虑到每个样本$x_i$在神经网络中所经过的计算是相似的。所以，同样的想法，可以将样本$x_1,x_2,\cdots,x_n$按列的方式堆叠成一个矩阵$X$。</p><script type="math/tex; mode=display">X = \left[\begin{array}{cccc}| & | &  & | \\x^{(1)} & x^{(2)} & \cdots & x^{(n)} \\| & | &  & |\end{array}\right]</script><p>展开来就是：</p><script type="math/tex; mode=display">X = \left[\begin{array}{cccc}x^{(1)}_1 & x^{(2)}_1 & \cdots & x^{(n)}_1 \\x^{(1)}_2 & x^{(2)}_2 & \cdots & x^{(n)}_2 \\\vdots & \vdots & \ddots & \vdots \\x^{(1)}_{m} & x^{(2)}_{m} & \cdots & x^{(n)}_{m}\end{array}\right]</script><blockquote><p>$m$个特征，$n$个样本</p></blockquote><p>而每层的计算方式并没有因为样本的堆叠发生改变，仍然是：</p><script type="math/tex; mode=display">Y =\sigma( WX + b)</script><blockquote><p>这里意思是每一列都加上$b$</p></blockquote><p>只不过矩阵的维度发生了变化：</p><ul><li>$X$维度变为$(m,n)$</li><li>$Y$的维度变为$(m’,n)$​</li></ul><blockquote><p>$W$矩阵的维度是$(m’,m)$​维</p></blockquote><h2 id="更新参数"><a href="#更新参数" class="headerlink" title="更新参数"></a>更新参数</h2><p>刚才所述统都属于前向传播的过程，而到这里还有一个关键的问题没有解决，就是神经网络的参数$W$和$b$​​要怎么更新。如果不更新，神经网络就无法学习样本中的特征。所以就需要引入反向传播算法，用于更新这两个参数。</p><p>而反向传播算法中常用的是梯度下降。</p><h3 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h3><p>考虑一个函数$z=f(x,y)$，在高数中学过，其在$x_0,y_0$增长最快的方向就是函数$f(x,y)$在这一点的梯度向量的方向。而$f(x,y)$在$(x_0,y_0)$处的梯度向量是$(\frac{\partial f}{\partial x}|_{x_0,y_0},\frac{\partial f}{\partial y}|_{x_0,y_0})$。所以$(x_0+\frac{\partial f}{\partial x}|_{x_0,y_0},y_0+\frac{\partial f}{\partial y}|_{x_0,y_0})$可以使得$f(x,y)$​增长最快。</p><p>那么相反的（如果一个函数是凸的），函数的减小最快的方向就是梯度向量的反方向，即$(x_0-\frac{\partial f}{\partial x}|_{x_0,y_0},y_0-\frac{\partial f}{\partial y}|_{x_0,y_0})$</p><h3 id="神经网络中的梯度下降"><a href="#神经网络中的梯度下降" class="headerlink" title="神经网络中的梯度下降"></a>神经网络中的梯度下降</h3><p>在神经网络中也是类似的，损失函数$f$（也就是神经网络预测的$\hat y$和实际的$y$的偏差）是各层权重矩阵$W$和偏置向量$b$的函数。</p><p>所以也可以用同样的方法去更新$W$和$b$​：</p><script type="math/tex; mode=display">W=W-\alpha \cdot \frac{\partial f}{\partial W}\\b=b-\alpha \cdot \frac{\partial f}{\partial b}</script><blockquote><p>这里的$\alpha$​是学习率</p></blockquote><p>下面直接给出神经网络中单层的梯度下降公式：</p><ul><li><p>计算 $dZ^{[l]}$：$dZ^{[l]} = dA^{[l]} * g^{[l]’}(Z^{[l]})$</p></li><li><p>计算 $dW^{[l]}$：$dW^{[l]} = \frac{1}{m} dZ^{[l]} \cdot A^{[l-1]T}$</p></li><li><p>计算 $db^{[l]}$：$db^{[l]} = \frac{1}{m}np.sum(dZ^{[l]},axis=1,keepdims=True)$</p></li><li><p>计算 $dA^{[l-1]}$：$dA^{[l-1]} = W^{[l]T} \cdot dZ^{[l]}$</p></li></ul><blockquote><p>其中，$dA^{[l]}$ 是损失函数对 $A^{[l]}$ 的梯度，$dZ^{[l]}$ 是损失函数对 $Z^{[l]}$​ 的梯度。上标$[l]$指的是第$l$​层。以此类推。</p><p>[!NOTE]</p><p>如果想看详细的证明，推荐吴恩达在B站的深度学习课程，这是相关的几节：</p><p><a href="https://www.bilibili.com/video/BV1FT4y1E74V?p=10&amp;vd_source=a72ba0205e5decee94fccb8c6b66a1e2">梯度下降法</a>、<a href="https://www.bilibili.com/video/BV1FT4y1E74V?p=15&amp;vd_source=a72ba0205e5decee94fccb8c6b66a1e2">逻辑回归中的梯度下降法</a>、<a href="https://www.bilibili.com/video/BV1FT4y1E74V?p=16">m个样本的梯度下降</a>、<a href="https://www.bilibili.com/video/BV1FT4y1E74V?p=33&amp;vd_source=a72ba0205e5decee94fccb8c6b66a1e2">神经网络中的梯度下降</a>、<a href="https://www.bilibili.com/video/BV1FT4y1E74V?p=34&amp;vd_source=a72ba0205e5decee94fccb8c6b66a1e2">直观理解反向传播</a></p></blockquote><h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><p>采用<code>Python</code>编写程序，需要用到的库有：</p><ul><li><code>numpy</code>：用于矩阵计算</li><li><code>tensorboard</code>（可选）：用来记录训练数据</li></ul><h1 id="单层神经元"><a href="#单层神经元" class="headerlink" title="单层神经元"></a>单层神经元</h1><p>因为可以将神经网络拆分成一层层神经元的堆叠，所以只要写好一层，将这层复制多份，就可以构建一个神经网络。所以可以创建一个名叫<code>Layer</code>的类，代表一层神经元</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  flowchart LRsubgraph 神经网络layer1[layer]layer2[layer]endinput--&gt;layer1--&gt;layer2--&gt;output  </pre></div><p>而如刚才所述，每一层都进行前向传播和反向传播。而在实现前向传播和反向传播之前，先来考虑每一层中应该有什么元素。</p><h2 id="Layer类中的变量"><a href="#Layer类中的变量" class="headerlink" title="Layer类中的变量"></a>Layer类中的变量</h2><p>再回头看抽象出来的神经元以及前向传播和反向传播的过程：</p><p>可以看出，每一层需要有权重矩阵<code>W</code>，偏置矩阵<code>b</code>，还有选用的激活函数$\sigma$。</p><p>除此之外，构建权重矩阵<code>W</code>时还需要知道该层结点数目；在实现反向传播的时候还需要知道该层神经网络的输入$A^{[l-1]}$、该层神经网络的输出对损失函数的导数$dA^{[l]}$、学习率$\alpha$、$WX+b$的输出$Z$以及样本数$m$。</p><p>所以类的成员变量如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Layer</span>:</span><br><span class="line">    <span class="comment"># 神经元参数</span></span><br><span class="line">    __W = <span class="literal">None</span>  <span class="comment"># 权重矩阵</span></span><br><span class="line">    __b = <span class="literal">None</span>  <span class="comment"># 偏置部分</span></span><br><span class="line">    __A_last_layer = <span class="literal">None</span>  <span class="comment"># 上层的输入</span></span><br><span class="line">    __Z = <span class="literal">None</span>  <span class="comment"># Wx+b得到的Z，之后会在反向传播中运用</span></span><br><span class="line">    __activation_function = <span class="literal">None</span>  <span class="comment"># 激活函数类型</span></span><br><span class="line">    __node_amount = <span class="literal">None</span>  <span class="comment"># 结点数目</span></span><br><span class="line">    __alpha = <span class="literal">None</span>  <span class="comment"># 学习率</span></span><br><span class="line">    __sample_amount = <span class="literal">None</span>  <span class="comment"># 样本数</span></span><br></pre></td></tr></table></figure><p>再给出构造函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, last_layer_node_amount, node_amount=<span class="number">4</span>, activation_function=<span class="string">&quot;relu&quot;</span>, alpha=<span class="number">0.1</span></span>):</span><br><span class="line">    <span class="comment"># 初始化节点数量和激活函数类型</span></span><br><span class="line">    self.__node_amount = node_amount</span><br><span class="line">    self.__activation_function = activation_function</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化权重矩阵</span></span><br><span class="line">    self.__W = np.random.randn(node_amount, last_layer_node_amount) * np.sqrt(<span class="number">2</span> / last_layer_node_amount)</span><br><span class="line">    <span class="comment"># 初始化偏置矩阵</span></span><br><span class="line">    self.__b = np.random.randn(node_amount, <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 设置学习率</span></span><br><span class="line">    self.__alpha = alpha</span><br></pre></td></tr></table></figure><h2 id="前向传播"><a href="#前向传播" class="headerlink" title="前向传播"></a>前向传播</h2><p>之后，就可以开始实现最简单的前向传播算法，总共就只有两步：</p><ol><li>计算$WX+b$得到$Z$​</li><li>根据激活函数的不同，选择不同的激活函数计算$Y=\sigma(Z)$</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, X: np.ndarray</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    前向传播</span></span><br><span class="line"><span class="string">    :param X: 每一列是一个样本，每一行是一个特征</span></span><br><span class="line"><span class="string">    :return: 该层的输出，保持每一列是一个样本，每一行是一个特征</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 设置样本数</span></span><br><span class="line">    self.__sample_amount = X.shape[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 前向传播</span></span><br><span class="line">    self.__A_last_layer = X</span><br><span class="line">    self.__Z = np.dot(self.__W, X) + self.__b  <span class="comment"># 计算WX+b</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.__activation_function == <span class="string">&quot;relu&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> activation_function.relu(self.__Z)</span><br><span class="line">    <span class="keyword">elif</span> self.__activation_function == <span class="string">&quot;sigmoid&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> activation_function.sigmoid(self.__Z)</span><br><span class="line">    <span class="keyword">elif</span> self.__activation_function == <span class="string">&quot;linear&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> activation_function.linear(self.__Z)</span><br><span class="line">    <span class="keyword">elif</span> self.__activation_function == <span class="string">&quot;tanh&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> activation_function.tanh(self.__Z)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> <span class="string">&quot;invalid activation function!&quot;</span></span><br></pre></td></tr></table></figure><p>这里以<code>relu</code>为例，给出激活函数的实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">relu</span>(<span class="params">Z: np.ndarray</span>):</span><br><span class="line">    <span class="keyword">return</span> np.where(Z &gt; <span class="number">0</span>, Z, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h2><p>反向传播是整个代码中最复杂的部分，但只要掌握这四条公式，也是四个步骤，写下来也不难：</p><ol><li>计算 $dZ^{[l]}$：$dZ^{[l]} = dA^{[l]} * g^{[l]’}(Z^{[l]})$</li><li><p>计算 $dW^{[l]}$：$dW^{[l]} = \frac{1}{m} dZ^{[l]} \cdot A^{[l-1]T}$</p></li><li><p>计算 $db^{[l]}$：$db^{[l]} = \frac{1}{m}np.sum(dZ^{[l]},axis=1,keepdims=True)$</p></li><li><p>计算 $dA^{[l-1]}$：$dA^{[l-1]} = W^{[l]T} \cdot dZ^{[l]}$</p></li></ol><p>转换为对应代码，即为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self, dA</span>):</span><br><span class="line">    dZ = <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 计算dZ</span></span><br><span class="line">    <span class="keyword">if</span> self.__activation_function == <span class="string">&quot;relu&quot;</span>:</span><br><span class="line">        dZ = dA * activation_function.d_relu(self.__Z)</span><br><span class="line">    <span class="keyword">elif</span> self.__activation_function == <span class="string">&quot;sigmoid&quot;</span>:</span><br><span class="line">        dZ = dA * activation_function.d_sigmoid(self.__Z)</span><br><span class="line">    <span class="keyword">elif</span> self.__activation_function == <span class="string">&quot;linear&quot;</span>:</span><br><span class="line">        dZ = dA * activation_function.d_linear(self.__Z)</span><br><span class="line">    <span class="keyword">elif</span> self.__activation_function == <span class="string">&quot;tanh&quot;</span>:</span><br><span class="line">        dZ = dA * activation_function.d_tanh(self.__Z)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> <span class="string">&quot;invalid activation function!&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算上一层的dA</span></span><br><span class="line">    dA_last_layer = np.dot(self.__W.T, dZ)</span><br><span class="line">    <span class="comment"># 更新权重矩阵</span></span><br><span class="line">    self.__W -= self.__alpha * (<span class="number">1</span> / self.__sample_amount) * np.dot(dZ, self.__A_last_layer.T)</span><br><span class="line">    <span class="comment"># 更新偏置量</span></span><br><span class="line">    self.__b -= (<span class="number">1</span> / self.__sample_amount) * np.<span class="built_in">sum</span>(dZ, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dA_last_layer</span><br></pre></td></tr></table></figure><p>这里以<code>relu</code>为例，给出激活函数导数的实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">d_relu</span>(<span class="params">Z: np.ndarray</span>):</span><br><span class="line">    <span class="keyword">return</span> np.where(Z &gt; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h1 id="神经网络的封装"><a href="#神经网络的封装" class="headerlink" title="神经网络的封装"></a>神经网络的封装</h1><p>写好单层之后，将单层神经元进行堆叠就可以得到完整的神经网络。</p><p>定义一个Network类，用于保存神经网络。以下是其的成员变量和构造函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Network</span>:</span><br><span class="line">    __layers = []  <span class="comment"># 保存隐藏层和输出层</span></span><br><span class="line">    __X_train, __Y_train, __X_test, __Y_test = <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>  <span class="comment"># 训练集和测试集</span></span><br><span class="line">    __loss_function = <span class="literal">None</span>  <span class="comment"># 损失函数</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, nodes_amount: <span class="built_in">list</span>, X_train, Y_train, X_test, Y_test, learning_speed,</span></span><br><span class="line"><span class="params">             output_layer_function=<span class="string">&quot;sigmoid&quot;</span>,</span></span><br><span class="line"><span class="params">             hidden_layer_function=<span class="string">&quot;relu&quot;</span>,</span></span><br><span class="line"><span class="params">             loss_function=<span class="string">&quot;cross entropy&quot;</span></span>):  <span class="comment"># 通过字符串来选择隐藏层，输出层的激活函数，还有损失函数</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    初始化神经网络</span></span><br><span class="line"><span class="string">    :param nodes_amount: 每层的结点数</span></span><br><span class="line"><span class="string">    :param X_train: 训练数据，每行是不同特征，每列是不同样本</span></span><br><span class="line"><span class="string">    :param Y_train: 训练标签，每行使不同特征，每列是不同样本</span></span><br><span class="line"><span class="string">    :param X_test: 测试数据，每行是不同特征，每列是不同样本</span></span><br><span class="line"><span class="string">    :param Y_test: 测试标签，每行是不同特征，每列是不同样本</span></span><br><span class="line"><span class="string">    :param learning_speed: 学习速率</span></span><br><span class="line"><span class="string">    :param output_layer_function: 输出层激活函数</span></span><br><span class="line"><span class="string">    :param hidden_layer_function: 隐藏层激活函数</span></span><br><span class="line"><span class="string">    :param loss_function: 损失函数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 判断维度是否正确</span></span><br><span class="line">    <span class="keyword">if</span> X_train.shape[<span class="number">0</span>] != X_test.shape[<span class="number">0</span>] <span class="keyword">or</span> Y_train.shape[<span class="number">0</span>] != Y_test.shape[<span class="number">0</span>] <span class="keyword">or</span> X_train.shape[<span class="number">1</span>:] != \</span><br><span class="line">            Y_train.shape[<span class="number">1</span>:] <span class="keyword">or</span> X_test.shape[<span class="number">1</span>:] != Y_test.shape[<span class="number">1</span>:]:</span><br><span class="line">        <span class="keyword">raise</span> <span class="string">&quot;dimension error&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存损失函数</span></span><br><span class="line">    <span class="keyword">if</span> loss_function == <span class="string">&quot;cross entropy&quot;</span>:</span><br><span class="line">        self.__loss_function = loss_function</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> <span class="string">&quot;loss function name error&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存训练集、测试集</span></span><br><span class="line">    self.__X_train = X_train</span><br><span class="line">    self.__X_test = X_test</span><br><span class="line">    self.__Y_train = Y_train</span><br><span class="line">    self.__Y_test = Y_test</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化神经网络</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nodes_amount)):</span><br><span class="line">        <span class="keyword">if</span> index == <span class="number">0</span>:</span><br><span class="line">            self.__layers.append(</span><br><span class="line">                layer.Layer(X_train.shape[<span class="number">0</span>], nodes_amount[index], hidden_layer_function, learning_speed))</span><br><span class="line">        <span class="keyword">elif</span> index &lt; <span class="built_in">len</span>(nodes_amount) - <span class="number">1</span>:</span><br><span class="line">            self.__layers.append(</span><br><span class="line">                layer.Layer(nodes_amount[index - <span class="number">1</span>], nodes_amount[index], hidden_layer_function, learning_speed))</span><br><span class="line">        <span class="keyword">elif</span> index == <span class="built_in">len</span>(nodes_amount) - <span class="number">1</span>:</span><br><span class="line">            self.__layers.append(</span><br><span class="line">                layer.Layer(nodes_amount[index - <span class="number">1</span>], nodes_amount[index], output_layer_function, learning_speed))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="神经网络的训练"><a href="#神经网络的训练" class="headerlink" title="神经网络的训练"></a>神经网络的训练</h2><p>因为每一层的前向传播和反向传播都是已经写好的。所以在整个神经网络的训练过程中，只需要逐层调用前向传播和反向传播即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">self, times</span>):</span><br><span class="line">    <span class="comment"># 增加计数器</span></span><br><span class="line">    count = increment_counter()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#tensorboard记录</span></span><br><span class="line">    writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> iteration <span class="keyword">in</span> <span class="built_in">range</span>(times):</span><br><span class="line">        <span class="comment"># 正向传播</span></span><br><span class="line">        layer_input = self.__X_train</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.__layers)):</span><br><span class="line">            layer = self.__layers[index]</span><br><span class="line">            layer_input = layer.forward(layer_input)</span><br><span class="line"></span><br><span class="line">        dA = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> self.__loss_function == <span class="string">&quot;cross entropy&quot;</span>:</span><br><span class="line">            <span class="comment"># 计算误差。最后一层对下一层的输入就是最终输出</span></span><br><span class="line">            loss = loss_function.cross_entropy(layer_input, self.__Y_train)</span><br><span class="line">            <span class="comment">#记录数据</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;iteration:<span class="subst">&#123;iteration&#125;</span>,loss:<span class="subst">&#123;loss&#125;</span>&#x27;</span>)</span><br><span class="line">            writer.add_scalar(<span class="string">f&#x27;loss<span class="subst">&#123;count&#125;</span>&#x27;</span>, loss, iteration)</span><br><span class="line">            <span class="comment"># 计算最终输出对损失函数的偏导数</span></span><br><span class="line">            dA = loss_function.d_cross_entropy(layer_input, self.__Y_train)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#反向传播</span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.__layers) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            layer = self.__layers[index]</span><br><span class="line">            dA = layer.backward(dA)</span><br><span class="line">    writer.close()</span><br></pre></td></tr></table></figure><p>因为在反向传播的时候需要给出该层神经元输出对损失函数的偏导数，所以需要计算最终输出对损失函数的偏导数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dA = loss_function.d_cross_entropy(layer_input, self.__Y_train)</span><br></pre></td></tr></table></figure><p>这里的损失函数采取的是交叉熵函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cross_entropy</span>(<span class="params">A: np.ndarray, Y: np.ndarray</span>):</span><br><span class="line">    <span class="keyword">if</span> A.shape != Y.shape:</span><br><span class="line">        <span class="keyword">raise</span> <span class="string">&quot;dimension is not match&quot;</span></span><br><span class="line">    m = A.shape[<span class="number">1</span>]</span><br><span class="line">    loss = Y * np.log(A) + (<span class="number">1</span> - Y) * np.log(<span class="number">1</span> - A)</span><br><span class="line">    loss = (-<span class="number">1</span> / m) * np.<span class="built_in">sum</span>(loss, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> loss</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">d_cross_entropy</span>(<span class="params">A: np.ndarray, Y: np.ndarray</span>):</span><br><span class="line">    <span class="keyword">if</span> A.shape != Y.shape:</span><br><span class="line">        <span class="keyword">raise</span> <span class="string">&quot;dimension is not match&quot;</span></span><br><span class="line">    dA = -(Y * (<span class="number">1</span> / A) + (Y - <span class="number">1</span>) * (<span class="number">1</span> / (<span class="number">1</span> - A)))</span><br><span class="line">    <span class="keyword">return</span> dA</span><br></pre></td></tr></table></figure><p>至此，整个训练过程的代码就写完了</p><h2 id="神经网络的预测"><a href="#神经网络的预测" class="headerlink" title="神经网络的预测"></a>神经网络的预测</h2><p>神经网络的预测实际上就是对特征矩阵做一次前向传播，神经网络的输出就是预测结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, X</span>):</span><br><span class="line">    layer_input = X</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.__layers)):</span><br><span class="line">        layer = self.__layers[index]</span><br><span class="line">        layer_input = layer.forward(layer_input)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> layer_input</span><br></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>至此，整个神经网络的框架就搭建好了。主要的两个类是单层神经元<code>Layer</code>以及神经网络类<code>Network</code>：<code>Layer</code>类需要实现前向传播和反向传播，<code>Network</code>类需要实现训练的过程。</p><p>其他的例如激活函数的改变、损失函数的改变，只需要在原有的框架下写一些条件判断即可。</p>]]></content>
      
      
      <categories>
          
          <category> 重生之我是程序员 </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>爬虫笔记</title>
      <link href="/post/498308509.html"/>
      <url>/post/498308509.html</url>
      
        <content type="html"><![CDATA[<h1 id="模拟发送-HTTP-请求"><a href="#模拟发送-HTTP-请求" class="headerlink" title="模拟发送 HTTP 请求"></a>模拟发送 HTTP 请求</h1><h2 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h2><p>GET请求是HTTP协议中定义的一种请求方法，用于从服务器获取数据。当发起一个GET请求时，客户端（通常是用户的网页浏览器）向服务器发送一个请求，请求服务器返回指定的资源或数据。当我们用浏览器打开网页时，其实发送的最原始的请求就是 GET 请求</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests </span><br><span class="line">res = requests.get(<span class="string">&#x27;http://www.douban.com&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(res) </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(res)) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line">&lt;Response [<span class="number">200</span>]&gt; </span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;requests.models.Response&#x27;</span>&gt; </span><br></pre></td></tr></table></figure><p>可以看到，我们得到的是一个 <code>Response</code> 对象</p><p>如果我们要获取网站返回的数据，可以使用 <code>text</code> 或者 <code>content</code> 属性来获取</p><p><code>text</code>：是以字符串的形式返回数据</p><p><code>content</code>：是以二进制的方式返回数据</p><h2 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h2><p>POST请求是HTTP协议中定义的另一种请求方法，用于向服务器提交数据。当发起一个POST请求时，客户端向服务器发送数据，并且这些数据通常作为HTTP请求的一部分（称为请求体）被发送。</p><p>对于 POST 请求，一般就是提交一个表单。<code>data</code> 当中，就是需要传递的表单信息，是一个字典类型的数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r = requests.post(<span class="string">&#x27;http://www.xxxx.com&#x27;</span>, data=&#123;<span class="string">&quot;key&quot;</span>: <span class="string">&quot;value&quot;</span>&#125;) </span><br></pre></td></tr></table></figure><h2 id="header-增强"><a href="#header-增强" class="headerlink" title="header 增强"></a>header 增强</h2><p>requests 发送的请求所带的请求头中 User-Agent 会标识为 python 程序发送的请求。</p><p>由于这种行为仅仅是消耗服务器资源带来成本，但是不会给对方带来任何好处（搜索引擎的爬虫除外），所以有一些网站会加入反爬机制，通过识别 headers 来拒绝对你的请求进行响应。</p><p>所以需要做一些 header 增强。比如：UA，Cookie，host 等等信息。</p><p>浏览器访问网站时的 headers 可以在<a href="https://link.zhihu.com/?target=https%3A//httpbin.org/headers">httpbin.org/headers</a> 中得到。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;headers&quot;: &#123;</span><br><span class="line">    &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;, </span><br><span class="line">    &quot;Accept-Encoding&quot;: &quot;gzip, deflate, br&quot;, </span><br><span class="line">    &quot;Accept-Language&quot;: &quot;zh-CN,zh-Hans;q=0.9&quot;, </span><br><span class="line">    &quot;Host&quot;: &quot;httpbin.org&quot;, </span><br><span class="line">    &quot;Referer&quot;: &quot;https://link.zhihu.com/?target=https%3A//httpbin.org/headers&quot;, </span><br><span class="line">    &quot;Sec-Fetch-Dest&quot;: &quot;document&quot;, </span><br><span class="line">    &quot;Sec-Fetch-Mode&quot;: &quot;navigate&quot;, </span><br><span class="line">    &quot;Sec-Fetch-Site&quot;: &quot;cross-site&quot;, </span><br><span class="line">    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.4.1 Safari/605.1.15&quot;, </span><br><span class="line">    &quot;X-Amzn-Trace-Id&quot;: &quot;Root=1-662b0580-3525d80357418fc75f2d3472&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的请求头复制下来，传给 <code>requests.get()</code> 函数，即可将请求伪装成浏览器。</p><p><code>requests.get()</code> 的语法是：<code>requests.get(url,kwargs)</code>。</p><p>其中，url 是我们想要访问的链接，kwargs 是可选参数，包括params、data、json、headers、cookies、auth、files、timeout、proxies、stream、verify、cert等。常用的参数有data、headers。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://httpbin.org/headers&#x27;</span></span><br><span class="line"></span><br><span class="line">headers= &#123;</span><br><span class="line">    <span class="string">&quot;Accept&quot;</span>: <span class="string">&quot;image/gif, image/jpeg, image/pjpeg, application/x-ms-application, application/xaml+xml, application/x-ms-xbap, */*&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Accept-Encoding&quot;</span>: <span class="string">&quot;gzip, deflate&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Accept-Language&quot;</span>: <span class="string">&quot;zh-Hans-CN,zh-Hans;q=0.8,en-US;q=0.5,en;q=0.3&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Host&quot;</span>: <span class="string">&quot;httpbin.org&quot;</span>, </span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; Tablet PC 2.0; wbx 1.0.0; wbxapp 1.0.0; Zoom 3.6.0)&quot;</span>, </span><br><span class="line">    <span class="string">&quot;X-Amzn-Trace-Id&quot;</span>: <span class="string">&quot;Root=1-628b672d-4d6de7f34d15a77960784504&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">response = requests.get(url,headers=headers)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">    <span class="built_in">print</span>(response.text) </span><br></pre></td></tr></table></figure><h1 id="解析-HTML"><a href="#解析-HTML" class="headerlink" title="解析 HTML"></a>解析 HTML</h1><p>现在我们已经获取到了网页返回的数据，即 HTML 代码，下面就需要解析 HTML，来提取其中有效的信息。</p><h2 id="BeautifulSoup"><a href="#BeautifulSoup" class="headerlink" title="BeautifulSoup"></a>BeautifulSoup</h2><p><code>BeautifulSoup</code> 是 Python 的一个库，最主要的功能是从网页解析数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup  <span class="comment"># 导入 BeautifulSoup 的方法 </span></span><br><span class="line"><span class="comment"># 可以传入一段字符串，或者传入一个文件句柄。一般都会先用 requests 库获取网页内容，然后使用 soup 解析。 </span></span><br><span class="line">soup = BeautifulSoup(html_doc,<span class="string">&#x27;html.parser&#x27;</span>)  <span class="comment"># 这里一定要指定解析器，可以使用默认的 html，也可以使用 lxml。 </span></span><br><span class="line"><span class="built_in">print</span>(soup.prettify())  <span class="comment"># 按照标准的缩进格式输出获取的 soup 内容。 </span></span><br></pre></td></tr></table></figure><blockquote><p><code>bs4</code> 是 <code>BeautifulSoup</code> 库的简称，它是一个用于解析 HTML 和 XML 文档的 Python 库，通常用于网页抓取和数据分析。<code>BeautifulSoup</code> 能够处理复杂的 HTML 网页内容，并提供简单易用的 API 来访问和修改数据。</p><p><code>BeautifulSoup</code> 库的名字来源于一个儿童故事中的角色，这个角色喜欢“把字符串咀嚼成美味的网络抓取汤”，因此得名“BeautifulSoup”。</p></blockquote><h3 id="BeautifulSoup-的一些简单用法"><a href="#BeautifulSoup-的一些简单用法" class="headerlink" title="BeautifulSoup 的一些简单用法"></a>BeautifulSoup 的一些简单用法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(soup.title)  <span class="comment"># 获取文档的 title </span></span><br><span class="line"><span class="built_in">print</span>(soup.title.name)  <span class="comment"># 获取 title 的 name 属性 </span></span><br><span class="line"><span class="built_in">print</span>(soup.title.string)  <span class="comment"># 获取 title 的内容 </span></span><br><span class="line"><span class="built_in">print</span>(soup.p)  <span class="comment"># 获取文档中第一个 p 节点 </span></span><br><span class="line"><span class="built_in">print</span>(soup.p[<span class="string">&#x27;class&#x27;</span>])  <span class="comment"># 获取第一个 p 节点的 class 内容 </span></span><br><span class="line"><span class="built_in">print</span>(soup.find_all(<span class="string">&#x27;a&#x27;</span>))  <span class="comment"># 获取文档中所有的 a 节点，返回一个 list </span></span><br><span class="line"><span class="built_in">print</span>(soup.find_all(<span class="string">&#x27;span&#x27;</span>, attrs=&#123;<span class="string">&#x27;style&#x27;</span>: <span class="string">&quot;color:#ff0000&quot;</span>&#125;))  <span class="comment"># 获取文档中所有的 span 且 style 符合规则的节点，返回一个 list </span></span><br></pre></td></tr></table></figure><p>在HTML和XML文档中，<code>p</code> 结点通常指的是 <code>&lt;p&gt;</code> 标签创建的元素，它代表一个段落（Paragraph）。<code>&lt;p&gt;</code> 标签是块级元素，用于定义文本的一个段落。在网页中，浏览器会在段落之间添加一些垂直的空白，以区分不同的段落。<br>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是另一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上面的HTML代码中，每个 <code>&lt;p&gt;</code> 元素都定义了一个文本段落。<br>同样，<code>a</code> 结点指的是 <code>&lt;a&gt;</code> 标签创建的元素，它代表一个锚点（Anchor）。<code>&lt;a&gt;</code> 标签用于创建超链接，允许用户通过点击跳转到其他网页、文件、位置或其他资源。<code>&lt;a&gt;</code> 标签可以包含文本、图片等任何内容，并且通常有一个 <code>href</code> 属性，指定了链接的目标URL。<br>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.example.com&quot;</span>&gt;</span>访问示例网站<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上面的HTML代码中，<code>&lt;a&gt;</code> 元素创建了一个文本为“访问示例网站”的超链接，当用户点击这个链接时，浏览器会跳转到 <code>https://www.example.com</code> 这个URL。</p><h3 id="find-all"><a href="#find-all" class="headerlink" title="find_all"></a>find_all</h3><p>在Python的<code>BeautifulSoup</code>库中，<code>find_all</code>方法用于搜索HTML或XML文档，并返回所有匹配指定条件的元素。<code>find_all</code>方法可以接受多种参数，包括要查找的标签名、属性、CSS类等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data = content.find_all(<span class="string">&#x27;div&#x27;</span>, attrs=&#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;cover&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure><p>这行代码的作用是：</p><ol><li><code>content</code> 是一个 <code>BeautifulSoup</code> 对象，它代表了已经解析的HTML文档。</li><li><code>find_all</code> 方法被调用，第一个参数 <code>&#39;div&#39;</code> 指定了要搜索的标签名，即 <code>&lt;div&gt;</code>。</li><li><code>attrs=&#123;&#39;class&#39;: &#39;cover&#39;&#125;</code> 参数指定了要搜索的 <code>&lt;div&gt;</code> 标签必须具有 <code>class</code> 属性，且属性值包含 <code>cover</code>。这意味着 <code>find_all</code> 方法将返回所有类名为 <code>cover</code> 的 <code>&lt;div&gt;</code> 元素。</li></ol><p>结果 <code>data</code> 将是一个列表，包含了文档中所有匹配的 <code>&lt;div&gt;</code> 元素。每个元素都是一个 <code>Tag</code> 对象，你可以对这些对象进行进一步的操作，例如提取文本、属性或其他嵌套的标签。</p><p>例如，如果您想要遍历这些 <code>&lt;div&gt;</code> 元素并打印它们的文本内容，可以这样做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> div <span class="keyword">in</span> data:</span><br><span class="line">    <span class="built_in">print</span>(div.get_text())</span><br></pre></td></tr></table></figure><p>这将会打印出每个类名为 <code>cover</code> 的 <code>&lt;div&gt;</code> 元素中的文本内容。</p><blockquote><p><code>&lt;div&gt;</code>元素是HTML文档中的一个块级元素，它用于定义文档中的一个区域或部分，并且可以用来组合其他HTML元素。<code>&lt;div&gt;</code>是 “division” 的缩写，意为“分区”。</p></blockquote><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>在 <code>BeautifulSoup</code> 中，<code>find</code> 方法用于搜索当前元素下的子元素，并返回第一个匹配的元素。如果找到了多个匹配的元素，<code>find</code> 方法只返回第一个匹配的元素。如果没有找到匹配的元素，则返回 <code>None</code>。</p><p>例如，假设我们有以下HTML代码片段：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cover&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;image1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图片1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;image2.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图片2&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果我们已经有一个 <code>BeautifulSoup</code> 对象 <code>d</code>，它代表上面的 <code>&lt;div&gt;</code> 元素，那么我们可以使用 <code>d.find(&#39;img&#39;)</code> 来找到第一个 <code>&lt;img&gt;</code> 子元素。</p><p>我们可以进一步从 <code>img_tag</code> 中获取 <code>src</code> 属性，得到图片的URL：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img_url = img_tag[<span class="string">&#x27;src&#x27;</span>]</span><br></pre></td></tr></table></figure><p>在这里，<code>img_url</code> 的值将是 <code>&quot;image1.jpg&quot;</code>。</p><h3 id="get-text"><a href="#get-text" class="headerlink" title="get_text"></a>get_text</h3><p>在 <code>BeautifulSoup</code> 中，<code>get_text()</code> 方法是一个用于提取标签内文本内容的方法。它将返回一个字符串，该字符串包含指定标签及其所有子标签的文本内容，而不包含任何HTML标签或属性。</p><p><code>get_text()</code> 方法可以用于任何 <code>Tag</code> 对象，它会递归地提取所有子标签的文本，并将它们连接成一个字符串。<br>这里有一些 <code>get_text()</code> 方法的基本用法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="comment"># 假设我们有以下HTML内容</span></span><br><span class="line">html_doc = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">&lt;head&gt;</span></span><br><span class="line"><span class="string">    &lt;title&gt;Page Title&lt;/title&gt;</span></span><br><span class="line"><span class="string">&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;p&gt;这是一个段落。&lt;/p&gt;</span></span><br><span class="line"><span class="string">        &lt;a href=&quot;http://example.com&quot;&gt;这是一个链接&lt;/a&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 使用 BeautifulSoup 解析 HTML</span></span><br><span class="line">soup = BeautifulSoup(html_doc, <span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取整个文档的文本内容</span></span><br><span class="line">text = soup.get_text()</span><br><span class="line"><span class="built_in">print</span>(text)</span><br></pre></td></tr></table></figure><p>输出将会是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Page Title</span><br><span class="line">这是一个段落。</span><br><span class="line">这是一个链接</span><br></pre></td></tr></table></figure><br>你也可以在特定的标签上调用 <code>get_text()</code> 方法来提取该标签及其子标签的文本：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取特定标签 &lt;div&gt; 的文本内容</span></span><br><span class="line">div_text = soup.div.get_text()</span><br><span class="line"><span class="built_in">print</span>(div_text)</span><br></pre></td></tr></table></figure><br>输出将会是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这是一个段落。</span><br><span class="line">这是一个链接</span><br></pre></td></tr></table></figure><br><code>get_text()</code> 方法还有一些参数，可以用来控制如何提取文本：</p><ul><li><code>strip</code>: 布尔值，默认为 <code>False</code>，表示是否去除文本前后的空白字符。</li><li><code>separator</code>: 字符串，用于连接各个文本片段的分隔符，默认为 “”，表示不添加分隔符。</li></ul><h1 id="下载图片"><a href="#下载图片" class="headerlink" title="下载图片"></a>下载图片</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">download_picture</span>(<span class="params">pic_l</span>): </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">r&#x27;picture&#x27;</span>): </span><br><span class="line">        os.mkdir(<span class="string">r&#x27;picture&#x27;</span>) </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> pic_l: </span><br><span class="line">        pic = requests.get(i) </span><br><span class="line">        p_name = i.split(<span class="string">&#x27;/&#x27;</span>)[<span class="number">7</span>] </span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;picture\\&#x27;</span> + p_name, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f: </span><br><span class="line">            f.write(pic.content) </span><br></pre></td></tr></table></figure><ol><li><code>if not os.path.exists(r&#39;picture&#39;):</code><ul><li>这个条件判断语句检查在当前目录下是否存在一个名为 <code>picture</code> 的文件夹。<code>os.path.exists</code>是一个检查路径是否存在的函数，<code>r&#39;picture&#39;</code> 表示 <code>picture</code> 文件夹的路径，<code>r</code> 前缀表示这是一个原始字符串，不处理反斜杠 <code>\</code> 作为转义字符。</li></ul></li><li><code>os.mkdir(r&#39;picture&#39;)</code><ul><li>如果上述条件成立（即 <code>picture</code> 文件夹不存在），这行代码会创建一个名为 <code>picture</code> 的新文件夹。</li></ul></li><li><code>pic = requests.get(i)</code><ul><li>在循环内部，这行代码使用 <code>requests.get</code> 函数从互联网上获取（下载）URL <code>i</code> 指向的图片内容，并将响应内容赋值给变量 <code>pic</code>。</li></ul></li><li><code>p_name = i.split(&#39;/&#39;)[7]</code><ul><li>这行代码将URL <code>i</code> 按照斜杠 <code>/</code> 分割成多个部分，并取出第8个部分（列表索引为7）作为图片的文件名。这里假设URL的第八部分是图片的文件名。</li></ul></li><li><code>with open(&#39;picture\\&#39; + p_name, &#39;wb&#39;) as f:</code><ul><li>这行代码打开一个文件，文件路径是 <code>picture</code> 文件夹加上图片的文件名 <code>p_name</code>，文件以二进制写模式（‘wb’）打开。<code>with</code> 语句确保文件使用后会被正确关闭。变量 <code>f</code> 是打开文件的引用。</li></ul></li><li><code>f.write(pic.content)</code><ul><li>最后，这行代码将下载的图片内容 <code>pic.content</code> 写入到文件 <code>f</code> 中，完成图片的保存。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 重生之我是程序员 </category>
          
          <category> Python笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>你好</title>
      <link href="/post/10739.html"/>
      <url>/post/10739.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
